import { getAllFragmentNames, getFragment, graphqlTypeToCollectionName, getCollection, getAllCollections, isValidCollectionName } from '../../lib/vulcan-lib';
import { generatedFileHeader, assert, simplSchemaTypeToTypescript, graphqlTypeToTypescript } from './typeGenerationUtils';
import { getSchema } from '../../lib/utils/getSchema';
import groupBy from 'lodash/groupBy';
import type { FieldNode, SelectionNode } from 'graphql';

const fragmentFileHeader = generatedFileHeader+`//
// Contains Typescript signatures for fragments, generated by
// server/codegen/generateFragmentTypes.ts.
//
`

export function generateFragmentTypes(): string {
  const fragmentNames: Array<FragmentName> = getAllFragmentNames();  
  const sb: Array<string> = [];
  
  for (let fragmentName of fragmentNames) {
    sb.push(generateFragmentTypeDefinition(fragmentName));
  }
  
  sb.push(generateFragmentsIndexType());
  sb.push(generateCollectionNamesByFragmentNameType());
  sb.push(generateCollectionNamesIndexType());
  sb.push(generateCollectionNamesWithCreatedAtIndexType());
  sb.push(generateCollectionNamesWithSlugIndexType());
  
  return fragmentFileHeader + sb.join('');
}

type ParsedFragmentType = ReturnType<typeof getParsedFragment>;

function getParsedFragment(fragmentName: FragmentName) {
  const fragmentDefinitions = getFragment(fragmentName);
  
  // `getFragment` returns the parsed definition of a fragment plus all of its
  // dependency fragments. The one we requested will be first.
  assert((fragmentDefinitions?.definitions?.length ?? 0) > 0);
  const parsedFragment = fragmentDefinitions?.definitions[0];
  assert(parsedFragment?.kind === "FragmentDefinition");
  if (!parsedFragment || !("name" in parsedFragment) || !("selectionSet" in parsedFragment) || parsedFragment?.name?.value !== fragmentName) {
    throw new Error("Retrieved parsed fragment with wrong name");
  }
  return parsedFragment;
}

function fragmentNameToCollectionName(fragmentName: FragmentName): CollectionNameString {
  const parsedFragment = getParsedFragment(fragmentName);
  if (!parsedFragment || !("typeCondition" in parsedFragment)) {
    throw new Error("Not a type node");
  }
  const typeName = parsedFragment.typeCondition.name?.value;
  const collectionName = graphqlTypeToCollectionName(typeName!);
  return collectionName;
}

function generateFragmentTypeDefinition(fragmentName: FragmentName): string {
  const parsedFragment = getParsedFragment(fragmentName);
  const collectionName = fragmentNameToCollectionName(fragmentName);
  const collection = isValidCollectionName(collectionName) ? getCollection(collectionName) : null;
  
  return fragmentToInterface(fragmentName, parsedFragment, collection);
}

function generateFragmentsIndexType(): string {
  const fragmentNames: Array<FragmentName> = getAllFragmentNames();
  const sb: Array<string> = [];
  
  sb.push('interface FragmentTypes {\n');
  for (let fragmentName of fragmentNames) {
    sb.push(`  ${fragmentName}: ${fragmentName}\n`);
  }
  sb.push('}\n\n');
  
  const fragmentNamesByCollection = groupBy(fragmentNames, (f: FragmentName): CollectionNameString => fragmentNameToCollectionName(f));
  sb.push(`interface FragmentTypesByCollection {\n`);
  for (const collectionName of Object.keys(fragmentNamesByCollection)) {
    sb.push(`  ${collectionName}: `);
    sb.push(fragmentNamesByCollection[collectionName].map(f=>`"${f}"`).join("|"));
    sb.push("\n");
  }
  sb.push('}\n\n');
  
  return sb.join('');
}

function generateCollectionNamesByFragmentNameType(): string {
  const fragmentNames: Array<FragmentName> = getAllFragmentNames();
  const sb: Array<string> = [];
  
  sb.push(`interface CollectionNamesByFragmentName {\n`);
  for (let fragmentName of fragmentNames) {
    const collectionName = fragmentNameToCollectionName(fragmentName);
    if (isValidCollectionName(collectionName)) {
      sb.push(`  ${fragmentName}: "${collectionName}"\n`);
    } else {
      sb.push(`  ${fragmentName}: never\n`);
    }
  }
  sb.push('}\n\n');
  
  return sb.join('');
}

const generateCollectionNameList = (
  name: string,
  collections: CollectionBase<CollectionNameString>[],
): string =>
  `type ${name} = ${collections.map(c => `"${c.collectionName}"`).join('|')}\n\n`;

const generateCollectionNamesIndexType = () =>
  generateCollectionNameList("CollectionNameString", getAllCollections());

const generateCollectionNamesWithCreatedAtIndexType = () =>
  generateCollectionNameList(
    "CollectionNameWithCreatedAt",
    getAllCollections().filter((c) => !!c._schemaFields.createdAt),
  );

const generateCollectionNamesWithSlugIndexType = () =>
  generateCollectionNameList(
    "CollectionNameWithSlug",
    getAllCollections().filter((c) => !!c._schemaFields.slug),
  );

function fragmentToInterface(interfaceName: string, parsedFragment: ParsedFragmentType | FieldNode, collection: AnyBecauseTodo): string {
  const sb: Array<string> = [];
  
  const spreadFragments = getSpreadFragments(parsedFragment);
  const inheritanceStr = spreadFragments.length>0 ? ` extends ${spreadFragments.join(', ')}` : "";
  
  // Process all selections to determine field types
  const allSubfragments: Array<string> = [];
  const fields: Array<string> = [];
  
  for (let selection of parsedFragment.selectionSet?.selections ?? []) {
    if (selection.kind === "Field") {
      const fieldTypeResult = getFragmentFieldType(interfaceName, selection, collection);
      
      if (fieldTypeResult.kind === "union") {
        const fieldName = selection.name.value;
        
        // Generate base interface for the union
        sb.push(`interface ${interfaceName}_${fieldName}_Base {\n`);
        sb.push(`  readonly __typename: string,\n`);
        sb.push('}\n\n');

        // Generate interfaces for each union case
        for (let unionCase of fieldTypeResult.unionCases) {
          const unionTypeCollection = getCollection(graphqlTypeToCollectionName(unionCase.typeName));
          const caseFields: Array<string> = [];
          const caseSubfragments: Array<string> = [];
          
          // Include all base fields for this specific type
          for (let baseField of fieldTypeResult.baseFields) {
            if (baseField.name.value === "__typename") continue;
            
            const fieldType = getFragmentFieldType(
              `${interfaceName}_${fieldName}_${unionCase.typeName}`,
              baseField,
              unionTypeCollection
            );
            if (fieldType.kind === "simple") {
              caseFields.push(`  readonly ${baseField.name.value}: ${fieldType.fieldType}`);
              if (fieldType.subfragment) caseSubfragments.push(fieldType.subfragment);
            }
          }
          
          // Include type-specific fields
          for (let field of unionCase.fields) {
            const fieldType = getFragmentFieldType(
              `${interfaceName}_${fieldName}_${unionCase.typeName}`,
              field,
              unionTypeCollection
            );
            if (fieldType.kind === "simple") {
              caseFields.push(`  readonly ${field.name.value}: ${fieldType.fieldType}`);
              if (fieldType.subfragment) caseSubfragments.push(fieldType.subfragment);
            }
          }
          
          // Add subfragments first
          caseSubfragments.forEach(subfrag => sb.push(subfrag));
          
          // Then add the interface
          sb.push(`interface ${interfaceName}_${fieldName}_${unionCase.typeName} {\n`);
          sb.push(`  readonly __typename: "${unionCase.typeName}",\n`);
          if (caseFields.length > 0) {
            sb.push(caseFields.join(',\n'));
            sb.push(',\n');
          }
          sb.push('}\n\n');
        }

        // Generate the union type
        sb.push(`type ${interfaceName}_${fieldName} = ${interfaceName}_${fieldName}_Base & (\n`);
        sb.push(fieldTypeResult.unionCases
          .map(c => `  | ${interfaceName}_${fieldName}_${c.typeName}`)
          .join('\n'));
        sb.push('\n);\n\n');

        // Add this field to the parent interface
        fields.push(`  readonly ${fieldName}: ${interfaceName}_${fieldName}`);
      } else {
        // Collect fields for simple case
        fields.push(`  readonly ${selection.name.value}: ${fieldTypeResult.fieldType}`);
        if (fieldTypeResult.subfragment) allSubfragments.push(fieldTypeResult.subfragment);
      }
    } else if (selection.kind === "FragmentSpread") {
      // We handle these with the inheritanceStr
    }
  }
  
  // Generate interface if we have fields OR fragment spreads
  if (fields.length > 0 || spreadFragments.length > 0) {
    sb.push(`interface ${interfaceName}${inheritanceStr} { // fragment on ${collection?.collectionName ?? "non-collection type"}\n`);
    if (fields.length > 0) {
      sb.push(fields.join(',\n'));
      sb.push(',\n');
    }
    sb.push('}\n\n');
  }
  
  // Add any subfragments for non-union fields
  for (let subfragment of allSubfragments) {
    sb.push(subfragment);
  }
  
  return sb.join('');
}

function getSpreadFragments(parsedFragment: ParsedFragmentType | FieldNode): Array<string> {
  const spreadFragmentNames: Array<string> = [];
  for (let selection of parsedFragment.selectionSet?.selections ?? []) {
    if(selection.kind === "FragmentSpread") {
      spreadFragmentNames.push(selection.name.value);
    }
  }
  return spreadFragmentNames;
}

interface UnionCase {
  typeName: string;
  fields: FieldNode[];
}

type FieldTypeResult = {
  kind: "simple";
  fieldType: string;
  subfragment: string|null;
} | {
  kind: "union";
  baseFields: FieldNode[];
  unionCases: UnionCase[];
  // We'll still need the collection info for nested field resolution
  collection: CollectionBase<any>|null;
};

function getFragmentFieldType(
  fragmentName: string,
  parsedFragmentField: FieldNode,
  collection: AnyBecauseTodo
): FieldTypeResult {
  // If there are inline fragments, this is a union type
  const hasInlineFragments = parsedFragmentField.selectionSet?.selections.some(
    selection => selection.kind === "InlineFragment"
  );
  
  if (hasInlineFragments) {
    const { baseFields, unionCases } = groupUnionSelections(
      parsedFragmentField.selectionSet!.selections
    );
    
    return {
      kind: "union",
      baseFields,
      unionCases,
      collection
    };
  }
  
  // Original logic for simple fields
  if (collection === null) {
    // Fragments may not correspond to a collection, if eg they're on a graphql
    // type defined with addGraphQLSchema. In that case, emit a type with the
    // right set of fields but with every field having type `any` because sadly
    // we aren't yet tracking down the schema definition.
    return { kind: "simple", fieldType: "any", subfragment: null };
  }

  const fieldName: string = parsedFragmentField.name.value;
  if (fieldName === "__typename") {
    return { kind: "simple", fieldType: "string", subfragment: null };
  }
  const schema = getSchema(collection);
  
  // There are two ways a field name can appear in a schema. The first is as a
  // regular field with that name. The second is as a resolver with that name,
  // which may be attached to a field with the same name or a different name.
  // If there's a resolver, it takes precedence.
  
  let fieldType: string|null = null;
  
  // Check for a field with a resolver by this name
  for (let schemaFieldName of Object.keys(schema)) {
    const fieldWithResolver = schema[schemaFieldName];
    if (fieldWithResolver?.resolveAs?.fieldName === fieldName) {
      if (fieldWithResolver.typescriptType) {
        fieldType = fieldWithResolver.typescriptType;
      } else {
        assert(!!fieldWithResolver.resolveAs.type);
        fieldType = graphqlTypeToTypescript(fieldWithResolver.resolveAs.type);
      }
      break;
    }
  }
  
  // Check for regular presence in the schema
  if (!fieldType) {
    if (fieldName in schema) {
      const fieldSchema = schema[fieldName];
      assert(fieldSchema?.type);
      if (fieldSchema?.typescriptType && fieldSchema?.blackbox) {
        fieldType = fieldSchema.typescriptType;
      } else if (fieldSchema?.resolveAs?.type && !fieldSchema?.resolveAs?.fieldName) {
        // If the field is a string with allowed values, we need to emit a type that matches the allowed values
        // It'd be annoying to refactor graphqlTypeToTypescript to support this, so we just special-case strings with allowed values here
        // Annoyingly, allowedValues seems to get reassigned from being a top-level field to being on the `type` (probably when it's run through SimpleSchema somewhere)
        if (fieldSchema.resolveAs.type === 'String' && fieldSchema.type?.definitions[0]?.allowedValues?.length) {
          fieldType = simplSchemaTypeToTypescript(schema, fieldName, fieldSchema.type);
        } else {
          fieldType = graphqlTypeToTypescript(fieldSchema.resolveAs.type);
        }
      } else {
        fieldType = simplSchemaTypeToTypescript(schema, fieldName, schema[fieldName].type);
      }
    }
  }
  
  // If neither found, error (fragment contains a field that isn't in the schema)
  if (!fieldType) {
    throw new Error(`Fragment ${fragmentName} contains field ${fieldName} on type ${collection.collectionName} which is not in the schema`);
  }

  const {collection: subfieldCollection, nullable} = subfragmentTypeToCollection(fieldType);
  
  // Now check if the field has a sub-selector
  const selectionSet = parsedFragmentField.selectionSet;
  if (selectionSet?.selections?.length) {
    // As a special case, if the sub-selector spreads a fragment and has no
    // other fields, use that fragment's type
    if (selectionSet.selections.length === 1
      && selectionSet.selections[0].kind === "FragmentSpread")
    {
      const subfragmentName = selectionSet.selections[0].name.value;
      if (fieldType.startsWith("Array<")) {
        return {
          kind: "simple",
          fieldType: nullable ? `Array<${subfragmentName}>|null` : `Array<${subfragmentName}>`,
          subfragment: null
        };
      } else {
        return {
          kind: "simple",
          fieldType: nullable ? `${subfragmentName}|null` : subfragmentName,
          subfragment: null
        };
      }
    }
    else
    {
      if (typeof fieldType !== "string") throw new Error("fieldType is not a string: was "+JSON.stringify(fieldType));
      if (!subfieldCollection) {
        // eslint-disable-next-line no-console
        console.log(`Field ${fieldName} in fragment ${fragmentName} has type ${fieldType} which does not identify a collection`);
        //throw new Error(`Field ${fieldName} in fragment ${fragmentName} has type ${fieldType} which does not identify a collection`);
        return {
          kind: "simple",
          fieldType: "any",
          subfragment: null
        };
      }
      const subfragmentName = `${fragmentName}_${fieldName}`;
      const subfragment = fragmentToInterface(subfragmentName, parsedFragmentField, subfieldCollection);
      
      // If it's an array type, then it's an array of that subfragment. Otherwise it's an instance of that subfragment.
      if (fieldType.startsWith("Array<")) {
        return {
          kind: "simple",
          fieldType: nullable ? `Array<${subfragmentName}>|null` : `Array<${subfragmentName}>`,
          subfragment: subfragment,
        };
      } else {
        return {
          kind: "simple",
          fieldType: nullable ? `${subfragmentName}|null` : subfragmentName,
          subfragment: subfragment,
        };
      }
    }
  } else {
    return {
      kind: "simple",
      fieldType,
      subfragment: null
    };
  }
}

function groupUnionSelections(selections: readonly SelectionNode[]) {
  const baseFields: FieldNode[] = [];
  const unionCases: UnionCase[] = [];
  
  for (const selection of selections) {
    if (selection.kind === "Field") {
      baseFields.push(selection);
    } else if (selection.kind === "InlineFragment" && selection.typeCondition) {
      unionCases.push({
        typeName: selection.typeCondition.name.value,
        fields: selection.selectionSet.selections.filter((s): s is FieldNode => s.kind === "Field")
      });
    }
  }
  
  return { baseFields, unionCases };
}

// Given the type of a field (as a string which is a Typescript type), where
// that field is a collection type with optional array- or nullable-wrapping,
// return the collection.
function subfragmentTypeToCollection(fieldType: string): {
  collection: CollectionBase<any>|null,
  nullable: boolean,
}{
  if (fieldType.startsWith("Array<") && fieldType.endsWith(">")) {
    return {
      collection: subfragmentTypeToCollection(fieldType.substr(6, fieldType.length-7)).collection,
      nullable: false,
    };
  } else if (fieldType.endsWith("|null")) {
    return {
      collection: subfragmentTypeToCollection(fieldType.substr(0, fieldType.length-5)).collection,
      nullable: true,
    };
  } else if (fieldType.endsWith("!")) {
    return {
      collection: subfragmentTypeToCollection(fieldType.substr(0, fieldType.length-1)).collection,
      nullable: false
    };
  } else {
    const collectionName = graphqlTypeToCollectionName(fieldType);
    if (isValidCollectionName(collectionName)) {
      return {
        collection: getCollection(collectionName),
        nullable: false
      };
    } else {
      return {
        collection: null,
        nullable: false
      }
    }
  }
}
