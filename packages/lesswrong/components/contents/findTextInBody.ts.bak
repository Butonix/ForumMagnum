import { nextTextNodeAfter } from "@/lib/utils/rawDom";
import type { ContentReplacedSubstringComponentInfo } from "../common/ContentItemBody";
import range from 'lodash/range';

type TextNodeWithOffset = {
  node: Text,
  str: string,
  offset: number,
}

type PreparedSubstitution = {
  searchStrings: ContentReplacedSubstringComponentInfo[],
  textNodes: Text[],
}

/**
 * Given a DOM element root and a set of search/replacements, prepare the DOM
 * for substitution. First, we find each string that will be substituted, and
 * split text nodes such that every substitution starts and ends at a node
 * boundary. Then, we organize the substitutions into an array of substitution
 * ranges, where each has a (contiguous, consecutive, disjoint) array of text
 * nodes affected, and a list of substitutions that apply to those nodes.
 */
export function prepareSubstitutions({ root, searchStrings }: {
  root: HTMLElement,
  searchStrings: ContentReplacedSubstringComponentInfo[]
}): PreparedSubstitution[] {
  // Take the given DOM and flatten it into a single large searchable string, while capturing
  // indexes such that we can map results from the string back to the corresponding location in
  // the DOM.
  const textNodes: Text[] = [];
  collectTextSegments(textNodes, root);
  
  const textNodesWithOffsets: TextNodeWithOffset[] = [];
  let currentOffset = 0;
  for (const node of textNodes) {
    const text = node.textContent ?? "";
    textNodesWithOffsets.push({
      node,
      str: text,
      offset: currentOffset
    });
    currentOffset += text.length;
  }

  // Join text into a single string (and a lowercase string) for efficient searching
  const allText = textNodesWithOffsets.map(n => n.str).join("");
  const allTextLowerCase = normalizeForStringSearch(allText);

  // Find instances of search strings in the combined string
  const searchResults: Array<{
    searchString: ContentReplacedSubstringComponentInfo,
    globalStartOffset: number,
    globalEndOffset: number,
    startNode: Text,
    startOffset: number,
    endNode: Text,
    endOffset: number,
  }> = [];
  
  for (const searchString of searchStrings) {
    const stringToSearchIn = searchString.caseInsensitive
      ? allTextLowerCase : allText;
    const stringToSearchFor = searchString.caseInsensitive
      ? normalizeForStringSearch(searchString.replacedString) : searchString.replacedString;
    let resultOffsets: number[] = [];
    
    let endOfLastResult = 0;
    let idx: number;
    do {
      idx = stringToSearchIn.indexOf(stringToSearchFor, endOfLastResult);
      if (idx >= 0) {
        endOfLastResult = idx + stringToSearchFor.length;
        const start = stringOffsetToTextNode(idx, textNodesWithOffsets)?.nodeWithOffset;
        const end = stringOffsetToTextNode(idx + stringToSearchFor.length, textNodesWithOffsets)?.nodeWithOffset;
        if (start && end) {
          searchResults.push({
            searchString,
            globalStartOffset: idx,
            globalEndOffset: idx + stringToSearchFor.length,
            startNode: start.node,
            startOffset: idx - start.offset,
            endNode: end.node,
            endOffset: idx + stringToSearchFor.length - end.offset,
          });
        }
      }
    } while (idx >= 0 && searchString.replace === "all")
  }

  // Collect a list of locations where the start or end of a search result
  // landed in the middle of a text node
  let splitPoints: Array<{node: Text, globalOffset: number, nodeOffset: number}> = [
    ...searchResults
      .filter(r => r.startOffset !== 0)
      .map(r => ({node: r.startNode, globalOffset: r.globalStartOffset, nodeOffset: r.startOffset})),
    ...searchResults
      .filter(r => r.endOffset !== 0)
      .map(r => ({node: r.endNode, globalOffset: r.globalEndOffset, nodeOffset: r.endOffset}))
  ];

  // Sort and deduplicate that list
  splitPoints.sort((a,b) => (a.globalOffset - b.globalOffset));
  let splitsByNode: Array<{
    globalOffset: number,
    nodeToSplit: Text,
    placesToSplit: number[],
  }> = [];
  for (let i=0; i<splitPoints.length; i++) {
    const splitPoint = splitPoints[i];
    if (i!==0 && splitPoint.globalOffset === splitPoints[i-1].globalOffset) {
      // Skip duplicate
      continue;
    }
    
    if (i>0 && splitPoint.node === splitPoints[i-1].node) {
      splitsByNode[splitsByNode.length-1].placesToSplit.push(splitPoint.nodeOffset);
    } else {
      splitsByNode.push({
        globalOffset: splitPoint.globalOffset,
        nodeToSplit: splitPoint.node,
        placesToSplit: [splitPoint.nodeOffset],
      });
    }
  }
  
  // Split text nodes at the start/end of search results
  const splitTextNodesByGlobalStartOffset: Record<number,Text> = {};
  for (const splitNode of splitsByNode) {
    const resultTextNodes = splitTextNodeAtOffsets(splitNode.nodeToSplit, splitNode.placesToSplit);
    
    const originalTextNodeWithOffset = stringOffsetToTextNode(splitNode.globalOffset, textNodesWithOffsets);
    if (!originalTextNodeWithOffset) throw new Error("Split text node not found");
    textNodesWithOffsets.splice(originalTextNodeWithOffset.index, 1, ...range(0,resultTextNodes.length).map(i => ({
      node: resultTextNodes[i],
      str:resultTextNodes[i].textContent!,
      offset: splitNode.globalOffset + (i>0 ? splitNode.placesToSplit[i-1] : 0),
    })));
    
    resultTextNodes.forEach((node, index) => {
      const globalOffset = splitNode.globalOffset + splitNode.placesToSplit.slice(0, index).reduce((sum, offset) => sum + offset, 0);
      splitTextNodesByGlobalStartOffset[globalOffset] = node;
    });
  }
  
  // Organize substitutions into the result format
  const results: Array<{
    searchStrings: ContentReplacedSubstringComponentInfo[],
    textNodes: Text[],
  }> = [];

  // Sort searchResults by globalStartOffset
  searchResults.sort((a, b) => a.globalStartOffset - b.globalStartOffset);

  let currentResult: {
    searchStrings: ContentReplacedSubstringComponentInfo[],
    textNodes: Text[],
  } | null = null;

  for (const searchResult of searchResults) {
    const startNode = splitTextNodesByGlobalStartOffset[searchResult.globalStartOffset] || searchResult.startNode;
    const endNode = splitTextNodesByGlobalStartOffset[searchResult.globalEndOffset] || searchResult.endNode;
  
    if (!currentResult || currentResult.textNodes[currentResult.textNodes.length - 1] !== startNode) {
      // Start a new result
      if (currentResult) {
        results.push(currentResult);
      }
      currentResult = {
        searchStrings: [searchResult.searchString],
        textNodes: [],
      };
    } else {
      // Add to existing result
      currentResult.searchStrings.push(searchResult.searchString);
    }
  
    // Collect all text nodes between startNode and endNode
    let node: Node | null = startNode;
    while (node) {
      if (node.nodeType === Node.TEXT_NODE) {
        currentResult.textNodes.push(node as Text);
      }
      if (node === endNode) break;
      node = node.nextSibling;
    }
  }

  if (currentResult) {
    results.push(currentResult);
  }

  validatePreparedSubstitutions(results);
  return results;
}

function validatePreparedSubstitutions(substitutions: PreparedSubstitution[]) {
  function assert(condition: boolean, message: string) {
    if (!condition) {
      throw new Error(message);
    }
  }
  for (let substitution of substitutions) {
    assert(substitution.textNodes.length > 0, "Prepared substitutions must have at least one text node");
    assert(substitution.searchStrings.length > 0, "Prepared substitutions must have at least one search string applied");
    
    // Check that the text nodes are consecutive
    for (let i=0; i<substitution.textNodes.length-1; i++) {
      assert(nextTextNodeAfter(substitution.textNodes[i]) === substitution.textNodes[i+1], "Text nodes in a substitution are contiguous");
    }
  }
}

/**
 * Traverse a DOM subtree recursively, populating textSegments with a list of all text elements
 * (in traversal order). Skips nodes that aren't text nodes, as well as descendents of <style> and
 * <script> tags.
 */
function collectTextSegments(textSegments: Node[], root: HTMLElement): void {
  if (root.nodeType === Node.TEXT_NODE) {
    textSegments.push(root);
    return;
  } else if (root.nodeType === Node.ELEMENT_NODE) {
    const tagName = root.tagName.toLowerCase();
    if (tagName === 'style' || tagName === 'script')
      return;
    for (let i=0; i<root.childNodes.length; i++) {
      collectTextSegments(textSegments, root.childNodes[i] as HTMLElement);
    }
  }
}


/**
 * Given a list of text nodes in a DOM, paired with and sorted by their offset
 * in the implied textContent combined string, and an offset which falls inside
 * one of those text nodes, find that node by binary search.
 */
function stringOffsetToTextNode(offset: number, textNodesWithOffsets: TextNodeWithOffset[]): {
  nodeWithOffset: TextNodeWithOffset
  index: number
}|null {
  let left = 0;
  let right = textNodesWithOffsets.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    const currentNode = textNodesWithOffsets[mid];
    const nextNode = textNodesWithOffsets[mid + 1];
  
    if (offset >= currentNode.offset && (!nextNode || offset < nextNode.offset)) {
      return {
        nodeWithOffset: currentNode,
        index: mid
      }
    }
  
    if (offset < currentNode.offset) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }

  return null;
}

function splitTextNodeAtOffsets(node: Text, offsets: number[]): Text[] {
  if (!(node.nodeType === Node.TEXT_NODE)) {
    throw new Error('Input node must be a text node');
  }

  // Sort offsets in ascending order
  const sortedOffsets = [...new Set(offsets)].sort((a, b) => a - b);

  // Filter out invalid offsets
  const validOffsets = sortedOffsets.filter(offset => offset > 0 && offset < node.length);

  if (validOffsets.length === 0) {
    return [node]; // No valid offsets, return the original node
  }

  const parentNode = node.parentNode;
  if (!parentNode) {
    throw new Error('Text node must have a parent node');
  }

  let currentNode = node;
  let currentOffset = 0;
  const resultNodes: Text[] = [];

  for (const offset of validOffsets) {
    // Split the current node at the offset
    const nextNode = currentNode.splitText(offset - currentOffset);
    
    // Add the split node to the result list
    resultNodes.push(currentNode);
    
    // Move to the next node
    currentNode = nextNode;
    currentOffset = offset;
  }

  // Add the last node to the result list
  resultNodes.push(currentNode);

  return resultNodes;
}

/**
 * Normalize a string, for matching glossary terms. This includes
 * case-insensitivity, but is slightly broader; it also replaces:
 *   * Unicode special apostrophes with regular single quotes
 *   * non-break spaces with regular spaces
 * IMPORTANT: This must not change the string length (as measured in UTF-16
 * codepoints), as we will be mapping indexes back onto the original string.
 */
export const normalizeForStringSearch = (s: string): string => {
  return s.toLowerCase()
    .replace(/[\u2018\u2019\uff07]/g, "'")
    .replace(/[\u00a0]/g, " ")
}


