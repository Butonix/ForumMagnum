# Generated file - run 'yarn generate' to update.

scalar JSON
scalar Date
# Type for AdvisorRequests
  type AdvisorRequest {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  user: User 
  interestedInMetaculus: Boolean 
  jobAds: JSON 
  }


input DeleteAdvisorRequestInput{
  selector: AdvisorRequestSelectorUniqueInput!
}

input SingleAdvisorRequestInput {
  selector: AdvisorRequestSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiAdvisorRequestInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: AdvisorRequestSelectorInput
  orderBy: AdvisorRequestOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleAdvisorRequestOutput{
  result: AdvisorRequest
}

type MultiAdvisorRequestOutput{
  results: [AdvisorRequest]
  totalCount: Int
}

type AdvisorRequestOutput{
  data: AdvisorRequest
}

input CreateAdvisorRequestInput{
  data: CreateAdvisorRequestDataInput!
}

input CreateAdvisorRequestDataInput {
  legacyData: JSON 
  userId: String! 
  interestedInMetaculus: Boolean 
  jobAds: JSON 
}

input UpdateAdvisorRequestInput{
  selector: AdvisorRequestSelectorUniqueInput!
  data: UpdateAdvisorRequestDataInput!
}

input UpsertAdvisorRequestInput{
  selector: AdvisorRequestSelectorUniqueInput!
  data: UpdateAdvisorRequestDataInput!
}

input UpdateAdvisorRequestDataInput {
  legacyData: JSON 
  userId: String 
  interestedInMetaculus: Boolean 
  jobAds: JSON 
}

input AdvisorRequestSelectorInput {
  AND: [AdvisorRequestSelectorInput]
  OR: [AdvisorRequestSelectorInput]

}

input AdvisorRequestSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum AdvisorRequestOrderByInput {
  foobar
  
}



# Type for ArbitalCaches
  type ArbitalCaches {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  }


input DeleteArbitalCachesInput{
  selector: ArbitalCachesSelectorUniqueInput!
}

input SingleArbitalCachesInput {
  selector: ArbitalCachesSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiArbitalCachesInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ArbitalCachesSelectorInput
  orderBy: ArbitalCachesOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleArbitalCachesOutput{
  result: ArbitalCaches
}

type MultiArbitalCachesOutput{
  results: [ArbitalCaches]
  totalCount: Int
}

type ArbitalCachesOutput{
  data: ArbitalCaches
}

input CreateArbitalCachesInput{
  data: CreateArbitalCachesDataInput!
}

input CreateArbitalCachesDataInput {
  legacyData: JSON 
}

input UpdateArbitalCachesInput{
  selector: ArbitalCachesSelectorUniqueInput!
  data: UpdateArbitalCachesDataInput!
}

input UpsertArbitalCachesInput{
  selector: ArbitalCachesSelectorUniqueInput!
  data: UpdateArbitalCachesDataInput!
}

input UpdateArbitalCachesDataInput {
  legacyData: JSON 
}

input ArbitalCachesSelectorInput {
  AND: [ArbitalCachesSelectorInput]
  OR: [ArbitalCachesSelectorInput]

}

input ArbitalCachesSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ArbitalCachesOrderByInput {
  foobar
  
}



# Type for ArbitalTagContentRels
  type ArbitalTagContentRel {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  parentDocumentId: String 
  childDocumentId: String 
  parentCollectionName: String 
  childCollectionName: String 
  type: String 
  level: Float 
  isStrong: Boolean 
  }


input DeleteArbitalTagContentRelInput{
  selector: ArbitalTagContentRelSelectorUniqueInput!
}

input SingleArbitalTagContentRelInput {
  selector: ArbitalTagContentRelSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiArbitalTagContentRelInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ArbitalTagContentRelSelectorInput
  orderBy: ArbitalTagContentRelOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleArbitalTagContentRelOutput{
  result: ArbitalTagContentRel
}

type MultiArbitalTagContentRelOutput{
  results: [ArbitalTagContentRel]
  totalCount: Int
}

type ArbitalTagContentRelOutput{
  data: ArbitalTagContentRel
}

input CreateArbitalTagContentRelInput{
  data: CreateArbitalTagContentRelDataInput!
}

input CreateArbitalTagContentRelDataInput {
  legacyData: JSON 
  parentDocumentId: String! 
  childDocumentId: String! 
  parentCollectionName: String! 
  childCollectionName: String! 
  type: String! 
  level: Float! 
  isStrong: Boolean! 
}

input UpdateArbitalTagContentRelInput{
  selector: ArbitalTagContentRelSelectorUniqueInput!
  data: UpdateArbitalTagContentRelDataInput!
}

input UpsertArbitalTagContentRelInput{
  selector: ArbitalTagContentRelSelectorUniqueInput!
  data: UpdateArbitalTagContentRelDataInput!
}

input UpdateArbitalTagContentRelDataInput {
  legacyData: JSON 
}

input ArbitalTagContentRelSelectorInput {
  AND: [ArbitalTagContentRelSelectorInput]
  OR: [ArbitalTagContentRelSelectorInput]

}

input ArbitalTagContentRelSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ArbitalTagContentRelOrderByInput {
  foobar
  
}



# Type for Bans
  type Ban {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  expirationDate: Date 
  userId: String 
  user: User 
  ip: String 
  reason: String 
  comment: String 
  properties: JSON 
  }


input DeleteBanInput{
  selector: BanSelectorUniqueInput!
}

input SingleBanInput {
  selector: BanSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiBanInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: BanSelectorInput
  orderBy: BanOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleBanOutput{
  result: Ban
}

type MultiBanOutput{
  results: [Ban]
  totalCount: Int
}

type BanOutput{
  data: Ban
}

input CreateBanInput{
  data: CreateBanDataInput!
}

input CreateBanDataInput {
  legacyData: JSON 
  expirationDate: Date! 
  userId: String 
  ip: String 
  reason: String 
  comment: String 
  properties: JSON 
}

input UpdateBanInput{
  selector: BanSelectorUniqueInput!
  data: UpdateBanDataInput!
}

input UpsertBanInput{
  selector: BanSelectorUniqueInput!
  data: UpdateBanDataInput!
}

input UpdateBanDataInput {
  legacyData: JSON 
  expirationDate: Date 
  userId: String 
  ip: String 
  reason: String 
  comment: String 
  properties: JSON 
}

input BanSelectorInput {
  AND: [BanSelectorInput]
  OR: [BanSelectorInput]

}

input BanSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum BanOrderByInput {
  foobar
  
}



# Type for Books
  type Book {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  contents(version: String): Revision 
  contents_latest: String 
  postedAt: Date 
  title: String 
  subtitle: String 
  tocTitle: String 
  collectionId: String 
  number: Float 
  postIds: [String] 
  posts: [Post!]! 
  sequenceIds: [String] 
  sequences: [Sequence!]! 
  displaySequencesAsGrid: Boolean 
  hideProgressBar: Boolean 
  showChapters: Boolean 
  }


input DeleteBookInput{
  selector: BookSelectorUniqueInput!
}

input SingleBookInput {
  selector: BookSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiBookInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: BookSelectorInput
  orderBy: BookOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleBookOutput{
  result: Book
}

type MultiBookOutput{
  results: [Book]
  totalCount: Int
}

type BookOutput{
  data: Book
}

input CreateBookInput{
  data: CreateBookDataInput!
}

input CreateBookDataInput {
  legacyData: JSON 
  contents: JSON 
  title: String 
  subtitle: String 
  tocTitle: String 
  collectionId: String! 
  number: Float 
  postIds: [String] 
  sequenceIds: [String] 
  displaySequencesAsGrid: Boolean 
  hideProgressBar: Boolean 
  showChapters: Boolean 
}

input UpdateBookInput{
  selector: BookSelectorUniqueInput!
  data: UpdateBookDataInput!
}

input UpsertBookInput{
  selector: BookSelectorUniqueInput!
  data: UpdateBookDataInput!
}

input UpdateBookDataInput {
  legacyData: JSON 
  contents: JSON 
  title: String 
  subtitle: String 
  tocTitle: String 
  collectionId: String 
  number: Float 
  postIds: [String] 
  sequenceIds: [String] 
  displaySequencesAsGrid: Boolean 
  hideProgressBar: Boolean 
  showChapters: Boolean 
}

input BookSelectorInput {
  AND: [BookSelectorInput]
  OR: [BookSelectorInput]

}

input BookSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum BookOrderByInput {
  foobar
  
}



# Type for Chapters
  type Chapter {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  contents(version: String): Revision 
  contents_latest: String 
  title: String 
  subtitle: String 
  number: Float 
  sequenceId: String 
  sequence: Sequence! 
  postIds: [String] 
  posts: [Post!]! 
  }


input DeleteChapterInput{
  selector: ChapterSelectorUniqueInput!
}

input SingleChapterInput {
  selector: ChapterSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiChapterInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ChapterSelectorInput
  orderBy: ChapterOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleChapterOutput{
  result: Chapter
}

type MultiChapterOutput{
  results: [Chapter]
  totalCount: Int
}

type ChapterOutput{
  data: Chapter
}

input CreateChapterInput{
  data: CreateChapterDataInput!
}

input CreateChapterDataInput {
  legacyData: JSON 
  contents: JSON 
  title: String 
  subtitle: String 
  number: Float 
  sequenceId: String 
  postIds: [String]! 
}

input UpdateChapterInput{
  selector: ChapterSelectorUniqueInput!
  data: UpdateChapterDataInput!
}

input UpsertChapterInput{
  selector: ChapterSelectorUniqueInput!
  data: UpdateChapterDataInput!
}

input UpdateChapterDataInput {
  legacyData: JSON 
  contents: JSON 
  title: String 
  subtitle: String 
  number: Float 
  sequenceId: String 
  postIds: [String] 
}

input ChapterSelectorInput {
  AND: [ChapterSelectorInput]
  OR: [ChapterSelectorInput]

}

input ChapterSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ChapterOrderByInput {
  foobar
  
}



# Type for CkEditorUserSessions
  type CkEditorUserSession {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  documentId: String 
  userId: String 
  endedAt: Date 
  endedBy: String 
  }


input DeleteCkEditorUserSessionInput{
  selector: CkEditorUserSessionSelectorUniqueInput!
}

input SingleCkEditorUserSessionInput {
  selector: CkEditorUserSessionSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiCkEditorUserSessionInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: CkEditorUserSessionSelectorInput
  orderBy: CkEditorUserSessionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCkEditorUserSessionOutput{
  result: CkEditorUserSession
}

type MultiCkEditorUserSessionOutput{
  results: [CkEditorUserSession]
  totalCount: Int
}

type CkEditorUserSessionOutput{
  data: CkEditorUserSession
}

input CreateCkEditorUserSessionInput{
  data: CreateCkEditorUserSessionDataInput!
}

input CreateCkEditorUserSessionDataInput {
  legacyData: JSON 
  documentId: String! 
  userId: String! 
  endedAt: Date 
  endedBy: String 
}

input UpdateCkEditorUserSessionInput{
  selector: CkEditorUserSessionSelectorUniqueInput!
  data: UpdateCkEditorUserSessionDataInput!
}

input UpsertCkEditorUserSessionInput{
  selector: CkEditorUserSessionSelectorUniqueInput!
  data: UpdateCkEditorUserSessionDataInput!
}

input UpdateCkEditorUserSessionDataInput {
  legacyData: JSON 
  documentId: String 
  userId: String 
  endedAt: Date 
  endedBy: String 
}

input CkEditorUserSessionSelectorInput {
  AND: [CkEditorUserSessionSelectorInput]
  OR: [CkEditorUserSessionSelectorInput]

}

input CkEditorUserSessionSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum CkEditorUserSessionOrderByInput {
  foobar
  
}



# Type for ClientIds
  type ClientId {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  clientId: String 
  firstSeenReferrer: String 
  firstSeenLandingPage: String 
  userIds: [String] 
  users: [User!]! 
  invalidated: Boolean 
  lastSeenAt: Date 
  timesSeen: Float 
  }


input DeleteClientIdInput{
  selector: ClientIdSelectorUniqueInput!
}

input SingleClientIdInput {
  selector: ClientIdSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiClientIdInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ClientIdSelectorInput
  orderBy: ClientIdOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleClientIdOutput{
  result: ClientId
}

type MultiClientIdOutput{
  results: [ClientId]
  totalCount: Int
}

type ClientIdOutput{
  data: ClientId
}

input CreateClientIdInput{
  data: CreateClientIdDataInput!
}

input CreateClientIdDataInput {
  legacyData: JSON 
}

input UpdateClientIdInput{
  selector: ClientIdSelectorUniqueInput!
  data: UpdateClientIdDataInput!
}

input UpsertClientIdInput{
  selector: ClientIdSelectorUniqueInput!
  data: UpdateClientIdDataInput!
}

input UpdateClientIdDataInput {
  legacyData: JSON 
}

input ClientIdSelectorInput {
  AND: [ClientIdSelectorInput]
  OR: [ClientIdSelectorInput]

}

input ClientIdSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ClientIdOrderByInput {
  foobar
  
}



# Type for Collections
  type Collection {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  contents(version: String): Revision 
  contents_latest: String 
  userId: String 
  user: User 
  title: String 
  slug: String 
  books: [Book] 
  postsCount: Int! 
  readPostsCount: Int! 
  gridImageId: String 
  firstPageLink: String 
  hideStartReadingButton: Boolean 
  noindex: Boolean 
  }


input DeleteCollectionInput{
  selector: CollectionSelectorUniqueInput!
}

input SingleCollectionInput {
  selector: CollectionSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiCollectionInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: CollectionSelectorInput
  orderBy: CollectionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCollectionOutput{
  result: Collection
}

type MultiCollectionOutput{
  results: [Collection]
  totalCount: Int
}

type CollectionOutput{
  data: Collection
}

input CreateCollectionInput{
  data: CreateCollectionDataInput!
}

input CreateCollectionDataInput {
  createdAt: Date 
  legacyData: JSON 
  contents: JSON 
  title: String! 
  slug: String! 
  gridImageId: String 
  firstPageLink: String 
  hideStartReadingButton: Boolean 
  noindex: Boolean 
}

input UpdateCollectionInput{
  selector: CollectionSelectorUniqueInput!
  data: UpdateCollectionDataInput!
}

input UpsertCollectionInput{
  selector: CollectionSelectorUniqueInput!
  data: UpdateCollectionDataInput!
}

input UpdateCollectionDataInput {
  createdAt: Date 
  legacyData: JSON 
  contents: JSON 
  title: String 
  slug: String 
  gridImageId: String 
  firstPageLink: String 
  hideStartReadingButton: Boolean 
  noindex: Boolean 
}

input CollectionSelectorInput {
  AND: [CollectionSelectorInput]
  OR: [CollectionSelectorInput]

}

input CollectionSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum CollectionOrderByInput {
  foobar
  
}



# Type for CommentModeratorActions
  type CommentModeratorAction {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  commentId: String 
  comment: Comment! 
  type: String 
  endedAt: Date 
  active: Boolean! 
  }


input DeleteCommentModeratorActionInput{
  selector: CommentModeratorActionSelectorUniqueInput!
}

input SingleCommentModeratorActionInput {
  selector: CommentModeratorActionSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiCommentModeratorActionInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: CommentModeratorActionSelectorInput
  orderBy: CommentModeratorActionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCommentModeratorActionOutput{
  result: CommentModeratorAction
}

type MultiCommentModeratorActionOutput{
  results: [CommentModeratorAction]
  totalCount: Int
}

type CommentModeratorActionOutput{
  data: CommentModeratorAction
}

input CreateCommentModeratorActionInput{
  data: CreateCommentModeratorActionDataInput!
}

input CreateCommentModeratorActionDataInput {
  legacyData: JSON 
  commentId: String 
  type: String! 
  endedAt: Date 
}

input UpdateCommentModeratorActionInput{
  selector: CommentModeratorActionSelectorUniqueInput!
  data: UpdateCommentModeratorActionDataInput!
}

input UpsertCommentModeratorActionInput{
  selector: CommentModeratorActionSelectorUniqueInput!
  data: UpdateCommentModeratorActionDataInput!
}

input UpdateCommentModeratorActionDataInput {
  legacyData: JSON 
  commentId: String 
  type: String 
  endedAt: Date 
}

input CommentModeratorActionSelectorInput {
  AND: [CommentModeratorActionSelectorInput]
  OR: [CommentModeratorActionSelectorInput]

}

input CommentModeratorActionSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum CommentModeratorActionOrderByInput {
  foobar
  
}



# Type for Comments
  type Comment {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  contents(version: String): Revision 
  contents_latest: String 
  pingbacks: JSON 
  parentCommentId: String 
  parentComment: Comment 
  topLevelCommentId: String 
  topLevelComment: Comment 
  postedAt: Date 
  lastEditedAt: Date 
  author: String 
  postId: String 
  post: Post 
  tagId: String 
  tag: Tag 
  forumEventId: String 
  forumEvent: ForumEvent 
  forumEventMetadata: JSON 
  tagCommentType: String 
  subforumStickyPriority: Float 
  userId: String 
  user: User 
  userIP: String 
  userAgent: String 
  referrer: String 
  authorIsUnreviewed: Boolean 
  pageUrl: String 
  pageUrlRelative: String 
  answer: Boolean 
  parentAnswerId: String 
  parentAnswer: Comment 
  directChildrenCount: Float 
  descendentCount: Float 
  latestChildren: [Comment] 
  shortform: Boolean 
  shortformFrontpage: Boolean 
  nominatedForReview: String 
  reviewingForReview: String 
  lastSubthreadActivity: Date 
  postVersion: String 
  promoted: Boolean 
  promotedByUserId: String 
  promotedByUser: User 
  promotedAt: Date 
  hideKarma: Boolean 
  wordCount: Int 
  htmlBody: String 
  votingSystem: String! 
  legacy: Boolean 
  legacyId: String 
  legacyPoll: Boolean 
  legacyParentId: String 
  retracted: Boolean 
  deleted: Boolean 
  deletedPublic: Boolean 
  deletedReason: String 
  deletedDate: Date 
  deletedByUserId: String 
  deletedByUser: User 
  spam: Boolean 
  repliesBlockedUntil: Date 
  needsReview: Boolean 
  reviewedByUserId: String 
  reviewedByUser: User 
  hideAuthor: Boolean 
  moderatorHat: Boolean 
  hideModeratorHat: Boolean 
  isPinnedOnProfile: Boolean 
  title: String 
  relevantTagIds: [String] 
  relevantTags: [Tag!]! 
  debateResponse: Boolean 
  rejected: Boolean 
  modGPTAnalysis: String 
  modGPTRecommendation: String 
  rejectedReason: String 
  rejectedByUserId: String 
  rejectedByUser: User 
  emojiReactors: JSON 
  af: Boolean 
  suggestForAlignmentUserIds: [String] 
  suggestForAlignmentUsers: [User!]! 
  reviewForAlignmentUserId: String 
  afDate: Date 
  moveToAlignmentUserId: String 
  moveToAlignmentUser: User 
  agentFoundationsId: String 
  originalDialogueId: String 
  originalDialogue: Post 
  currentUserVote: String 
  currentUserExtendedVote: JSON 
  allVotes: [Vote] 
  voteCount: Float 
  baseScore: Float 
  extendedScore: JSON 
  score: Float 
  afBaseScore: Float 
  afExtendedScore: JSON 
  afVoteCount: Float 
  }


input DeleteCommentInput{
  selector: CommentSelectorUniqueInput!
}

input SingleCommentInput {
  selector: CommentSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiCommentInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: CommentSelectorInput
  orderBy: CommentOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCommentOutput{
  result: Comment
}

type MultiCommentOutput{
  results: [Comment]
  totalCount: Int
}

type CommentOutput{
  data: Comment
}

input CreateCommentInput{
  data: CreateCommentDataInput!
}

input CreateCommentDataInput {
  legacyData: JSON 
  contents: JSON 
  parentCommentId: String 
  topLevelCommentId: String 
  postId: String 
  tagId: String 
  forumEventId: String 
  forumEventMetadata: JSON 
  tagCommentType: String 
  subforumStickyPriority: Float 
  userId: String 
  authorIsUnreviewed: Boolean 
  answer: Boolean 
  parentAnswerId: String 
  shortform: Boolean 
  shortformFrontpage: Boolean 
  nominatedForReview: String 
  reviewingForReview: String 
  promotedByUserId: String 
  hideKarma: Boolean 
  legacy: Boolean 
  legacyId: String 
  legacyPoll: Boolean 
  legacyParentId: String 
  retracted: Boolean 
  deleted: Boolean 
  deletedPublic: Boolean 
  deletedReason: String 
  deletedDate: Date 
  deletedByUserId: String 
  spam: Boolean 
  needsReview: Boolean 
  reviewedByUserId: String 
  moderatorHat: Boolean 
  hideModeratorHat: Boolean 
  isPinnedOnProfile: Boolean 
  title: String 
  relevantTagIds: [String] 
  debateResponse: Boolean 
  rejected: Boolean 
  modGPTAnalysis: String 
  modGPTRecommendation: String 
  rejectedReason: String 
  rejectedByUserId: String 
  af: Boolean 
  afDate: Date 
  agentFoundationsId: String 
  originalDialogueId: String 
}

input UpdateCommentInput{
  selector: CommentSelectorUniqueInput!
  data: UpdateCommentDataInput!
}

input UpsertCommentInput{
  selector: CommentSelectorUniqueInput!
  data: UpdateCommentDataInput!
}

input UpdateCommentDataInput {
  legacyData: JSON 
  contents: JSON 
  subforumStickyPriority: Float 
  authorIsUnreviewed: Boolean 
  answer: Boolean 
  shortform: Boolean 
  shortformFrontpage: Boolean 
  nominatedForReview: String 
  reviewingForReview: String 
  promoted: Boolean 
  promotedByUserId: String 
  hideKarma: Boolean 
  legacy: Boolean 
  legacyId: String 
  legacyPoll: Boolean 
  legacyParentId: String 
  retracted: Boolean 
  deleted: Boolean 
  deletedPublic: Boolean 
  deletedReason: String 
  deletedDate: Date 
  deletedByUserId: String 
  spam: Boolean 
  repliesBlockedUntil: Date 
  needsReview: Boolean 
  reviewedByUserId: String 
  hideAuthor: Boolean 
  moderatorHat: Boolean 
  hideModeratorHat: Boolean 
  isPinnedOnProfile: Boolean 
  title: String 
  relevantTagIds: [String] 
  debateResponse: Boolean 
  rejected: Boolean 
  modGPTAnalysis: String 
  modGPTRecommendation: String 
  rejectedReason: String 
  rejectedByUserId: String 
  af: Boolean 
  suggestForAlignmentUserIds: [String] 
  reviewForAlignmentUserId: String 
  afDate: Date 
  moveToAlignmentUserId: String 
  agentFoundationsId: String 
  originalDialogueId: String 
}

input CommentSelectorInput {
  AND: [CommentSelectorInput]
  OR: [CommentSelectorInput]

}

input CommentSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum CommentOrderByInput {
  foobar
  
}



# Type for Conversations
  type Conversation {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  title: String 
  participantIds: [String] 
  participants: [User!]! 
  latestActivity: Date 
  af: Boolean 
  messageCount: Float 
  moderator: Boolean 
  archivedByIds: [String] 
  archivedBy: [User!]! 
  latestMessage: Message 
  hasUnreadMessages: Boolean 
  }


input DeleteConversationInput{
  selector: ConversationSelectorUniqueInput!
}

input SingleConversationInput {
  selector: ConversationSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiConversationInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ConversationSelectorInput
  orderBy: ConversationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleConversationOutput{
  result: Conversation
}

type MultiConversationOutput{
  results: [Conversation]
  totalCount: Int
}

type ConversationOutput{
  data: Conversation
}

input CreateConversationInput{
  data: CreateConversationDataInput!
}

input CreateConversationDataInput {
  legacyData: JSON 
  title: String 
  participantIds: [String] 
  af: Boolean 
  moderator: Boolean 
  archivedByIds: [String] 
}

input UpdateConversationInput{
  selector: ConversationSelectorUniqueInput!
  data: UpdateConversationDataInput!
}

input UpsertConversationInput{
  selector: ConversationSelectorUniqueInput!
  data: UpdateConversationDataInput!
}

input UpdateConversationDataInput {
  legacyData: JSON 
  title: String 
  participantIds: [String] 
  af: Boolean 
  moderator: Boolean 
  archivedByIds: [String] 
}

input ConversationSelectorInput {
  AND: [ConversationSelectorInput]
  OR: [ConversationSelectorInput]

}

input ConversationSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ConversationOrderByInput {
  foobar
  
}



# Type for CronHistories
  type CronHistory {
    _id: String 
  intendedAt: Date 
  name: String 
  startedAt: Date 
  finishedAt: Date 
  result: JSON 
  }


input DeleteCronHistoryInput{
  selector: CronHistorySelectorUniqueInput!
}

input SingleCronHistoryInput {
  selector: CronHistorySelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiCronHistoryInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: CronHistorySelectorInput
  orderBy: CronHistoryOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCronHistoryOutput{
  result: CronHistory
}

type MultiCronHistoryOutput{
  results: [CronHistory]
  totalCount: Int
}

type CronHistoryOutput{
  data: CronHistory
}

input CreateCronHistoryInput{
  data: CreateCronHistoryDataInput!
}

input CreateCronHistoryDataInput {
  _id: String! 
  intendedAt: Date! 
  name: String! 
  startedAt: Date! 
  finishedAt: Date 
  result: JSON 
}

input UpdateCronHistoryInput{
  selector: CronHistorySelectorUniqueInput!
  data: UpdateCronHistoryDataInput!
}

input UpsertCronHistoryInput{
  selector: CronHistorySelectorUniqueInput!
  data: UpdateCronHistoryDataInput!
}

input UpdateCronHistoryDataInput {
  _id: String 
  intendedAt: Date 
  name: String 
  startedAt: Date 
  finishedAt: Date 
  result: JSON 
}

input CronHistorySelectorInput {
  AND: [CronHistorySelectorInput]
  OR: [CronHistorySelectorInput]

}

input CronHistorySelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum CronHistoryOrderByInput {
  foobar
  
}



# Type for CurationEmails
  type CurationEmail {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  postId: String 
  }


input DeleteCurationEmailInput{
  selector: CurationEmailSelectorUniqueInput!
}

input SingleCurationEmailInput {
  selector: CurationEmailSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiCurationEmailInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: CurationEmailSelectorInput
  orderBy: CurationEmailOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCurationEmailOutput{
  result: CurationEmail
}

type MultiCurationEmailOutput{
  results: [CurationEmail]
  totalCount: Int
}

type CurationEmailOutput{
  data: CurationEmail
}

input CreateCurationEmailInput{
  data: CreateCurationEmailDataInput!
}

input CreateCurationEmailDataInput {
  legacyData: JSON 
  userId: String! 
  postId: String! 
}

input UpdateCurationEmailInput{
  selector: CurationEmailSelectorUniqueInput!
  data: UpdateCurationEmailDataInput!
}

input UpsertCurationEmailInput{
  selector: CurationEmailSelectorUniqueInput!
  data: UpdateCurationEmailDataInput!
}

input UpdateCurationEmailDataInput {
  legacyData: JSON 
  userId: String 
  postId: String 
}

input CurationEmailSelectorInput {
  AND: [CurationEmailSelectorInput]
  OR: [CurationEmailSelectorInput]

}

input CurationEmailSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum CurationEmailOrderByInput {
  foobar
  
}



# Type for CurationNotices
  type CurationNotice {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  contents(version: String): Revision 
  contents_latest: String 
  userId: String 
  user: User 
  commentId: String 
  comment: Comment 
  postId: String 
  post: Post 
  deleted: Boolean 
  }


input DeleteCurationNoticeInput{
  selector: CurationNoticeSelectorUniqueInput!
}

input SingleCurationNoticeInput {
  selector: CurationNoticeSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiCurationNoticeInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: CurationNoticeSelectorInput
  orderBy: CurationNoticeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCurationNoticeOutput{
  result: CurationNotice
}

type MultiCurationNoticeOutput{
  results: [CurationNotice]
  totalCount: Int
}

type CurationNoticeOutput{
  data: CurationNotice
}

input CreateCurationNoticeInput{
  data: CreateCurationNoticeDataInput!
}

input CreateCurationNoticeDataInput {
  legacyData: JSON 
  contents: JSON 
  userId: String! 
  commentId: String 
  postId: String! 
}

input UpdateCurationNoticeInput{
  selector: CurationNoticeSelectorUniqueInput!
  data: UpdateCurationNoticeDataInput!
}

input UpsertCurationNoticeInput{
  selector: CurationNoticeSelectorUniqueInput!
  data: UpdateCurationNoticeDataInput!
}

input UpdateCurationNoticeDataInput {
  legacyData: JSON 
  contents: JSON 
  commentId: String 
  deleted: Boolean 
}

input CurationNoticeSelectorInput {
  AND: [CurationNoticeSelectorInput]
  OR: [CurationNoticeSelectorInput]

}

input CurationNoticeSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum CurationNoticeOrderByInput {
  foobar
  
}



# Type for DatabaseMetadata
  type DatabaseMetadata {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  }


input DeleteDatabaseMetadataInput{
  selector: DatabaseMetadataSelectorUniqueInput!
}

input SingleDatabaseMetadataInput {
  selector: DatabaseMetadataSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiDatabaseMetadataInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: DatabaseMetadataSelectorInput
  orderBy: DatabaseMetadataOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDatabaseMetadataOutput{
  result: DatabaseMetadata
}

type MultiDatabaseMetadataOutput{
  results: [DatabaseMetadata]
  totalCount: Int
}

type DatabaseMetadataOutput{
  data: DatabaseMetadata
}

input CreateDatabaseMetadataInput{
  data: CreateDatabaseMetadataDataInput!
}

input CreateDatabaseMetadataDataInput {
  legacyData: JSON 
}

input UpdateDatabaseMetadataInput{
  selector: DatabaseMetadataSelectorUniqueInput!
  data: UpdateDatabaseMetadataDataInput!
}

input UpsertDatabaseMetadataInput{
  selector: DatabaseMetadataSelectorUniqueInput!
  data: UpdateDatabaseMetadataDataInput!
}

input UpdateDatabaseMetadataDataInput {
  legacyData: JSON 
}

input DatabaseMetadataSelectorInput {
  AND: [DatabaseMetadataSelectorInput]
  OR: [DatabaseMetadataSelectorInput]

}

input DatabaseMetadataSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum DatabaseMetadataOrderByInput {
  foobar
  
}



# Type for DebouncerEvents
  type DebouncerEvents {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  }


input DeleteDebouncerEventsInput{
  selector: DebouncerEventsSelectorUniqueInput!
}

input SingleDebouncerEventsInput {
  selector: DebouncerEventsSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiDebouncerEventsInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: DebouncerEventsSelectorInput
  orderBy: DebouncerEventsOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDebouncerEventsOutput{
  result: DebouncerEvents
}

type MultiDebouncerEventsOutput{
  results: [DebouncerEvents]
  totalCount: Int
}

type DebouncerEventsOutput{
  data: DebouncerEvents
}

input CreateDebouncerEventsInput{
  data: CreateDebouncerEventsDataInput!
}

input CreateDebouncerEventsDataInput {
  legacyData: JSON 
}

input UpdateDebouncerEventsInput{
  selector: DebouncerEventsSelectorUniqueInput!
  data: UpdateDebouncerEventsDataInput!
}

input UpsertDebouncerEventsInput{
  selector: DebouncerEventsSelectorUniqueInput!
  data: UpdateDebouncerEventsDataInput!
}

input UpdateDebouncerEventsDataInput {
  legacyData: JSON 
}

input DebouncerEventsSelectorInput {
  AND: [DebouncerEventsSelectorInput]
  OR: [DebouncerEventsSelectorInput]

}

input DebouncerEventsSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum DebouncerEventsOrderByInput {
  foobar
  
}



# Type for DialogueChecks
  type DialogueCheck {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  targetUserId: String 
  checked: Boolean 
  checkedAt: Date 
  hideInRecommendations: Boolean 
  matchPreference: DialogueMatchPreference 
  reciprocalMatchPreference: DialogueMatchPreference 
  }


input DeleteDialogueCheckInput{
  selector: DialogueCheckSelectorUniqueInput!
}

input SingleDialogueCheckInput {
  selector: DialogueCheckSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiDialogueCheckInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: DialogueCheckSelectorInput
  orderBy: DialogueCheckOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDialogueCheckOutput{
  result: DialogueCheck
}

type MultiDialogueCheckOutput{
  results: [DialogueCheck]
  totalCount: Int
}

type DialogueCheckOutput{
  data: DialogueCheck
}

input CreateDialogueCheckInput{
  data: CreateDialogueCheckDataInput!
}

input CreateDialogueCheckDataInput {
  legacyData: JSON 
  userId: String! 
  targetUserId: String! 
  checked: Boolean! 
  checkedAt: Date! 
  hideInRecommendations: Boolean! 
}

input UpdateDialogueCheckInput{
  selector: DialogueCheckSelectorUniqueInput!
  data: UpdateDialogueCheckDataInput!
}

input UpsertDialogueCheckInput{
  selector: DialogueCheckSelectorUniqueInput!
  data: UpdateDialogueCheckDataInput!
}

input UpdateDialogueCheckDataInput {
  legacyData: JSON 
}

input DialogueCheckSelectorInput {
  AND: [DialogueCheckSelectorInput]
  OR: [DialogueCheckSelectorInput]

}

input DialogueCheckSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum DialogueCheckOrderByInput {
  foobar
  
}



# Type for DialogueMatchPreferences
  type DialogueMatchPreference {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  dialogueCheckId: String 
  dialogueCheck: DialogueCheck 
  topicPreferences: [JSON] 
  topicNotes: String 
  syncPreference: String 
  asyncPreference: String 
  formatNotes: String 
  calendlyLink: String 
  generatedDialogueId: String 
  deleted: Boolean 
  }


input DeleteDialogueMatchPreferenceInput{
  selector: DialogueMatchPreferenceSelectorUniqueInput!
}

input SingleDialogueMatchPreferenceInput {
  selector: DialogueMatchPreferenceSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiDialogueMatchPreferenceInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: DialogueMatchPreferenceSelectorInput
  orderBy: DialogueMatchPreferenceOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDialogueMatchPreferenceOutput{
  result: DialogueMatchPreference
}

type MultiDialogueMatchPreferenceOutput{
  results: [DialogueMatchPreference]
  totalCount: Int
}

type DialogueMatchPreferenceOutput{
  data: DialogueMatchPreference
}

input CreateDialogueMatchPreferenceInput{
  data: CreateDialogueMatchPreferenceDataInput!
}

input CreateDialogueMatchPreferenceDataInput {
  legacyData: JSON 
  dialogueCheckId: String! 
  topicPreferences: [JSON]! 
  topicNotes: String! 
  syncPreference: String! 
  asyncPreference: String! 
  formatNotes: String! 
  calendlyLink: String 
  generatedDialogueId: String 
  deleted: Boolean 
}

input UpdateDialogueMatchPreferenceInput{
  selector: DialogueMatchPreferenceSelectorUniqueInput!
  data: UpdateDialogueMatchPreferenceDataInput!
}

input UpsertDialogueMatchPreferenceInput{
  selector: DialogueMatchPreferenceSelectorUniqueInput!
  data: UpdateDialogueMatchPreferenceDataInput!
}

input UpdateDialogueMatchPreferenceDataInput {
  legacyData: JSON 
  dialogueCheckId: String 
  topicPreferences: [JSON] 
  topicNotes: String 
  syncPreference: String 
  asyncPreference: String 
  formatNotes: String 
  calendlyLink: String 
  generatedDialogueId: String 
  deleted: Boolean 
}

input DialogueMatchPreferenceSelectorInput {
  AND: [DialogueMatchPreferenceSelectorInput]
  OR: [DialogueMatchPreferenceSelectorInput]

}

input DialogueMatchPreferenceSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum DialogueMatchPreferenceOrderByInput {
  foobar
  
}



# Type for DigestPosts
  type DigestPost {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  digestId: String 
  digest: Digest! 
  postId: String 
  post: Post! 
  emailDigestStatus: String 
  onsiteDigestStatus: String 
  }


input DeleteDigestPostInput{
  selector: DigestPostSelectorUniqueInput!
}

input SingleDigestPostInput {
  selector: DigestPostSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiDigestPostInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: DigestPostSelectorInput
  orderBy: DigestPostOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDigestPostOutput{
  result: DigestPost
}

type MultiDigestPostOutput{
  results: [DigestPost]
  totalCount: Int
}

type DigestPostOutput{
  data: DigestPost
}

input CreateDigestPostInput{
  data: CreateDigestPostDataInput!
}

input CreateDigestPostDataInput {
  legacyData: JSON 
  digestId: String! 
  postId: String! 
  emailDigestStatus: String 
  onsiteDigestStatus: String 
}

input UpdateDigestPostInput{
  selector: DigestPostSelectorUniqueInput!
  data: UpdateDigestPostDataInput!
}

input UpsertDigestPostInput{
  selector: DigestPostSelectorUniqueInput!
  data: UpdateDigestPostDataInput!
}

input UpdateDigestPostDataInput {
  legacyData: JSON 
  digestId: String 
  postId: String 
  emailDigestStatus: String 
  onsiteDigestStatus: String 
}

input DigestPostSelectorInput {
  AND: [DigestPostSelectorInput]
  OR: [DigestPostSelectorInput]

}

input DigestPostSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum DigestPostOrderByInput {
  foobar
  
}



# Type for Digests
  type Digest {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  num: Float 
  startDate: Date 
  endDate: Date 
  publishedDate: Date 
  onsiteImageId: String 
  onsitePrimaryColor: String 
  }


input DeleteDigestInput{
  selector: DigestSelectorUniqueInput!
}

input SingleDigestInput {
  selector: DigestSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiDigestInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: DigestSelectorInput
  orderBy: DigestOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDigestOutput{
  result: Digest
}

type MultiDigestOutput{
  results: [Digest]
  totalCount: Int
}

type DigestOutput{
  data: Digest
}

input CreateDigestInput{
  data: CreateDigestDataInput!
}

input CreateDigestDataInput {
  legacyData: JSON 
  num: Float! 
  startDate: Date! 
  endDate: Date 
  publishedDate: Date 
  onsiteImageId: String 
  onsitePrimaryColor: String 
}

input UpdateDigestInput{
  selector: DigestSelectorUniqueInput!
  data: UpdateDigestDataInput!
}

input UpsertDigestInput{
  selector: DigestSelectorUniqueInput!
  data: UpdateDigestDataInput!
}

input UpdateDigestDataInput {
  legacyData: JSON 
  num: Float 
  startDate: Date 
  endDate: Date 
  publishedDate: Date 
  onsiteImageId: String 
  onsitePrimaryColor: String 
}

input DigestSelectorInput {
  AND: [DigestSelectorInput]
  OR: [DigestSelectorInput]

}

input DigestSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum DigestOrderByInput {
  foobar
  
}



# Type for ElectionCandidates
  type ElectionCandidate {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  electionName: String 
  name: String 
  logoSrc: String 
  href: String 
  fundraiserLink: String 
  gwwcLink: String 
  gwwcId: String 
  description: String 
  userId: String 
  user: User 
  postCount: Float 
  tagId: String 
  tag: Tag 
  isElectionFundraiser: Boolean 
  amountRaised: Float 
  targetAmount: Float 
  currentUserVote: String 
  currentUserExtendedVote: JSON 
  voteCount: Float 
  baseScore: Float 
  extendedScore: JSON 
  score: Float 
  afBaseScore: Float 
  afExtendedScore: JSON 
  afVoteCount: Float 
  }


input DeleteElectionCandidateInput{
  selector: ElectionCandidateSelectorUniqueInput!
}

input SingleElectionCandidateInput {
  selector: ElectionCandidateSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiElectionCandidateInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ElectionCandidateSelectorInput
  orderBy: ElectionCandidateOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleElectionCandidateOutput{
  result: ElectionCandidate
}

type MultiElectionCandidateOutput{
  results: [ElectionCandidate]
  totalCount: Int
}

type ElectionCandidateOutput{
  data: ElectionCandidate
}

input CreateElectionCandidateInput{
  data: CreateElectionCandidateDataInput!
}

input CreateElectionCandidateDataInput {
  legacyData: JSON 
  electionName: String! 
  name: String! 
  logoSrc: String! 
  href: String! 
  fundraiserLink: String 
  gwwcLink: String 
  gwwcId: String 
  description: String! 
  userId: String 
  tagId: String! 
  isElectionFundraiser: Boolean 
  amountRaised: Float 
  targetAmount: Float 
}

input UpdateElectionCandidateInput{
  selector: ElectionCandidateSelectorUniqueInput!
  data: UpdateElectionCandidateDataInput!
}

input UpsertElectionCandidateInput{
  selector: ElectionCandidateSelectorUniqueInput!
  data: UpdateElectionCandidateDataInput!
}

input UpdateElectionCandidateDataInput {
  legacyData: JSON 
  electionName: String 
  name: String 
  logoSrc: String 
  href: String 
  fundraiserLink: String 
  gwwcLink: String 
  gwwcId: String 
  description: String 
  userId: String 
  tagId: String 
  isElectionFundraiser: Boolean 
  amountRaised: Float 
  targetAmount: Float 
}

input ElectionCandidateSelectorInput {
  AND: [ElectionCandidateSelectorInput]
  OR: [ElectionCandidateSelectorInput]

}

input ElectionCandidateSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ElectionCandidateOrderByInput {
  foobar
  
}



# Type for ElectionVotes
  type ElectionVote {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  electionName: String 
  userId: String 
  user: User! 
  compareState: JSON 
  vote: JSON 
  submittedAt: Date 
  submissionComments: JSON 
  userExplanation: String 
  userOtherComments: String 
  }


input DeleteElectionVoteInput{
  selector: ElectionVoteSelectorUniqueInput!
}

input SingleElectionVoteInput {
  selector: ElectionVoteSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiElectionVoteInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ElectionVoteSelectorInput
  orderBy: ElectionVoteOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleElectionVoteOutput{
  result: ElectionVote
}

type MultiElectionVoteOutput{
  results: [ElectionVote]
  totalCount: Int
}

type ElectionVoteOutput{
  data: ElectionVote
}

input CreateElectionVoteInput{
  data: CreateElectionVoteDataInput!
}

input CreateElectionVoteDataInput {
  legacyData: JSON 
  electionName: String! 
  userId: String! 
  compareState: JSON 
  vote: JSON 
  submittedAt: Date 
  submissionComments: JSON 
  userExplanation: String 
  userOtherComments: String 
}

input UpdateElectionVoteInput{
  selector: ElectionVoteSelectorUniqueInput!
  data: UpdateElectionVoteDataInput!
}

input UpsertElectionVoteInput{
  selector: ElectionVoteSelectorUniqueInput!
  data: UpdateElectionVoteDataInput!
}

input UpdateElectionVoteDataInput {
  legacyData: JSON 
  electionName: String 
  userId: String 
  compareState: JSON 
  vote: JSON 
  submittedAt: Date 
  submissionComments: JSON 
  userExplanation: String 
  userOtherComments: String 
}

input ElectionVoteSelectorInput {
  AND: [ElectionVoteSelectorInput]
  OR: [ElectionVoteSelectorInput]

}

input ElectionVoteSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ElectionVoteOrderByInput {
  foobar
  
}



# Type for ElicitQuestionPredictions
  type ElicitQuestionPrediction {
    _id: String 
  predictionId: String 
  prediction: Float 
  createdAt: Date 
  notes: String 
  creator: JSON 
  userId: String 
  user: User 
  sourceUrl: String 
  sourceId: String 
  binaryQuestionId: String 
  question: ElicitQuestion! 
  isDeleted: Boolean 
  }


input DeleteElicitQuestionPredictionInput{
  selector: ElicitQuestionPredictionSelectorUniqueInput!
}

input SingleElicitQuestionPredictionInput {
  selector: ElicitQuestionPredictionSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiElicitQuestionPredictionInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ElicitQuestionPredictionSelectorInput
  orderBy: ElicitQuestionPredictionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleElicitQuestionPredictionOutput{
  result: ElicitQuestionPrediction
}

type MultiElicitQuestionPredictionOutput{
  results: [ElicitQuestionPrediction]
  totalCount: Int
}

type ElicitQuestionPredictionOutput{
  data: ElicitQuestionPrediction
}

input CreateElicitQuestionPredictionInput{
  data: CreateElicitQuestionPredictionDataInput!
}

input CreateElicitQuestionPredictionDataInput {
  _id: String! 
  prediction: Float 
  createdAt: Date! 
  notes: String 
  creator: JSON! 
  userId: String 
  sourceUrl: String 
  sourceId: String 
  binaryQuestionId: String! 
  isDeleted: Boolean! 
}

input UpdateElicitQuestionPredictionInput{
  selector: ElicitQuestionPredictionSelectorUniqueInput!
  data: UpdateElicitQuestionPredictionDataInput!
}

input UpsertElicitQuestionPredictionInput{
  selector: ElicitQuestionPredictionSelectorUniqueInput!
  data: UpdateElicitQuestionPredictionDataInput!
}

input UpdateElicitQuestionPredictionDataInput {
  _id: String 
  prediction: Float 
  createdAt: Date 
  notes: String 
  creator: JSON 
  userId: String 
  sourceUrl: String 
  sourceId: String 
  binaryQuestionId: String 
  isDeleted: Boolean 
}

input ElicitQuestionPredictionSelectorInput {
  AND: [ElicitQuestionPredictionSelectorInput]
  OR: [ElicitQuestionPredictionSelectorInput]

}

input ElicitQuestionPredictionSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ElicitQuestionPredictionOrderByInput {
  foobar
  
}



# Type for ElicitQuestions
  type ElicitQuestion {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  title: String 
  notes: String 
  resolution: String 
  resolvesBy: Date 
  }


input DeleteElicitQuestionInput{
  selector: ElicitQuestionSelectorUniqueInput!
}

input SingleElicitQuestionInput {
  selector: ElicitQuestionSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiElicitQuestionInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ElicitQuestionSelectorInput
  orderBy: ElicitQuestionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleElicitQuestionOutput{
  result: ElicitQuestion
}

type MultiElicitQuestionOutput{
  results: [ElicitQuestion]
  totalCount: Int
}

type ElicitQuestionOutput{
  data: ElicitQuestion
}

input CreateElicitQuestionInput{
  data: CreateElicitQuestionDataInput!
}

input CreateElicitQuestionDataInput {
  legacyData: JSON 
  title: String! 
  notes: String 
  resolution: String 
  resolvesBy: Date 
}

input UpdateElicitQuestionInput{
  selector: ElicitQuestionSelectorUniqueInput!
  data: UpdateElicitQuestionDataInput!
}

input UpsertElicitQuestionInput{
  selector: ElicitQuestionSelectorUniqueInput!
  data: UpdateElicitQuestionDataInput!
}

input UpdateElicitQuestionDataInput {
  legacyData: JSON 
  title: String 
  notes: String 
  resolution: String 
  resolvesBy: Date 
}

input ElicitQuestionSelectorInput {
  AND: [ElicitQuestionSelectorInput]
  OR: [ElicitQuestionSelectorInput]

}

input ElicitQuestionSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ElicitQuestionOrderByInput {
  foobar
  
}



# Type for EmailTokens
  type EmailTokens {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  }


input DeleteEmailTokensInput{
  selector: EmailTokensSelectorUniqueInput!
}

input SingleEmailTokensInput {
  selector: EmailTokensSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiEmailTokensInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: EmailTokensSelectorInput
  orderBy: EmailTokensOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleEmailTokensOutput{
  result: EmailTokens
}

type MultiEmailTokensOutput{
  results: [EmailTokens]
  totalCount: Int
}

type EmailTokensOutput{
  data: EmailTokens
}

input CreateEmailTokensInput{
  data: CreateEmailTokensDataInput!
}

input CreateEmailTokensDataInput {
  legacyData: JSON 
}

input UpdateEmailTokensInput{
  selector: EmailTokensSelectorUniqueInput!
  data: UpdateEmailTokensDataInput!
}

input UpsertEmailTokensInput{
  selector: EmailTokensSelectorUniqueInput!
  data: UpdateEmailTokensDataInput!
}

input UpdateEmailTokensDataInput {
  legacyData: JSON 
}

input EmailTokensSelectorInput {
  AND: [EmailTokensSelectorInput]
  OR: [EmailTokensSelectorInput]

}

input EmailTokensSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum EmailTokensOrderByInput {
  foobar
  
}



# Type for FeaturedResources
  type FeaturedResource {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  title: String 
  body: String 
  ctaText: String 
  ctaUrl: String 
  expiresAt: Date 
  }


input DeleteFeaturedResourceInput{
  selector: FeaturedResourceSelectorUniqueInput!
}

input SingleFeaturedResourceInput {
  selector: FeaturedResourceSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiFeaturedResourceInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: FeaturedResourceSelectorInput
  orderBy: FeaturedResourceOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleFeaturedResourceOutput{
  result: FeaturedResource
}

type MultiFeaturedResourceOutput{
  results: [FeaturedResource]
  totalCount: Int
}

type FeaturedResourceOutput{
  data: FeaturedResource
}

input CreateFeaturedResourceInput{
  data: CreateFeaturedResourceDataInput!
}

input CreateFeaturedResourceDataInput {
  legacyData: JSON 
  title: String! 
  body: String! 
  ctaText: String! 
  ctaUrl: String! 
  expiresAt: Date 
}

input UpdateFeaturedResourceInput{
  selector: FeaturedResourceSelectorUniqueInput!
  data: UpdateFeaturedResourceDataInput!
}

input UpsertFeaturedResourceInput{
  selector: FeaturedResourceSelectorUniqueInput!
  data: UpdateFeaturedResourceDataInput!
}

input UpdateFeaturedResourceDataInput {
  legacyData: JSON 
  title: String 
  body: String 
  ctaText: String 
  ctaUrl: String 
  expiresAt: Date 
}

input FeaturedResourceSelectorInput {
  AND: [FeaturedResourceSelectorInput]
  OR: [FeaturedResourceSelectorInput]

}

input FeaturedResourceSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum FeaturedResourceOrderByInput {
  foobar
  
}



# Type for FieldChanges
  type FieldChange {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  user: User 
  changeGroup: String 
  documentId: String 
  fieldName: String 
  oldValue: JSON 
  newValue: JSON 
  }


input DeleteFieldChangeInput{
  selector: FieldChangeSelectorUniqueInput!
}

input SingleFieldChangeInput {
  selector: FieldChangeSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiFieldChangeInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: FieldChangeSelectorInput
  orderBy: FieldChangeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleFieldChangeOutput{
  result: FieldChange
}

type MultiFieldChangeOutput{
  results: [FieldChange]
  totalCount: Int
}

type FieldChangeOutput{
  data: FieldChange
}

input CreateFieldChangeInput{
  data: CreateFieldChangeDataInput!
}

input CreateFieldChangeDataInput {
  legacyData: JSON 
}

input UpdateFieldChangeInput{
  selector: FieldChangeSelectorUniqueInput!
  data: UpdateFieldChangeDataInput!
}

input UpsertFieldChangeInput{
  selector: FieldChangeSelectorUniqueInput!
  data: UpdateFieldChangeDataInput!
}

input UpdateFieldChangeDataInput {
  legacyData: JSON 
}

input FieldChangeSelectorInput {
  AND: [FieldChangeSelectorInput]
  OR: [FieldChangeSelectorInput]

}

input FieldChangeSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum FieldChangeOrderByInput {
  foobar
  
}



# Type for ForumEvents
  type ForumEvent {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  frontpageDescription(version: String): Revision 
  frontpageDescription_latest: String 
  frontpageDescriptionMobile(version: String): Revision 
  frontpageDescriptionMobile_latest: String 
  postPageDescription(version: String): Revision 
  postPageDescription_latest: String 
  title: String 
  startDate: Date 
  endDate: Date 
  darkColor: String 
  lightColor: String 
  bannerTextColor: String 
  contrastColor: String 
  tagId: String 
  tag: Tag 
  postId: String 
  post: Post 
  bannerImageId: String 
  includesPoll: Boolean 
  eventFormat: String 
  pollQuestion(version: String): Revision 
  pollQuestion_latest: String 
  pollAgreeWording: String 
  pollDisagreeWording: String 
  maxStickersPerUser: Float 
  customComponent: String 
  commentPrompt: String 
  publicData: JSON 
  voteCount: Int! 
  }


input DeleteForumEventInput{
  selector: ForumEventSelectorUniqueInput!
}

input SingleForumEventInput {
  selector: ForumEventSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiForumEventInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ForumEventSelectorInput
  orderBy: ForumEventOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleForumEventOutput{
  result: ForumEvent
}

type MultiForumEventOutput{
  results: [ForumEvent]
  totalCount: Int
}

type ForumEventOutput{
  data: ForumEvent
}

input CreateForumEventInput{
  data: CreateForumEventDataInput!
}

input CreateForumEventDataInput {
  legacyData: JSON 
  frontpageDescription: JSON 
  frontpageDescriptionMobile: JSON 
  postPageDescription: JSON 
  title: String! 
  startDate: Date! 
  endDate: Date! 
  darkColor: String! 
  lightColor: String! 
  bannerTextColor: String! 
  contrastColor: String 
  tagId: String 
  postId: String 
  bannerImageId: String 
  includesPoll: Boolean 
  eventFormat: String 
  pollQuestion: JSON 
  pollAgreeWording: String 
  pollDisagreeWording: String 
  maxStickersPerUser: Float 
  customComponent: String 
  commentPrompt: String 
  publicData: JSON 
}

input UpdateForumEventInput{
  selector: ForumEventSelectorUniqueInput!
  data: UpdateForumEventDataInput!
}

input UpsertForumEventInput{
  selector: ForumEventSelectorUniqueInput!
  data: UpdateForumEventDataInput!
}

input UpdateForumEventDataInput {
  legacyData: JSON 
  frontpageDescription: JSON 
  frontpageDescriptionMobile: JSON 
  postPageDescription: JSON 
  title: String 
  startDate: Date 
  endDate: Date 
  darkColor: String 
  lightColor: String 
  bannerTextColor: String 
  contrastColor: String 
  tagId: String 
  postId: String 
  bannerImageId: String 
  includesPoll: Boolean 
  eventFormat: String 
  pollQuestion: JSON 
  pollAgreeWording: String 
  pollDisagreeWording: String 
  maxStickersPerUser: Float 
  customComponent: String 
  commentPrompt: String 
}

input ForumEventSelectorInput {
  AND: [ForumEventSelectorInput]
  OR: [ForumEventSelectorInput]

}

input ForumEventSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ForumEventOrderByInput {
  foobar
  
}



# Type for GardenCodes
  type GardenCode {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  contents(version: String): Revision 
  contents_latest: String 
  pingbacks: JSON 
  slug: String 
  code: String 
  title: String 
  userId: String 
  user: User 
  startTime: Date 
  endTime: Date 
  fbLink: String 
  type: String 
  hidden: Boolean 
  deleted: Boolean 
  afOnly: Boolean 
  }


input DeleteGardenCodeInput{
  selector: GardenCodeSelectorUniqueInput!
}

input SingleGardenCodeInput {
  selector: GardenCodeSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiGardenCodeInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: GardenCodeSelectorInput
  orderBy: GardenCodeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleGardenCodeOutput{
  result: GardenCode
}

type MultiGardenCodeOutput{
  results: [GardenCode]
  totalCount: Int
}

type GardenCodeOutput{
  data: GardenCode
}

input CreateGardenCodeInput{
  data: CreateGardenCodeDataInput!
}

input CreateGardenCodeDataInput {
  legacyData: JSON 
  contents: JSON 
  title: String! 
  startTime: Date 
  fbLink: String 
  type: String 
  afOnly: Boolean 
}

input UpdateGardenCodeInput{
  selector: GardenCodeSelectorUniqueInput!
  data: UpdateGardenCodeDataInput!
}

input UpsertGardenCodeInput{
  selector: GardenCodeSelectorUniqueInput!
  data: UpdateGardenCodeDataInput!
}

input UpdateGardenCodeDataInput {
  legacyData: JSON 
  contents: JSON 
  title: String 
  startTime: Date 
  endTime: Date 
  fbLink: String 
  type: String 
  hidden: Boolean 
  deleted: Boolean 
  afOnly: Boolean 
}

input GardenCodeSelectorInput {
  AND: [GardenCodeSelectorInput]
  OR: [GardenCodeSelectorInput]

}

input GardenCodeSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum GardenCodeOrderByInput {
  foobar
  
}



# Type for GoogleServiceAccountSessions
  type GoogleServiceAccountSession {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  email: String 
  refreshToken: String 
  estimatedExpiry: Date 
  active: Boolean 
  revoked: Boolean 
  }


input DeleteGoogleServiceAccountSessionInput{
  selector: GoogleServiceAccountSessionSelectorUniqueInput!
}

input SingleGoogleServiceAccountSessionInput {
  selector: GoogleServiceAccountSessionSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiGoogleServiceAccountSessionInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: GoogleServiceAccountSessionSelectorInput
  orderBy: GoogleServiceAccountSessionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleGoogleServiceAccountSessionOutput{
  result: GoogleServiceAccountSession
}

type MultiGoogleServiceAccountSessionOutput{
  results: [GoogleServiceAccountSession]
  totalCount: Int
}

type GoogleServiceAccountSessionOutput{
  data: GoogleServiceAccountSession
}

input CreateGoogleServiceAccountSessionInput{
  data: CreateGoogleServiceAccountSessionDataInput!
}

input CreateGoogleServiceAccountSessionDataInput {
  legacyData: JSON 
  email: String! 
  refreshToken: String! 
  estimatedExpiry: Date! 
  active: Boolean! 
  revoked: Boolean! 
}

input UpdateGoogleServiceAccountSessionInput{
  selector: GoogleServiceAccountSessionSelectorUniqueInput!
  data: UpdateGoogleServiceAccountSessionDataInput!
}

input UpsertGoogleServiceAccountSessionInput{
  selector: GoogleServiceAccountSessionSelectorUniqueInput!
  data: UpdateGoogleServiceAccountSessionDataInput!
}

input UpdateGoogleServiceAccountSessionDataInput {
  legacyData: JSON 
  email: String 
  refreshToken: String 
  estimatedExpiry: Date 
  active: Boolean 
  revoked: Boolean 
}

input GoogleServiceAccountSessionSelectorInput {
  AND: [GoogleServiceAccountSessionSelectorInput]
  OR: [GoogleServiceAccountSessionSelectorInput]

}

input GoogleServiceAccountSessionSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum GoogleServiceAccountSessionOrderByInput {
  foobar
  
}



# Type for Images
  type Images {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  }


input DeleteImagesInput{
  selector: ImagesSelectorUniqueInput!
}

input SingleImagesInput {
  selector: ImagesSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiImagesInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ImagesSelectorInput
  orderBy: ImagesOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleImagesOutput{
  result: Images
}

type MultiImagesOutput{
  results: [Images]
  totalCount: Int
}

type ImagesOutput{
  data: Images
}

input CreateImagesInput{
  data: CreateImagesDataInput!
}

input CreateImagesDataInput {
  legacyData: JSON 
}

input UpdateImagesInput{
  selector: ImagesSelectorUniqueInput!
  data: UpdateImagesDataInput!
}

input UpsertImagesInput{
  selector: ImagesSelectorUniqueInput!
  data: UpdateImagesDataInput!
}

input UpdateImagesDataInput {
  legacyData: JSON 
}

input ImagesSelectorInput {
  AND: [ImagesSelectorInput]
  OR: [ImagesSelectorInput]

}

input ImagesSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ImagesOrderByInput {
  foobar
  
}



# Type for JargonTerms
  type JargonTerm {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  contents(version: String): Revision 
  contents_latest: String 
  postId: String 
  post: Post 
  term: String 
  humansAndOrAIEdited: String 
  approved: Boolean 
  deleted: Boolean 
  altTerms: [String] 
  }


input DeleteJargonTermInput{
  selector: JargonTermSelectorUniqueInput!
}

input SingleJargonTermInput {
  selector: JargonTermSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiJargonTermInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: JargonTermSelectorInput
  orderBy: JargonTermOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleJargonTermOutput{
  result: JargonTerm
}

type MultiJargonTermOutput{
  results: [JargonTerm]
  totalCount: Int
}

type JargonTermOutput{
  data: JargonTerm
}

input CreateJargonTermInput{
  data: CreateJargonTermDataInput!
}

input CreateJargonTermDataInput {
  legacyData: JSON 
  contents: JSON 
  postId: String! 
  term: String! 
  approved: Boolean 
  deleted: Boolean 
  altTerms: [String]! 
}

input UpdateJargonTermInput{
  selector: JargonTermSelectorUniqueInput!
  data: UpdateJargonTermDataInput!
}

input UpsertJargonTermInput{
  selector: JargonTermSelectorUniqueInput!
  data: UpdateJargonTermDataInput!
}

input UpdateJargonTermDataInput {
  legacyData: JSON 
  contents: JSON 
  term: String 
  approved: Boolean 
  deleted: Boolean 
  altTerms: [String] 
}

input JargonTermSelectorInput {
  AND: [JargonTermSelectorInput]
  OR: [JargonTermSelectorInput]

}

input JargonTermSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum JargonTermOrderByInput {
  foobar
  
}



# Type for LWEvents
  type LWEvent {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  user: User 
  name: String 
  documentId: String 
  important: Boolean 
  properties: JSON 
  intercom: Boolean 
  }


input DeleteLWEventInput{
  selector: LWEventSelectorUniqueInput!
}

input SingleLWEventInput {
  selector: LWEventSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiLWEventInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: LWEventSelectorInput
  orderBy: LWEventOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLWEventOutput{
  result: LWEvent
}

type MultiLWEventOutput{
  results: [LWEvent]
  totalCount: Int
}

type LWEventOutput{
  data: LWEvent
}

input CreateLWEventInput{
  data: CreateLWEventDataInput!
}

input CreateLWEventDataInput {
  legacyData: JSON 
  userId: String 
  name: String! 
  documentId: String 
  important: Boolean 
  properties: JSON 
  intercom: Boolean 
}

input UpdateLWEventInput{
  selector: LWEventSelectorUniqueInput!
  data: UpdateLWEventDataInput!
}

input UpsertLWEventInput{
  selector: LWEventSelectorUniqueInput!
  data: UpdateLWEventDataInput!
}

input UpdateLWEventDataInput {
  legacyData: JSON 
  important: Boolean 
}

input LWEventSelectorInput {
  AND: [LWEventSelectorInput]
  OR: [LWEventSelectorInput]

}

input LWEventSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum LWEventOrderByInput {
  foobar
  
}



# Type for LegacyData
  type LegacyData {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  }


input DeleteLegacyDataInput{
  selector: LegacyDataSelectorUniqueInput!
}

input SingleLegacyDataInput {
  selector: LegacyDataSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiLegacyDataInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: LegacyDataSelectorInput
  orderBy: LegacyDataOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLegacyDataOutput{
  result: LegacyData
}

type MultiLegacyDataOutput{
  results: [LegacyData]
  totalCount: Int
}

type LegacyDataOutput{
  data: LegacyData
}

input CreateLegacyDataInput{
  data: CreateLegacyDataDataInput!
}

input CreateLegacyDataDataInput {
  legacyData: JSON 
}

input UpdateLegacyDataInput{
  selector: LegacyDataSelectorUniqueInput!
  data: UpdateLegacyDataDataInput!
}

input UpsertLegacyDataInput{
  selector: LegacyDataSelectorUniqueInput!
  data: UpdateLegacyDataDataInput!
}

input UpdateLegacyDataDataInput {
  legacyData: JSON 
}

input LegacyDataSelectorInput {
  AND: [LegacyDataSelectorInput]
  OR: [LegacyDataSelectorInput]

}

input LegacyDataSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum LegacyDataOrderByInput {
  foobar
  
}



# Type for LlmConversations
  type LlmConversation {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  user: User 
  title: String 
  model: String 
  systemPrompt: String 
  lastUpdatedAt: Date 
  messages: [LlmMessage] 
  deleted: Boolean 
  totalCharacterCount: Int 
  }


input DeleteLlmConversationInput{
  selector: LlmConversationSelectorUniqueInput!
}

input SingleLlmConversationInput {
  selector: LlmConversationSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiLlmConversationInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: LlmConversationSelectorInput
  orderBy: LlmConversationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLlmConversationOutput{
  result: LlmConversation
}

type MultiLlmConversationOutput{
  results: [LlmConversation]
  totalCount: Int
}

type LlmConversationOutput{
  data: LlmConversation
}

input CreateLlmConversationInput{
  data: CreateLlmConversationDataInput!
}

input CreateLlmConversationDataInput {
  legacyData: JSON 
  userId: String! 
  title: String! 
  model: String! 
  systemPrompt: String 
  deleted: Boolean 
}

input UpdateLlmConversationInput{
  selector: LlmConversationSelectorUniqueInput!
  data: UpdateLlmConversationDataInput!
}

input UpsertLlmConversationInput{
  selector: LlmConversationSelectorUniqueInput!
  data: UpdateLlmConversationDataInput!
}

input UpdateLlmConversationDataInput {
  legacyData: JSON 
  userId: String 
  title: String 
  model: String 
  systemPrompt: String 
  deleted: Boolean 
}

input LlmConversationSelectorInput {
  AND: [LlmConversationSelectorInput]
  OR: [LlmConversationSelectorInput]

}

input LlmConversationSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum LlmConversationOrderByInput {
  foobar
  
}



# Type for LlmMessages
  type LlmMessage {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  conversationId: String 
  role: String 
  content: String 
  }


input DeleteLlmMessageInput{
  selector: LlmMessageSelectorUniqueInput!
}

input SingleLlmMessageInput {
  selector: LlmMessageSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiLlmMessageInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: LlmMessageSelectorInput
  orderBy: LlmMessageOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLlmMessageOutput{
  result: LlmMessage
}

type MultiLlmMessageOutput{
  results: [LlmMessage]
  totalCount: Int
}

type LlmMessageOutput{
  data: LlmMessage
}

input CreateLlmMessageInput{
  data: CreateLlmMessageDataInput!
}

input CreateLlmMessageDataInput {
  legacyData: JSON 
  userId: String! 
  conversationId: String 
  role: String! 
  content: String! 
}

input UpdateLlmMessageInput{
  selector: LlmMessageSelectorUniqueInput!
  data: UpdateLlmMessageDataInput!
}

input UpsertLlmMessageInput{
  selector: LlmMessageSelectorUniqueInput!
  data: UpdateLlmMessageDataInput!
}

input UpdateLlmMessageDataInput {
  legacyData: JSON 
  userId: String 
  conversationId: String 
  role: String 
  content: String 
}

input LlmMessageSelectorInput {
  AND: [LlmMessageSelectorInput]
  OR: [LlmMessageSelectorInput]

}

input LlmMessageSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum LlmMessageOrderByInput {
  foobar
  
}



# Type for Localgroups
  type Localgroup {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  contents(version: String): Revision 
  contents_latest: String 
  name: String 
  nameInAnotherLanguage: String 
  organizerIds: [String] 
  organizers: [User!]! 
  lastActivity: Date 
  types: [String] 
  categories: [String] 
  isOnline: Boolean 
  mongoLocation: JSON 
  googleLocation: JSON 
  location: String 
  contactInfo: String 
  facebookLink: String 
  facebookPageLink: String 
  meetupLink: String 
  slackLink: String 
  website: String 
  bannerImageId: String 
  inactive: Boolean 
  deleted: Boolean 
  }


input DeleteLocalgroupInput{
  selector: LocalgroupSelectorUniqueInput!
}

input SingleLocalgroupInput {
  selector: LocalgroupSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiLocalgroupInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: LocalgroupSelectorInput
  orderBy: LocalgroupOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLocalgroupOutput{
  result: Localgroup
}

type MultiLocalgroupOutput{
  results: [Localgroup]
  totalCount: Int
}

type LocalgroupOutput{
  data: Localgroup
}

input CreateLocalgroupInput{
  data: CreateLocalgroupDataInput!
}

input CreateLocalgroupDataInput {
  legacyData: JSON 
  contents: JSON 
  name: String! 
  nameInAnotherLanguage: String 
  organizerIds: [String]! 
  lastActivity: Date 
  types: [String]! 
  categories: [String] 
  isOnline: Boolean 
  googleLocation: JSON 
  location: String 
  contactInfo: String 
  facebookLink: String 
  facebookPageLink: String 
  meetupLink: String 
  slackLink: String 
  website: String 
  bannerImageId: String 
  inactive: Boolean 
  deleted: Boolean 
}

input UpdateLocalgroupInput{
  selector: LocalgroupSelectorUniqueInput!
  data: UpdateLocalgroupDataInput!
}

input UpsertLocalgroupInput{
  selector: LocalgroupSelectorUniqueInput!
  data: UpdateLocalgroupDataInput!
}

input UpdateLocalgroupDataInput {
  legacyData: JSON 
  contents: JSON 
  name: String 
  nameInAnotherLanguage: String 
  organizerIds: [String] 
  lastActivity: Date 
  types: [String] 
  categories: [String] 
  isOnline: Boolean 
  googleLocation: JSON 
  location: String 
  contactInfo: String 
  facebookLink: String 
  facebookPageLink: String 
  meetupLink: String 
  slackLink: String 
  website: String 
  bannerImageId: String 
  inactive: Boolean 
  deleted: Boolean 
}

input LocalgroupSelectorInput {
  AND: [LocalgroupSelectorInput]
  OR: [LocalgroupSelectorInput]

}

input LocalgroupSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum LocalgroupOrderByInput {
  foobar
  
}



# Type for ManifoldProbabilitiesCaches
  type ManifoldProbabilitiesCache {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  marketId: String 
  probability: Float 
  isResolved: Boolean 
  year: Float 
  lastUpdated: Date 
  url: String 
  }


input DeleteManifoldProbabilitiesCacheInput{
  selector: ManifoldProbabilitiesCacheSelectorUniqueInput!
}

input SingleManifoldProbabilitiesCacheInput {
  selector: ManifoldProbabilitiesCacheSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiManifoldProbabilitiesCacheInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ManifoldProbabilitiesCacheSelectorInput
  orderBy: ManifoldProbabilitiesCacheOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleManifoldProbabilitiesCacheOutput{
  result: ManifoldProbabilitiesCache
}

type MultiManifoldProbabilitiesCacheOutput{
  results: [ManifoldProbabilitiesCache]
  totalCount: Int
}

type ManifoldProbabilitiesCacheOutput{
  data: ManifoldProbabilitiesCache
}

input CreateManifoldProbabilitiesCacheInput{
  data: CreateManifoldProbabilitiesCacheDataInput!
}

input CreateManifoldProbabilitiesCacheDataInput {
  legacyData: JSON 
  marketId: String! 
  probability: Float! 
  isResolved: Boolean! 
  year: Float! 
  lastUpdated: Date! 
  url: String 
}

input UpdateManifoldProbabilitiesCacheInput{
  selector: ManifoldProbabilitiesCacheSelectorUniqueInput!
  data: UpdateManifoldProbabilitiesCacheDataInput!
}

input UpsertManifoldProbabilitiesCacheInput{
  selector: ManifoldProbabilitiesCacheSelectorUniqueInput!
  data: UpdateManifoldProbabilitiesCacheDataInput!
}

input UpdateManifoldProbabilitiesCacheDataInput {
  legacyData: JSON 
}

input ManifoldProbabilitiesCacheSelectorInput {
  AND: [ManifoldProbabilitiesCacheSelectorInput]
  OR: [ManifoldProbabilitiesCacheSelectorInput]

}

input ManifoldProbabilitiesCacheSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ManifoldProbabilitiesCacheOrderByInput {
  foobar
  
}



# Type for Messages
  type Message {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  contents(version: String): Revision 
  contents_latest: String 
  userId: String 
  user: User 
  conversationId: String 
  conversation: Conversation! 
  noEmail: Boolean 
  }


input DeleteMessageInput{
  selector: MessageSelectorUniqueInput!
}

input SingleMessageInput {
  selector: MessageSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiMessageInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: MessageSelectorInput
  orderBy: MessageOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleMessageOutput{
  result: Message
}

type MultiMessageOutput{
  results: [Message]
  totalCount: Int
}

type MessageOutput{
  data: Message
}

input CreateMessageInput{
  data: CreateMessageDataInput!
}

input CreateMessageDataInput {
  legacyData: JSON 
  contents: JSON 
  userId: String 
  conversationId: String! 
  noEmail: Boolean 
}

input UpdateMessageInput{
  selector: MessageSelectorUniqueInput!
  data: UpdateMessageDataInput!
}

input UpsertMessageInput{
  selector: MessageSelectorUniqueInput!
  data: UpdateMessageDataInput!
}

input UpdateMessageDataInput {
  legacyData: JSON 
  contents: JSON 
}

input MessageSelectorInput {
  AND: [MessageSelectorInput]
  OR: [MessageSelectorInput]

}

input MessageSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum MessageOrderByInput {
  foobar
  
}



# Type for Migrations
  type Migration {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  }


input DeleteMigrationInput{
  selector: MigrationSelectorUniqueInput!
}

input SingleMigrationInput {
  selector: MigrationSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiMigrationInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: MigrationSelectorInput
  orderBy: MigrationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleMigrationOutput{
  result: Migration
}

type MultiMigrationOutput{
  results: [Migration]
  totalCount: Int
}

type MigrationOutput{
  data: Migration
}

input CreateMigrationInput{
  data: CreateMigrationDataInput!
}

input CreateMigrationDataInput {
  legacyData: JSON 
}

input UpdateMigrationInput{
  selector: MigrationSelectorUniqueInput!
  data: UpdateMigrationDataInput!
}

input UpsertMigrationInput{
  selector: MigrationSelectorUniqueInput!
  data: UpdateMigrationDataInput!
}

input UpdateMigrationDataInput {
  legacyData: JSON 
}

input MigrationSelectorInput {
  AND: [MigrationSelectorInput]
  OR: [MigrationSelectorInput]

}

input MigrationSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum MigrationOrderByInput {
  foobar
  
}



# Type for ModerationTemplates
  type ModerationTemplate {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  contents(version: String): Revision 
  contents_latest: String 
  name: String 
  collectionName: String 
  order: Float 
  deleted: Boolean 
  }


input DeleteModerationTemplateInput{
  selector: ModerationTemplateSelectorUniqueInput!
}

input SingleModerationTemplateInput {
  selector: ModerationTemplateSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiModerationTemplateInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ModerationTemplateSelectorInput
  orderBy: ModerationTemplateOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleModerationTemplateOutput{
  result: ModerationTemplate
}

type MultiModerationTemplateOutput{
  results: [ModerationTemplate]
  totalCount: Int
}

type ModerationTemplateOutput{
  data: ModerationTemplate
}

input CreateModerationTemplateInput{
  data: CreateModerationTemplateDataInput!
}

input CreateModerationTemplateDataInput {
  legacyData: JSON 
  contents: JSON 
  name: String! 
  collectionName: String! 
  order: Float 
}

input UpdateModerationTemplateInput{
  selector: ModerationTemplateSelectorUniqueInput!
  data: UpdateModerationTemplateDataInput!
}

input UpsertModerationTemplateInput{
  selector: ModerationTemplateSelectorUniqueInput!
  data: UpdateModerationTemplateDataInput!
}

input UpdateModerationTemplateDataInput {
  legacyData: JSON 
  contents: JSON 
  name: String 
  collectionName: String 
  order: Float 
  deleted: Boolean 
}

input ModerationTemplateSelectorInput {
  AND: [ModerationTemplateSelectorInput]
  OR: [ModerationTemplateSelectorInput]

}

input ModerationTemplateSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ModerationTemplateOrderByInput {
  foobar
  
}



# Type for ModeratorActions
  type ModeratorAction {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  user: User 
  type: String 
  endedAt: Date 
  active: Boolean! 
  }


input DeleteModeratorActionInput{
  selector: ModeratorActionSelectorUniqueInput!
}

input SingleModeratorActionInput {
  selector: ModeratorActionSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiModeratorActionInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ModeratorActionSelectorInput
  orderBy: ModeratorActionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleModeratorActionOutput{
  result: ModeratorAction
}

type MultiModeratorActionOutput{
  results: [ModeratorAction]
  totalCount: Int
}

type ModeratorActionOutput{
  data: ModeratorAction
}

input CreateModeratorActionInput{
  data: CreateModeratorActionDataInput!
}

input CreateModeratorActionDataInput {
  legacyData: JSON 
  userId: String 
  type: String! 
  endedAt: Date 
}

input UpdateModeratorActionInput{
  selector: ModeratorActionSelectorUniqueInput!
  data: UpdateModeratorActionDataInput!
}

input UpsertModeratorActionInput{
  selector: ModeratorActionSelectorUniqueInput!
  data: UpdateModeratorActionDataInput!
}

input UpdateModeratorActionDataInput {
  legacyData: JSON 
  userId: String 
  type: String 
  endedAt: Date 
}

input ModeratorActionSelectorInput {
  AND: [ModeratorActionSelectorInput]
  OR: [ModeratorActionSelectorInput]

}

input ModeratorActionSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ModeratorActionOrderByInput {
  foobar
  
}



# Type for MultiDocuments
  type MultiDocument {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  contents(version: String): Revision 
  contents_latest: String 
  pingbacks: JSON 
  slug: String 
  oldSlugs: [String] 
  title: String 
  preview: String 
  tabTitle: String 
  tabSubtitle: String 
  userId: String 
  user: User 
  parentDocumentId: String 
  parentTag: Tag 
  parentLens: MultiDocument 
  collectionName: String 
  fieldName: String 
  index: Float 
  tableOfContents(version: String): JSON 
  contributors(limit: Int, version: String): TagContributorsList 
  contributionStats: JSON 
  arbitalLinkedPages: ArbitalLinkedPages 
  htmlWithContributorAnnotations: String 
  summaries: [MultiDocument!]! 
  textLastUpdatedAt: Date 
  deleted: Boolean 
  currentUserVote: String 
  currentUserExtendedVote: JSON 
  voteCount: Float 
  baseScore: Float 
  extendedScore: JSON 
  score: Float 
  afBaseScore: Float 
  afExtendedScore: JSON 
  afVoteCount: Float 
  }


input DeleteMultiDocumentInput{
  selector: MultiDocumentSelectorUniqueInput!
}

input SingleMultiDocumentInput {
  selector: MultiDocumentSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiMultiDocumentInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: MultiDocumentSelectorInput
  orderBy: MultiDocumentOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleMultiDocumentOutput{
  result: MultiDocument
}

type MultiMultiDocumentOutput{
  results: [MultiDocument]
  totalCount: Int
}

type MultiDocumentOutput{
  data: MultiDocument
}

input CreateMultiDocumentInput{
  data: CreateMultiDocumentDataInput!
}

input CreateMultiDocumentDataInput {
  legacyData: JSON 
  contents: JSON 
  title: String 
  tabTitle: String! 
  tabSubtitle: String 
  userId: String 
  parentDocumentId: String! 
  collectionName: String! 
  fieldName: String! 
}

input UpdateMultiDocumentInput{
  selector: MultiDocumentSelectorUniqueInput!
  data: UpdateMultiDocumentDataInput!
}

input UpsertMultiDocumentInput{
  selector: MultiDocumentSelectorUniqueInput!
  data: UpdateMultiDocumentDataInput!
}

input UpdateMultiDocumentDataInput {
  legacyData: JSON 
  contents: JSON 
  title: String 
  tabTitle: String 
  tabSubtitle: String 
  index: Float 
  deleted: Boolean 
}

input MultiDocumentSelectorInput {
  AND: [MultiDocumentSelectorInput]
  OR: [MultiDocumentSelectorInput]

}

input MultiDocumentSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum MultiDocumentOrderByInput {
  foobar
  
}



# Type for Notifications
  type Notification {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  documentId: String 
  documentType: String 
  extraData: JSON 
  link: String 
  title: String 
  message: String 
  type: String 
  deleted: Boolean 
  viewed: Boolean 
  emailed: Boolean 
  waitingForBatch: Boolean 
  }


input DeleteNotificationInput{
  selector: NotificationSelectorUniqueInput!
}

input SingleNotificationInput {
  selector: NotificationSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiNotificationInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: NotificationSelectorInput
  orderBy: NotificationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleNotificationOutput{
  result: Notification
}

type MultiNotificationOutput{
  results: [Notification]
  totalCount: Int
}

type NotificationOutput{
  data: Notification
}

input CreateNotificationInput{
  data: CreateNotificationDataInput!
}

input CreateNotificationDataInput {
  legacyData: JSON 
  viewed: Boolean 
}

input UpdateNotificationInput{
  selector: NotificationSelectorUniqueInput!
  data: UpdateNotificationDataInput!
}

input UpsertNotificationInput{
  selector: NotificationSelectorUniqueInput!
  data: UpdateNotificationDataInput!
}

input UpdateNotificationDataInput {
  legacyData: JSON 
  viewed: Boolean 
}

input NotificationSelectorInput {
  AND: [NotificationSelectorInput]
  OR: [NotificationSelectorInput]

}

input NotificationSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum NotificationOrderByInput {
  foobar
  
}



# Type for PageCache
  type PageCacheEntry {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  }


input DeletePageCacheEntryInput{
  selector: PageCacheEntrySelectorUniqueInput!
}

input SinglePageCacheEntryInput {
  selector: PageCacheEntrySelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiPageCacheEntryInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: PageCacheEntrySelectorInput
  orderBy: PageCacheEntryOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePageCacheEntryOutput{
  result: PageCacheEntry
}

type MultiPageCacheEntryOutput{
  results: [PageCacheEntry]
  totalCount: Int
}

type PageCacheEntryOutput{
  data: PageCacheEntry
}

input CreatePageCacheEntryInput{
  data: CreatePageCacheEntryDataInput!
}

input CreatePageCacheEntryDataInput {
  legacyData: JSON 
}

input UpdatePageCacheEntryInput{
  selector: PageCacheEntrySelectorUniqueInput!
  data: UpdatePageCacheEntryDataInput!
}

input UpsertPageCacheEntryInput{
  selector: PageCacheEntrySelectorUniqueInput!
  data: UpdatePageCacheEntryDataInput!
}

input UpdatePageCacheEntryDataInput {
  legacyData: JSON 
}

input PageCacheEntrySelectorInput {
  AND: [PageCacheEntrySelectorInput]
  OR: [PageCacheEntrySelectorInput]

}

input PageCacheEntrySelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum PageCacheEntryOrderByInput {
  foobar
  
}



# Type for PetrovDayActions
  type PetrovDayAction {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  actionType: String 
  data: JSON 
  userId: String 
  }


input DeletePetrovDayActionInput{
  selector: PetrovDayActionSelectorUniqueInput!
}

input SinglePetrovDayActionInput {
  selector: PetrovDayActionSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiPetrovDayActionInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: PetrovDayActionSelectorInput
  orderBy: PetrovDayActionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePetrovDayActionOutput{
  result: PetrovDayAction
}

type MultiPetrovDayActionOutput{
  results: [PetrovDayAction]
  totalCount: Int
}

type PetrovDayActionOutput{
  data: PetrovDayAction
}

input CreatePetrovDayActionInput{
  data: CreatePetrovDayActionDataInput!
}

input CreatePetrovDayActionDataInput {
  legacyData: JSON 
  actionType: String! 
  data: JSON 
  userId: String! 
}

input UpdatePetrovDayActionInput{
  selector: PetrovDayActionSelectorUniqueInput!
  data: UpdatePetrovDayActionDataInput!
}

input UpsertPetrovDayActionInput{
  selector: PetrovDayActionSelectorUniqueInput!
  data: UpdatePetrovDayActionDataInput!
}

input UpdatePetrovDayActionDataInput {
  legacyData: JSON 
}

input PetrovDayActionSelectorInput {
  AND: [PetrovDayActionSelectorInput]
  OR: [PetrovDayActionSelectorInput]

}

input PetrovDayActionSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum PetrovDayActionOrderByInput {
  foobar
  
}



# Type for PetrovDayLaunchs
  type PetrovDayLaunch {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  launchCode: String 
  hashedLaunchCode: String 
  userId: String 
  }


input DeletePetrovDayLaunchInput{
  selector: PetrovDayLaunchSelectorUniqueInput!
}

input SinglePetrovDayLaunchInput {
  selector: PetrovDayLaunchSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiPetrovDayLaunchInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: PetrovDayLaunchSelectorInput
  orderBy: PetrovDayLaunchOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePetrovDayLaunchOutput{
  result: PetrovDayLaunch
}

type MultiPetrovDayLaunchOutput{
  results: [PetrovDayLaunch]
  totalCount: Int
}

type PetrovDayLaunchOutput{
  data: PetrovDayLaunch
}

input CreatePetrovDayLaunchInput{
  data: CreatePetrovDayLaunchDataInput!
}

input CreatePetrovDayLaunchDataInput {
  legacyData: JSON 
  launchCode: String 
  hashedLaunchCode: String 
  userId: String 
}

input UpdatePetrovDayLaunchInput{
  selector: PetrovDayLaunchSelectorUniqueInput!
  data: UpdatePetrovDayLaunchDataInput!
}

input UpsertPetrovDayLaunchInput{
  selector: PetrovDayLaunchSelectorUniqueInput!
  data: UpdatePetrovDayLaunchDataInput!
}

input UpdatePetrovDayLaunchDataInput {
  legacyData: JSON 
  launchCode: String 
  hashedLaunchCode: String 
  userId: String 
}

input PetrovDayLaunchSelectorInput {
  AND: [PetrovDayLaunchSelectorInput]
  OR: [PetrovDayLaunchSelectorInput]

}

input PetrovDayLaunchSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum PetrovDayLaunchOrderByInput {
  foobar
  
}



# Type for PodcastEpisodes
  type PodcastEpisode {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  podcastId: String 
  podcast: Podcast! 
  title: String 
  episodeLink: String 
  externalEpisodeId: String 
  }


input DeletePodcastEpisodeInput{
  selector: PodcastEpisodeSelectorUniqueInput!
}

input SinglePodcastEpisodeInput {
  selector: PodcastEpisodeSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiPodcastEpisodeInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: PodcastEpisodeSelectorInput
  orderBy: PodcastEpisodeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePodcastEpisodeOutput{
  result: PodcastEpisode
}

type MultiPodcastEpisodeOutput{
  results: [PodcastEpisode]
  totalCount: Int
}

type PodcastEpisodeOutput{
  data: PodcastEpisode
}

input CreatePodcastEpisodeInput{
  data: CreatePodcastEpisodeDataInput!
}

input CreatePodcastEpisodeDataInput {
  legacyData: JSON 
  podcastId: String 
  title: String! 
  episodeLink: String! 
  externalEpisodeId: String! 
}

input UpdatePodcastEpisodeInput{
  selector: PodcastEpisodeSelectorUniqueInput!
  data: UpdatePodcastEpisodeDataInput!
}

input UpsertPodcastEpisodeInput{
  selector: PodcastEpisodeSelectorUniqueInput!
  data: UpdatePodcastEpisodeDataInput!
}

input UpdatePodcastEpisodeDataInput {
  legacyData: JSON 
}

input PodcastEpisodeSelectorInput {
  AND: [PodcastEpisodeSelectorInput]
  OR: [PodcastEpisodeSelectorInput]

}

input PodcastEpisodeSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum PodcastEpisodeOrderByInput {
  foobar
  
}



# Type for Podcasts
  type Podcast {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  title: String 
  applePodcastLink: String 
  spotifyPodcastLink: String 
  }


input DeletePodcastInput{
  selector: PodcastSelectorUniqueInput!
}

input SinglePodcastInput {
  selector: PodcastSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiPodcastInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: PodcastSelectorInput
  orderBy: PodcastOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePodcastOutput{
  result: Podcast
}

type MultiPodcastOutput{
  results: [Podcast]
  totalCount: Int
}

type PodcastOutput{
  data: Podcast
}

input CreatePodcastInput{
  data: CreatePodcastDataInput!
}

input CreatePodcastDataInput {
  legacyData: JSON 
}

input UpdatePodcastInput{
  selector: PodcastSelectorUniqueInput!
  data: UpdatePodcastDataInput!
}

input UpsertPodcastInput{
  selector: PodcastSelectorUniqueInput!
  data: UpdatePodcastDataInput!
}

input UpdatePodcastDataInput {
  legacyData: JSON 
}

input PodcastSelectorInput {
  AND: [PodcastSelectorInput]
  OR: [PodcastSelectorInput]

}

input PodcastSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum PodcastOrderByInput {
  foobar
  
}



# Type for PostEmbeddings
  type PostEmbedding {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  postId: String 
  post: Post! 
  postHash: String 
  lastGeneratedAt: Date 
  model: String 
  embeddings: [Float] 
  }


input DeletePostEmbeddingInput{
  selector: PostEmbeddingSelectorUniqueInput!
}

input SinglePostEmbeddingInput {
  selector: PostEmbeddingSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiPostEmbeddingInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: PostEmbeddingSelectorInput
  orderBy: PostEmbeddingOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostEmbeddingOutput{
  result: PostEmbedding
}

type MultiPostEmbeddingOutput{
  results: [PostEmbedding]
  totalCount: Int
}

type PostEmbeddingOutput{
  data: PostEmbedding
}

input CreatePostEmbeddingInput{
  data: CreatePostEmbeddingDataInput!
}

input CreatePostEmbeddingDataInput {
  legacyData: JSON 
  postId: String! 
  postHash: String! 
  lastGeneratedAt: Date! 
  model: String! 
  embeddings: [Float]! 
}

input UpdatePostEmbeddingInput{
  selector: PostEmbeddingSelectorUniqueInput!
  data: UpdatePostEmbeddingDataInput!
}

input UpsertPostEmbeddingInput{
  selector: PostEmbeddingSelectorUniqueInput!
  data: UpdatePostEmbeddingDataInput!
}

input UpdatePostEmbeddingDataInput {
  legacyData: JSON 
  postId: String 
  postHash: String 
  lastGeneratedAt: Date 
  model: String 
  embeddings: [Float] 
}

input PostEmbeddingSelectorInput {
  AND: [PostEmbeddingSelectorInput]
  OR: [PostEmbeddingSelectorInput]

}

input PostEmbeddingSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum PostEmbeddingOrderByInput {
  foobar
  
}



# Type for PostRecommendations
  type PostRecommendation {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  user: User! 
  clientId: String 
  postId: String 
  post: Post! 
  strategyName: String 
  strategySettings: JSON 
  recommendationCount: Int 
  lastRecommendedAt: Date 
  clickedAt: Date 
  }


input DeletePostRecommendationInput{
  selector: PostRecommendationSelectorUniqueInput!
}

input SinglePostRecommendationInput {
  selector: PostRecommendationSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiPostRecommendationInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: PostRecommendationSelectorInput
  orderBy: PostRecommendationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostRecommendationOutput{
  result: PostRecommendation
}

type MultiPostRecommendationOutput{
  results: [PostRecommendation]
  totalCount: Int
}

type PostRecommendationOutput{
  data: PostRecommendation
}

input CreatePostRecommendationInput{
  data: CreatePostRecommendationDataInput!
}

input CreatePostRecommendationDataInput {
  legacyData: JSON 
  userId: String 
  clientId: String 
  postId: String! 
  strategyName: String! 
  strategySettings: JSON 
  recommendationCount: Int! 
  lastRecommendedAt: Date! 
  clickedAt: Date 
}

input UpdatePostRecommendationInput{
  selector: PostRecommendationSelectorUniqueInput!
  data: UpdatePostRecommendationDataInput!
}

input UpsertPostRecommendationInput{
  selector: PostRecommendationSelectorUniqueInput!
  data: UpdatePostRecommendationDataInput!
}

input UpdatePostRecommendationDataInput {
  legacyData: JSON 
  userId: String 
  clientId: String 
  postId: String 
  strategyName: String 
  strategySettings: JSON 
  recommendationCount: Int 
  lastRecommendedAt: Date 
  clickedAt: Date 
}

input PostRecommendationSelectorInput {
  AND: [PostRecommendationSelectorInput]
  OR: [PostRecommendationSelectorInput]

}

input PostRecommendationSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum PostRecommendationOrderByInput {
  foobar
  
}



# Type for PostRelations
  type PostRelation {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  type: String 
  sourcePostId: String 
  sourcePost: Post 
  targetPostId: String 
  targetPost: Post 
  order: Float 
  }


input DeletePostRelationInput{
  selector: PostRelationSelectorUniqueInput!
}

input SinglePostRelationInput {
  selector: PostRelationSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiPostRelationInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: PostRelationSelectorInput
  orderBy: PostRelationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostRelationOutput{
  result: PostRelation
}

type MultiPostRelationOutput{
  results: [PostRelation]
  totalCount: Int
}

type PostRelationOutput{
  data: PostRelation
}

input CreatePostRelationInput{
  data: CreatePostRelationDataInput!
}

input CreatePostRelationDataInput {
  legacyData: JSON 
  type: String 
  sourcePostId: String! 
  targetPostId: String! 
  order: Float 
}

input UpdatePostRelationInput{
  selector: PostRelationSelectorUniqueInput!
  data: UpdatePostRelationDataInput!
}

input UpsertPostRelationInput{
  selector: PostRelationSelectorUniqueInput!
  data: UpdatePostRelationDataInput!
}

input UpdatePostRelationDataInput {
  legacyData: JSON 
  type: String 
  order: Float 
}

input PostRelationSelectorInput {
  AND: [PostRelationSelectorInput]
  OR: [PostRelationSelectorInput]

}

input PostRelationSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum PostRelationOrderByInput {
  foobar
  
}



# Type for PostViewTimes
  type PostViewTime {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  }


input DeletePostViewTimeInput{
  selector: PostViewTimeSelectorUniqueInput!
}

input SinglePostViewTimeInput {
  selector: PostViewTimeSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiPostViewTimeInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: PostViewTimeSelectorInput
  orderBy: PostViewTimeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostViewTimeOutput{
  result: PostViewTime
}

type MultiPostViewTimeOutput{
  results: [PostViewTime]
  totalCount: Int
}

type PostViewTimeOutput{
  data: PostViewTime
}

input CreatePostViewTimeInput{
  data: CreatePostViewTimeDataInput!
}

input CreatePostViewTimeDataInput {
  legacyData: JSON 
}

input UpdatePostViewTimeInput{
  selector: PostViewTimeSelectorUniqueInput!
  data: UpdatePostViewTimeDataInput!
}

input UpsertPostViewTimeInput{
  selector: PostViewTimeSelectorUniqueInput!
  data: UpdatePostViewTimeDataInput!
}

input UpdatePostViewTimeDataInput {
  legacyData: JSON 
}

input PostViewTimeSelectorInput {
  AND: [PostViewTimeSelectorInput]
  OR: [PostViewTimeSelectorInput]

}

input PostViewTimeSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum PostViewTimeOrderByInput {
  foobar
  
}



# Type for PostViews
  type PostViews {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  }


input DeletePostViewsInput{
  selector: PostViewsSelectorUniqueInput!
}

input SinglePostViewsInput {
  selector: PostViewsSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiPostViewsInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: PostViewsSelectorInput
  orderBy: PostViewsOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostViewsOutput{
  result: PostViews
}

type MultiPostViewsOutput{
  results: [PostViews]
  totalCount: Int
}

type PostViewsOutput{
  data: PostViews
}

input CreatePostViewsInput{
  data: CreatePostViewsDataInput!
}

input CreatePostViewsDataInput {
  legacyData: JSON 
}

input UpdatePostViewsInput{
  selector: PostViewsSelectorUniqueInput!
  data: UpdatePostViewsDataInput!
}

input UpsertPostViewsInput{
  selector: PostViewsSelectorUniqueInput!
  data: UpdatePostViewsDataInput!
}

input UpdatePostViewsDataInput {
  legacyData: JSON 
}

input PostViewsSelectorInput {
  AND: [PostViewsSelectorInput]
  OR: [PostViewsSelectorInput]

}

input PostViewsSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum PostViewsOrderByInput {
  foobar
  
}



# Type for Posts
  type Post {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  contents(version: String): Revision 
  contents_latest: String 
  revisions(limit: Int = 5): [Revision] 
  version: String 
  pingbacks: JSON 
  moderationGuidelines(version: String): Revision 
  moderationGuidelines_latest: String 
  customHighlight(version: String): Revision 
  customHighlight_latest: String 
  slug: String 
  postedAt: Date 
  modifiedAt: Date 
  url: String 
  postCategory: String 
  title: String 
  viewCount: Float 
  lastCommentedAt: Date 
  clickCount: Float 
  deletedDraft: Boolean 
  status: Float 
  isFuture: Boolean 
  sticky: Boolean 
  stickyPriority: Int 
  userIP: String 
  userAgent: String 
  referrer: String 
  author: String 
  userId: String 
  user: User 
  domain: String 
  pageUrl: String! 
  pageUrlRelative: String 
  linkUrl: String 
  postedAtFormatted: String 
  emailShareUrl: String 
  twitterShareUrl: String 
  facebookShareUrl: String 
  socialPreviewImageUrl: String 
  question: Boolean 
  authorIsUnreviewed: Boolean 
  readTimeMinutesOverride: Float 
  readTimeMinutes: Int! 
  wordCount: Int 
  htmlBody: String 
  submitToFrontpage: Boolean 
  hiddenRelatedQuestion: Boolean 
  originalPostRelationSourceId: String 
  sourcePostRelations: [PostRelation!]! 
  targetPostRelations: [PostRelation!]! 
  shortform: Boolean 
  canonicalSource: String 
  nominationCount2018: Float 
  nominationCount2019: Float 
  reviewCount2018: Float 
  reviewCount2019: Float 
  reviewCount: Float 
  reviewVoteCount: Float 
  positiveReviewVoteCount: Float 
  manifoldReviewMarketId: String 
  annualReviewMarketProbability: Float 
  annualReviewMarketIsResolved: Boolean 
  annualReviewMarketYear: Int 
  annualReviewMarketUrl: String 
  glossary: [JargonTerm!]! 
  reviewVoteScoreAF: Float 
  reviewVotesAF: [Float] 
  reviewVoteScoreHighKarma: Float 
  reviewVotesHighKarma: [Float] 
  reviewVoteScoreAllKarma: Float 
  reviewVotesAllKarma: [Float] 
  finalReviewVoteScoreHighKarma: Float 
  finalReviewVotesHighKarma: [Float] 
  finalReviewVoteScoreAllKarma: Float 
  finalReviewVotesAllKarma: [Float] 
  finalReviewVoteScoreAF: Float 
  finalReviewVotesAF: [Float] 
  lastCommentPromotedAt: Date 
  tagRel(tagId: String): TagRel 
  tags: [Tag] 
  tagRelevance: JSON 
  lastPromotedComment: Comment 
  bestAnswer: Comment 
  noIndex: Boolean 
  rsvps: [JSON] 
  rsvpCounts: JSON! 
  activateRSVPs: Boolean 
  nextDayReminderSent: Boolean 
  onlyVisibleToLoggedIn: Boolean 
  onlyVisibleToEstablishedAccounts: Boolean 
  hideFromRecentDiscussions: Boolean 
  currentUserReviewVote: ReviewVote 
  reviewWinner: ReviewWinner 
  spotlight: Spotlight 
  votingSystem: String 
  myEditorAccess: String! 
  podcastEpisodeId: String 
  podcastEpisode: PodcastEpisode 
  forceAllowType3Audio: Boolean 
  legacy: Boolean 
  legacyId: String 
  legacySpam: Boolean 
  feedId: String 
  feed: RSSFeed 
  feedLink: String 
  lastVisitedAt: Date 
  isRead: Boolean 
  curatedDate: Date 
  metaDate: Date 
  suggestForCuratedUserIds: [String] 
  suggestForCuratedUsernames: String 
  frontpageDate: Date 
  autoFrontpage: String 
  collectionTitle: String 
  coauthorStatuses: [JSON] 
  coauthors: [User!] 
  hasCoauthorPermission: Boolean 
  socialPreviewImageId: String 
  socialPreviewImageAutoUrl: String 
  socialPreview: JSON 
  socialPreviewData: SocialPreviewType 
  fmCrosspost: JSON 
  canonicalSequenceId: String 
  canonicalSequence: Sequence 
  canonicalCollectionSlug: String 
  canonicalCollection: Collection 
  canonicalBookId: String 
  canonicalBook: Book 
  canonicalNextPostSlug: String 
  canonicalPrevPostSlug: String 
  nextPost(sequenceId: String): Post 
  prevPost(sequenceId: String): Post 
  sequence(sequenceId: String, prevOrNext: String): Sequence 
  unlisted: Boolean 
  disableRecommendation: Boolean 
  defaultRecommendation: Boolean 
  hideFromPopularComments: Boolean 
  draft: Boolean 
  wasEverUndrafted: Boolean 
  meta: Boolean 
  hideFrontpageComments: Boolean 
  maxBaseScore: Float 
  scoreExceeded2Date: Date 
  scoreExceeded30Date: Date 
  scoreExceeded45Date: Date 
  scoreExceeded75Date: Date 
  scoreExceeded125Date: Date 
  scoreExceeded200Date: Date 
  bannedUserIds: [String] 
  commentsLocked: Boolean 
  commentsLockedToAccountsCreatedAfter: Date 
  organizerIds: [String] 
  organizers: [User!]! 
  groupId: String 
  group: Localgroup 
  eventType: String 
  isEvent: Boolean 
  reviewedByUserId: String 
  reviewedByUser: User 
  reviewForCuratedUserId: String 
  startTime: Date 
  localStartTime: Date 
  endTime: Date 
  localEndTime: Date 
  eventRegistrationLink: String 
  joinEventLink: String 
  onlineEvent: Boolean 
  globalEvent: Boolean 
  mongoLocation: JSON 
  googleLocation: JSON 
  location: String 
  contactInfo: String 
  facebookLink: String 
  meetupLink: String 
  website: String 
  eventImageId: String 
  types: [String] 
  metaSticky: Boolean 
  sharingSettings: JSON 
  shareWithUsers: [String] 
  usersSharedWith: [User!]! 
  linkSharingKey: String 
  linkSharingKeyUsedBy: [String] 
  commentSortOrder: String 
  hideAuthor: Boolean 
  tableOfContents: JSON 
  tableOfContentsRevision(version: String): JSON 
  sideComments: JSON 
  sideCommentsCache: SideCommentCache 
  sideCommentVisibility: String 
  disableSidenotes: Boolean 
  moderationStyle: String 
  ignoreRateLimits: Boolean 
  hideCommentKarma: Boolean 
  commentCount: Float 
  topLevelCommentCount: Float 
  recentComments(commentsLimit: Int, maxAgeHours: Int, af: Boolean): [Comment] 
  languageModelSummary: String! 
  debate: Boolean 
  collabEditorDialogue: Boolean 
  totalDialogueResponseCount: Int! 
  mostRecentPublishedDialogueResponseDate: Date 
  unreadDebateResponseCount: Int! 
  emojiReactors: JSON 
  commentEmojiReactors: JSON 
  rejected: Boolean 
  rejectedReason: String 
  rejectedByUserId: String 
  rejectedByUser: User 
  dialogTooltipPreview: String 
  dialogueMessageContents(dialogueMessageId: String): String 
  firstVideoAttribsForPreview: JSON 
  subforumTagId: String 
  subforumTag: Tag 
  af: Boolean 
  afDate: Date 
  afCommentCount: Float 
  afLastCommentedAt: Date 
  afSticky: Boolean 
  suggestForAlignmentUserIds: [String] 
  suggestForAlignmentUsers: [User!]! 
  reviewForAlignmentUserId: String 
  agentFoundationsId: String 
  swrCachingEnabled: Boolean 
  generateDraftJargon: Boolean 
  curationNotices: [CurationNotice] 
  reviews: [Comment] 
  currentUserVote: String 
  currentUserExtendedVote: JSON 
  voteCount: Float 
  baseScore: Float 
  extendedScore: JSON 
  score: Float 
  afBaseScore: Float 
  afExtendedScore: JSON 
  afVoteCount: Float 
  }


input DeletePostInput{
  selector: PostSelectorUniqueInput!
}

input SinglePostInput {
  selector: PostSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiPostInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: PostSelectorInput
  orderBy: PostOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostOutput{
  result: Post
}

type MultiPostOutput{
  results: [Post]
  totalCount: Int
}

type PostOutput{
  data: Post
}

input CreatePostInput{
  data: CreatePostDataInput!
}

input CreatePostDataInput {
  legacyData: JSON 
  contents: JSON 
  moderationGuidelines: JSON 
  customHighlight: JSON 
  postedAt: Date 
  url: String 
  postCategory: String 
  title: String! 
  status: Float 
  sticky: Boolean 
  stickyPriority: Int 
  userId: String 
  question: Boolean 
  authorIsUnreviewed: Boolean 
  readTimeMinutesOverride: Float 
  submitToFrontpage: Boolean 
  hiddenRelatedQuestion: Boolean 
  originalPostRelationSourceId: String 
  shortform: Boolean 
  canonicalSource: String 
  manifoldReviewMarketId: String 
  tagRelevance: JSON 
  noIndex: Boolean 
  activateRSVPs: Boolean 
  nextDayReminderSent: Boolean 
  onlyVisibleToLoggedIn: Boolean 
  onlyVisibleToEstablishedAccounts: Boolean 
  hideFromRecentDiscussions: Boolean 
  podcastEpisodeId: String 
  forceAllowType3Audio: Boolean 
  legacy: Boolean 
  legacyId: String 
  legacySpam: Boolean 
  feedId: String 
  feedLink: String 
  curatedDate: Date 
  metaDate: Date 
  suggestForCuratedUserIds: [String] 
  frontpageDate: Date 
  autoFrontpage: String 
  collectionTitle: String 
  coauthorStatuses: [JSON] 
  hasCoauthorPermission: Boolean 
  socialPreviewImageId: String 
  socialPreviewImageAutoUrl: String 
  socialPreview: JSON 
  fmCrosspost: JSON 
  canonicalSequenceId: String 
  canonicalCollectionSlug: String 
  canonicalBookId: String 
  canonicalNextPostSlug: String 
  canonicalPrevPostSlug: String 
  unlisted: Boolean 
  disableRecommendation: Boolean 
  defaultRecommendation: Boolean 
  hideFromPopularComments: Boolean 
  draft: Boolean 
  wasEverUndrafted: Boolean 
  meta: Boolean 
  hideFrontpageComments: Boolean 
  bannedUserIds: [String] 
  commentsLocked: Boolean 
  commentsLockedToAccountsCreatedAfter: Date 
  organizerIds: [String] 
  groupId: String 
  eventType: String 
  isEvent: Boolean 
  reviewedByUserId: String 
  reviewForCuratedUserId: String 
  startTime: Date 
  endTime: Date 
  eventRegistrationLink: String 
  joinEventLink: String 
  onlineEvent: Boolean 
  globalEvent: Boolean 
  googleLocation: JSON 
  location: String 
  contactInfo: String 
  facebookLink: String 
  meetupLink: String 
  website: String 
  eventImageId: String 
  types: [String] 
  metaSticky: Boolean 
  sharingSettings: JSON 
  shareWithUsers: [String] 
  commentSortOrder: String 
  hideAuthor: Boolean 
  sideCommentVisibility: String 
  disableSidenotes: Boolean 
  moderationStyle: String 
  ignoreRateLimits: Boolean 
  hideCommentKarma: Boolean 
  debate: Boolean 
  collabEditorDialogue: Boolean 
  rejected: Boolean 
  rejectedReason: String 
  rejectedByUserId: String 
  subforumTagId: String 
  af: Boolean 
  afDate: Date 
  afSticky: Boolean 
  suggestForAlignmentUserIds: [String] 
  reviewForAlignmentUserId: String 
  agentFoundationsId: String 
  swrCachingEnabled: Boolean 
  generateDraftJargon: Boolean 
}

input UpdatePostInput{
  selector: PostSelectorUniqueInput!
  data: UpdatePostDataInput!
}

input UpsertPostInput{
  selector: PostSelectorUniqueInput!
  data: UpdatePostDataInput!
}

input UpdatePostDataInput {
  legacyData: JSON 
  contents: JSON 
  moderationGuidelines: JSON 
  customHighlight: JSON 
  postedAt: Date 
  url: String 
  postCategory: String 
  title: String 
  deletedDraft: Boolean 
  status: Float 
  sticky: Boolean 
  stickyPriority: Int 
  userId: String 
  question: Boolean 
  authorIsUnreviewed: Boolean 
  readTimeMinutesOverride: Float 
  submitToFrontpage: Boolean 
  hiddenRelatedQuestion: Boolean 
  shortform: Boolean 
  canonicalSource: String 
  manifoldReviewMarketId: String 
  tagRelevance: JSON 
  noIndex: Boolean 
  activateRSVPs: Boolean 
  nextDayReminderSent: Boolean 
  onlyVisibleToLoggedIn: Boolean 
  onlyVisibleToEstablishedAccounts: Boolean 
  hideFromRecentDiscussions: Boolean 
  votingSystem: String 
  podcastEpisodeId: String 
  forceAllowType3Audio: Boolean 
  legacy: Boolean 
  legacyId: String 
  legacySpam: Boolean 
  feedId: String 
  feedLink: String 
  curatedDate: Date 
  metaDate: Date 
  suggestForCuratedUserIds: [String] 
  frontpageDate: Date 
  autoFrontpage: String 
  collectionTitle: String 
  coauthorStatuses: [JSON] 
  hasCoauthorPermission: Boolean 
  socialPreviewImageId: String 
  socialPreviewImageAutoUrl: String 
  socialPreview: JSON 
  fmCrosspost: JSON 
  canonicalSequenceId: String 
  canonicalCollectionSlug: String 
  canonicalBookId: String 
  canonicalNextPostSlug: String 
  canonicalPrevPostSlug: String 
  unlisted: Boolean 
  disableRecommendation: Boolean 
  defaultRecommendation: Boolean 
  hideFromPopularComments: Boolean 
  draft: Boolean 
  wasEverUndrafted: Boolean 
  meta: Boolean 
  hideFrontpageComments: Boolean 
  bannedUserIds: [String] 
  commentsLocked: Boolean 
  commentsLockedToAccountsCreatedAfter: Date 
  organizerIds: [String] 
  groupId: String 
  eventType: String 
  isEvent: Boolean 
  reviewedByUserId: String 
  reviewForCuratedUserId: String 
  startTime: Date 
  endTime: Date 
  eventRegistrationLink: String 
  joinEventLink: String 
  onlineEvent: Boolean 
  globalEvent: Boolean 
  googleLocation: JSON 
  location: String 
  contactInfo: String 
  facebookLink: String 
  meetupLink: String 
  website: String 
  eventImageId: String 
  types: [String] 
  metaSticky: Boolean 
  sharingSettings: JSON 
  shareWithUsers: [String] 
  linkSharingKey: String 
  commentSortOrder: String 
  hideAuthor: Boolean 
  sideCommentVisibility: String 
  disableSidenotes: Boolean 
  moderationStyle: String 
  ignoreRateLimits: Boolean 
  hideCommentKarma: Boolean 
  debate: Boolean 
  collabEditorDialogue: Boolean 
  rejected: Boolean 
  rejectedReason: String 
  rejectedByUserId: String 
  subforumTagId: String 
  af: Boolean 
  afDate: Date 
  afSticky: Boolean 
  suggestForAlignmentUserIds: [String] 
  reviewForAlignmentUserId: String 
  agentFoundationsId: String 
  swrCachingEnabled: Boolean 
  generateDraftJargon: Boolean 
}

input PostSelectorInput {
  AND: [PostSelectorInput]
  OR: [PostSelectorInput]

}

input PostSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum PostOrderByInput {
  foobar
  
}



# Type for RSSFeeds
  type RSSFeed {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  user: User 
  ownedByUser: Boolean 
  displayFullContent: Boolean 
  nickname: String 
  url: String 
  status: String 
  rawFeed: JSON 
  setCanonicalUrl: Boolean 
  importAsDraft: Boolean 
  }


input DeleteRSSFeedInput{
  selector: RSSFeedSelectorUniqueInput!
}

input SingleRSSFeedInput {
  selector: RSSFeedSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiRSSFeedInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: RSSFeedSelectorInput
  orderBy: RSSFeedOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleRSSFeedOutput{
  result: RSSFeed
}

type MultiRSSFeedOutput{
  results: [RSSFeed]
  totalCount: Int
}

type RSSFeedOutput{
  data: RSSFeed
}

input CreateRSSFeedInput{
  data: CreateRSSFeedDataInput!
}

input CreateRSSFeedDataInput {
  legacyData: JSON 
  userId: String 
  ownedByUser: Boolean 
  displayFullContent: Boolean 
  nickname: String 
  url: String 
  rawFeed: JSON 
  setCanonicalUrl: Boolean 
  importAsDraft: Boolean 
}

input UpdateRSSFeedInput{
  selector: RSSFeedSelectorUniqueInput!
  data: UpdateRSSFeedDataInput!
}

input UpsertRSSFeedInput{
  selector: RSSFeedSelectorUniqueInput!
  data: UpdateRSSFeedDataInput!
}

input UpdateRSSFeedDataInput {
  legacyData: JSON 
  userId: String 
  ownedByUser: Boolean 
  displayFullContent: Boolean 
  nickname: String 
  url: String 
  status: String 
  rawFeed: JSON 
  setCanonicalUrl: Boolean 
  importAsDraft: Boolean 
}

input RSSFeedSelectorInput {
  AND: [RSSFeedSelectorInput]
  OR: [RSSFeedSelectorInput]

}

input RSSFeedSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum RSSFeedOrderByInput {
  foobar
  
}



# Type for ReadStatuses
  type ReadStatus {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  }


input DeleteReadStatusInput{
  selector: ReadStatusSelectorUniqueInput!
}

input SingleReadStatusInput {
  selector: ReadStatusSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiReadStatusInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ReadStatusSelectorInput
  orderBy: ReadStatusOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReadStatusOutput{
  result: ReadStatus
}

type MultiReadStatusOutput{
  results: [ReadStatus]
  totalCount: Int
}

type ReadStatusOutput{
  data: ReadStatus
}

input CreateReadStatusInput{
  data: CreateReadStatusDataInput!
}

input CreateReadStatusDataInput {
  legacyData: JSON 
}

input UpdateReadStatusInput{
  selector: ReadStatusSelectorUniqueInput!
  data: UpdateReadStatusDataInput!
}

input UpsertReadStatusInput{
  selector: ReadStatusSelectorUniqueInput!
  data: UpdateReadStatusDataInput!
}

input UpdateReadStatusDataInput {
  legacyData: JSON 
}

input ReadStatusSelectorInput {
  AND: [ReadStatusSelectorInput]
  OR: [ReadStatusSelectorInput]

}

input ReadStatusSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ReadStatusOrderByInput {
  foobar
  
}



# Type for RecommendationsCaches
  type RecommendationsCache {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  postId: String 
  source: String 
  scenario: String 
  attributionId: String 
  ttlMs: Float 
  }


input DeleteRecommendationsCacheInput{
  selector: RecommendationsCacheSelectorUniqueInput!
}

input SingleRecommendationsCacheInput {
  selector: RecommendationsCacheSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiRecommendationsCacheInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: RecommendationsCacheSelectorInput
  orderBy: RecommendationsCacheOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleRecommendationsCacheOutput{
  result: RecommendationsCache
}

type MultiRecommendationsCacheOutput{
  results: [RecommendationsCache]
  totalCount: Int
}

type RecommendationsCacheOutput{
  data: RecommendationsCache
}

input CreateRecommendationsCacheInput{
  data: CreateRecommendationsCacheDataInput!
}

input CreateRecommendationsCacheDataInput {
  legacyData: JSON 
  userId: String! 
  postId: String! 
  source: String! 
  scenario: String! 
  attributionId: String! 
  ttlMs: Float! 
}

input UpdateRecommendationsCacheInput{
  selector: RecommendationsCacheSelectorUniqueInput!
  data: UpdateRecommendationsCacheDataInput!
}

input UpsertRecommendationsCacheInput{
  selector: RecommendationsCacheSelectorUniqueInput!
  data: UpdateRecommendationsCacheDataInput!
}

input UpdateRecommendationsCacheDataInput {
  legacyData: JSON 
  userId: String 
  postId: String 
  source: String 
  scenario: String 
  attributionId: String 
  ttlMs: Float 
}

input RecommendationsCacheSelectorInput {
  AND: [RecommendationsCacheSelectorInput]
  OR: [RecommendationsCacheSelectorInput]

}

input RecommendationsCacheSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum RecommendationsCacheOrderByInput {
  foobar
  
}



# Type for Reports
  type Report {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  user: User! 
  reportedUserId: String 
  reportedUser: User 
  commentId: String 
  comment: Comment 
  postId: String 
  post: Post 
  link: String 
  claimedUserId: String 
  claimedUser: User 
  description: String 
  closedAt: Date 
  markedAsSpam: Boolean 
  reportedAsSpam: Boolean 
  }


input DeleteReportInput{
  selector: ReportSelectorUniqueInput!
}

input SingleReportInput {
  selector: ReportSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiReportInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ReportSelectorInput
  orderBy: ReportOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReportOutput{
  result: Report
}

type MultiReportOutput{
  results: [Report]
  totalCount: Int
}

type ReportOutput{
  data: Report
}

input CreateReportInput{
  data: CreateReportDataInput!
}

input CreateReportDataInput {
  legacyData: JSON 
  userId: String 
  reportedUserId: String 
  commentId: String 
  postId: String 
  link: String! 
  claimedUserId: String 
  description: String 
  reportedAsSpam: Boolean 
}

input UpdateReportInput{
  selector: ReportSelectorUniqueInput!
  data: UpdateReportDataInput!
}

input UpsertReportInput{
  selector: ReportSelectorUniqueInput!
  data: UpdateReportDataInput!
}

input UpdateReportDataInput {
  createdAt: Date 
  legacyData: JSON 
  claimedUserId: String 
  description: String 
  closedAt: Date 
  markedAsSpam: Boolean 
  reportedAsSpam: Boolean 
}

input ReportSelectorInput {
  AND: [ReportSelectorInput]
  OR: [ReportSelectorInput]

}

input ReportSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ReportOrderByInput {
  foobar
  
}



# Type for ReviewVotes
  type ReviewVote {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  user: User 
  postId: String 
  post: Post 
  qualitativeScore: Int 
  quadraticScore: Int 
  comment: String 
  year: String 
  dummy: Boolean 
  reactions: [String] 
  }


input DeleteReviewVoteInput{
  selector: ReviewVoteSelectorUniqueInput!
}

input SingleReviewVoteInput {
  selector: ReviewVoteSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiReviewVoteInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ReviewVoteSelectorInput
  orderBy: ReviewVoteOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReviewVoteOutput{
  result: ReviewVote
}

type MultiReviewVoteOutput{
  results: [ReviewVote]
  totalCount: Int
}

type ReviewVoteOutput{
  data: ReviewVote
}

input CreateReviewVoteInput{
  data: CreateReviewVoteDataInput!
}

input CreateReviewVoteDataInput {
  legacyData: JSON 
}

input UpdateReviewVoteInput{
  selector: ReviewVoteSelectorUniqueInput!
  data: UpdateReviewVoteDataInput!
}

input UpsertReviewVoteInput{
  selector: ReviewVoteSelectorUniqueInput!
  data: UpdateReviewVoteDataInput!
}

input UpdateReviewVoteDataInput {
  legacyData: JSON 
}

input ReviewVoteSelectorInput {
  AND: [ReviewVoteSelectorInput]
  OR: [ReviewVoteSelectorInput]

}

input ReviewVoteSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ReviewVoteOrderByInput {
  foobar
  
}



# Type for ReviewWinnerArts
  type ReviewWinnerArt {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  postId: String 
  splashArtImagePrompt: String 
  splashArtImageUrl: String 
  activeSplashArtCoordinates: SplashArtCoordinate 
  }


input DeleteReviewWinnerArtInput{
  selector: ReviewWinnerArtSelectorUniqueInput!
}

input SingleReviewWinnerArtInput {
  selector: ReviewWinnerArtSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiReviewWinnerArtInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ReviewWinnerArtSelectorInput
  orderBy: ReviewWinnerArtOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReviewWinnerArtOutput{
  result: ReviewWinnerArt
}

type MultiReviewWinnerArtOutput{
  results: [ReviewWinnerArt]
  totalCount: Int
}

type ReviewWinnerArtOutput{
  data: ReviewWinnerArt
}

input CreateReviewWinnerArtInput{
  data: CreateReviewWinnerArtDataInput!
}

input CreateReviewWinnerArtDataInput {
  legacyData: JSON 
  postId: String! 
  splashArtImagePrompt: String! 
  splashArtImageUrl: String! 
}

input UpdateReviewWinnerArtInput{
  selector: ReviewWinnerArtSelectorUniqueInput!
  data: UpdateReviewWinnerArtDataInput!
}

input UpsertReviewWinnerArtInput{
  selector: ReviewWinnerArtSelectorUniqueInput!
  data: UpdateReviewWinnerArtDataInput!
}

input UpdateReviewWinnerArtDataInput {
  legacyData: JSON 
  postId: String 
  splashArtImagePrompt: String 
  splashArtImageUrl: String 
}

input ReviewWinnerArtSelectorInput {
  AND: [ReviewWinnerArtSelectorInput]
  OR: [ReviewWinnerArtSelectorInput]

}

input ReviewWinnerArtSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ReviewWinnerArtOrderByInput {
  foobar
  
}



# Type for ReviewWinners
  type ReviewWinner {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  postId: String 
  post: Post! 
  reviewWinnerArt: ReviewWinnerArt 
  competitorCount: Int 
  reviewYear: Float 
  category: String 
  curatedOrder: Float 
  reviewRanking: Float 
  isAI: Boolean 
  }


input DeleteReviewWinnerInput{
  selector: ReviewWinnerSelectorUniqueInput!
}

input SingleReviewWinnerInput {
  selector: ReviewWinnerSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiReviewWinnerInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: ReviewWinnerSelectorInput
  orderBy: ReviewWinnerOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReviewWinnerOutput{
  result: ReviewWinner
}

type MultiReviewWinnerOutput{
  results: [ReviewWinner]
  totalCount: Int
}

type ReviewWinnerOutput{
  data: ReviewWinner
}

input CreateReviewWinnerInput{
  data: CreateReviewWinnerDataInput!
}

input CreateReviewWinnerDataInput {
  legacyData: JSON 
  postId: String! 
  reviewYear: Float! 
  category: String! 
  curatedOrder: Float 
  reviewRanking: Float! 
  isAI: Boolean 
}

input UpdateReviewWinnerInput{
  selector: ReviewWinnerSelectorUniqueInput!
  data: UpdateReviewWinnerDataInput!
}

input UpsertReviewWinnerInput{
  selector: ReviewWinnerSelectorUniqueInput!
  data: UpdateReviewWinnerDataInput!
}

input UpdateReviewWinnerDataInput {
  legacyData: JSON 
  postId: String 
  reviewYear: Float 
  category: String 
  curatedOrder: Float 
  reviewRanking: Float 
  isAI: Boolean 
}

input ReviewWinnerSelectorInput {
  AND: [ReviewWinnerSelectorInput]
  OR: [ReviewWinnerSelectorInput]

}

input ReviewWinnerSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ReviewWinnerOrderByInput {
  foobar
  
}



# Type for Revisions
  type Revision {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  documentId: String 
  collectionName: String 
  fieldName: String 
  editedAt: Date 
  updateType: String 
  version: String 
  commitMessage: String 
  userId: String 
  user: User 
  draft: Boolean 
  originalContents: ContentType 
  html: String 
  markdown: String 
  draftJS: JSON 
  ckEditorMarkup: String 
  wordCount: Float 
  htmlHighlight: String! 
  htmlHighlightStartingAtHash(hash: String): String! 
  plaintextDescription: String! 
  plaintextMainText: String! 
  hasFootnotes: Boolean 
  changeMetrics: JSON 
  googleDocMetadata: JSON 
  skipAttributions: Boolean 
  tag: Tag 
  post: Post 
  lens: MultiDocument 
  summary: MultiDocument 
  currentUserVote: String 
  currentUserExtendedVote: JSON 
  voteCount: Float 
  baseScore: Float 
  extendedScore: JSON 
  score: Float 
  afBaseScore: Float 
  afExtendedScore: JSON 
  afVoteCount: Float 
  }


input DeleteRevisionInput{
  selector: RevisionSelectorUniqueInput!
}

input SingleRevisionInput {
  selector: RevisionSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiRevisionInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: RevisionSelectorInput
  orderBy: RevisionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleRevisionOutput{
  result: Revision
}

type MultiRevisionOutput{
  results: [Revision]
  totalCount: Int
}

type RevisionOutput{
  data: Revision
}

input CreateRevisionInput{
  data: CreateRevisionDataInput!
}

input CreateRevisionDataInput {
  legacyData: JSON 
  updateType: String 
  commitMessage: String 
}

input UpdateRevisionInput{
  selector: RevisionSelectorUniqueInput!
  data: UpdateRevisionDataInput!
}

input UpsertRevisionInput{
  selector: RevisionSelectorUniqueInput!
  data: UpdateRevisionDataInput!
}

input UpdateRevisionDataInput {
  legacyData: JSON 
  skipAttributions: Boolean 
}

input RevisionSelectorInput {
  AND: [RevisionSelectorInput]
  OR: [RevisionSelectorInput]

}

input RevisionSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum RevisionOrderByInput {
  foobar
  
}



# Type for Sequences
  type Sequence {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  contents(version: String): Revision 
  contents_latest: String 
  lastUpdated: Date 
  userId: String 
  user: User 
  title: String 
  bannerImageId: String 
  gridImageId: String 
  hideFromAuthorPage: Boolean 
  draft: Boolean 
  isDeleted: Boolean 
  curatedOrder: Float 
  userProfileOrder: Float 
  canonicalCollectionSlug: String 
  canonicalCollection: Collection 
  hidden: Boolean 
  noindex: Boolean 
  postsCount: Int! 
  readPostsCount: Int! 
  chapters: [Chapter] 
  af: Boolean 
  }


input DeleteSequenceInput{
  selector: SequenceSelectorUniqueInput!
}

input SingleSequenceInput {
  selector: SequenceSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiSequenceInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: SequenceSelectorInput
  orderBy: SequenceOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSequenceOutput{
  result: Sequence
}

type MultiSequenceOutput{
  results: [Sequence]
  totalCount: Int
}

type SequenceOutput{
  data: Sequence
}

input CreateSequenceInput{
  data: CreateSequenceDataInput!
}

input CreateSequenceDataInput {
  legacyData: JSON 
  contents: JSON 
  lastUpdated: Date 
  userId: String 
  title: String! 
  bannerImageId: String 
  gridImageId: String 
  hideFromAuthorPage: Boolean 
  draft: Boolean 
  isDeleted: Boolean 
  curatedOrder: Float 
  userProfileOrder: Float 
  canonicalCollectionSlug: String 
  hidden: Boolean 
  noindex: Boolean 
  af: Boolean 
}

input UpdateSequenceInput{
  selector: SequenceSelectorUniqueInput!
  data: UpdateSequenceDataInput!
}

input UpsertSequenceInput{
  selector: SequenceSelectorUniqueInput!
  data: UpdateSequenceDataInput!
}

input UpdateSequenceDataInput {
  legacyData: JSON 
  contents: JSON 
  lastUpdated: Date 
  userId: String 
  title: String 
  bannerImageId: String 
  gridImageId: String 
  hideFromAuthorPage: Boolean 
  draft: Boolean 
  isDeleted: Boolean 
  curatedOrder: Float 
  userProfileOrder: Float 
  canonicalCollectionSlug: String 
  hidden: Boolean 
  noindex: Boolean 
  af: Boolean 
}

input SequenceSelectorInput {
  AND: [SequenceSelectorInput]
  OR: [SequenceSelectorInput]

}

input SequenceSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum SequenceOrderByInput {
  foobar
  
}



# Type for Sessions
  type Session {
    _id: String 
  session: JSON 
  expires: Date 
  lastModified: Date 
  }


input DeleteSessionInput{
  selector: SessionSelectorUniqueInput!
}

input SingleSessionInput {
  selector: SessionSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiSessionInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: SessionSelectorInput
  orderBy: SessionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSessionOutput{
  result: Session
}

type MultiSessionOutput{
  results: [Session]
  totalCount: Int
}

type SessionOutput{
  data: Session
}

input CreateSessionInput{
  data: CreateSessionDataInput!
}

input CreateSessionDataInput {
  _id: String! 
  session: JSON 
  expires: Date 
  lastModified: Date 
}

input UpdateSessionInput{
  selector: SessionSelectorUniqueInput!
  data: UpdateSessionDataInput!
}

input UpsertSessionInput{
  selector: SessionSelectorUniqueInput!
  data: UpdateSessionDataInput!
}

input UpdateSessionDataInput {
  _id: String 
  session: JSON 
  expires: Date 
  lastModified: Date 
}

input SessionSelectorInput {
  AND: [SessionSelectorInput]
  OR: [SessionSelectorInput]

}

input SessionSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum SessionOrderByInput {
  foobar
  
}



# Type for SideCommentCaches
  type SideCommentCache {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  postId: String 
  annotatedHtml: String 
  commentsByBlock: JSON 
  version: Float 
  }


input DeleteSideCommentCacheInput{
  selector: SideCommentCacheSelectorUniqueInput!
}

input SingleSideCommentCacheInput {
  selector: SideCommentCacheSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiSideCommentCacheInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: SideCommentCacheSelectorInput
  orderBy: SideCommentCacheOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSideCommentCacheOutput{
  result: SideCommentCache
}

type MultiSideCommentCacheOutput{
  results: [SideCommentCache]
  totalCount: Int
}

type SideCommentCacheOutput{
  data: SideCommentCache
}

input CreateSideCommentCacheInput{
  data: CreateSideCommentCacheDataInput!
}

input CreateSideCommentCacheDataInput {
  legacyData: JSON 
}

input UpdateSideCommentCacheInput{
  selector: SideCommentCacheSelectorUniqueInput!
  data: UpdateSideCommentCacheDataInput!
}

input UpsertSideCommentCacheInput{
  selector: SideCommentCacheSelectorUniqueInput!
  data: UpdateSideCommentCacheDataInput!
}

input UpdateSideCommentCacheDataInput {
  legacyData: JSON 
}

input SideCommentCacheSelectorInput {
  AND: [SideCommentCacheSelectorInput]
  OR: [SideCommentCacheSelectorInput]

}

input SideCommentCacheSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum SideCommentCacheOrderByInput {
  foobar
  
}



# Type for SplashArtCoordinates
  type SplashArtCoordinate {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  reviewWinnerArtId: String 
  reviewWinnerArt: ReviewWinnerArt! 
  leftXPct: Float 
  leftYPct: Float 
  leftHeightPct: Float 
  leftWidthPct: Float 
  leftFlipped: Boolean 
  middleXPct: Float 
  middleYPct: Float 
  middleHeightPct: Float 
  middleWidthPct: Float 
  middleFlipped: Boolean 
  rightXPct: Float 
  rightYPct: Float 
  rightHeightPct: Float 
  rightWidthPct: Float 
  rightFlipped: Boolean 
  }


input DeleteSplashArtCoordinateInput{
  selector: SplashArtCoordinateSelectorUniqueInput!
}

input SingleSplashArtCoordinateInput {
  selector: SplashArtCoordinateSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiSplashArtCoordinateInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: SplashArtCoordinateSelectorInput
  orderBy: SplashArtCoordinateOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSplashArtCoordinateOutput{
  result: SplashArtCoordinate
}

type MultiSplashArtCoordinateOutput{
  results: [SplashArtCoordinate]
  totalCount: Int
}

type SplashArtCoordinateOutput{
  data: SplashArtCoordinate
}

input CreateSplashArtCoordinateInput{
  data: CreateSplashArtCoordinateDataInput!
}

input CreateSplashArtCoordinateDataInput {
  legacyData: JSON 
  reviewWinnerArtId: String! 
  leftXPct: Float! 
  leftYPct: Float! 
  leftHeightPct: Float! 
  leftWidthPct: Float! 
  leftFlipped: Boolean 
  middleXPct: Float! 
  middleYPct: Float! 
  middleHeightPct: Float! 
  middleWidthPct: Float! 
  middleFlipped: Boolean 
  rightXPct: Float! 
  rightYPct: Float! 
  rightHeightPct: Float! 
  rightWidthPct: Float! 
  rightFlipped: Boolean! 
}

input UpdateSplashArtCoordinateInput{
  selector: SplashArtCoordinateSelectorUniqueInput!
  data: UpdateSplashArtCoordinateDataInput!
}

input UpsertSplashArtCoordinateInput{
  selector: SplashArtCoordinateSelectorUniqueInput!
  data: UpdateSplashArtCoordinateDataInput!
}

input UpdateSplashArtCoordinateDataInput {
  legacyData: JSON 
  reviewWinnerArtId: String 
  leftXPct: Float 
  leftYPct: Float 
  leftHeightPct: Float 
  leftWidthPct: Float 
  leftFlipped: Boolean 
  middleXPct: Float 
  middleYPct: Float 
  middleHeightPct: Float 
  middleWidthPct: Float 
  middleFlipped: Boolean 
  rightXPct: Float 
  rightYPct: Float 
  rightHeightPct: Float 
  rightWidthPct: Float 
  rightFlipped: Boolean 
}

input SplashArtCoordinateSelectorInput {
  AND: [SplashArtCoordinateSelectorInput]
  OR: [SplashArtCoordinateSelectorInput]

}

input SplashArtCoordinateSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum SplashArtCoordinateOrderByInput {
  foobar
  
}



# Type for Spotlights
  type Spotlight {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  description(version: String): Revision 
  description_latest: String 
  documentId: String 
  document: Post! 
  post: Post 
  sequence: Sequence 
  tag: Tag 
  documentType: String 
  position: Float 
  duration: Float 
  customTitle: String 
  customSubtitle: String 
  subtitleUrl: String 
  headerTitle: String 
  headerTitleLeftColor: String 
  headerTitleRightColor: String 
  lastPromotedAt: Date 
  spotlightSplashImageUrl: String 
  draft: Boolean 
  deletedDraft: Boolean 
  showAuthor: Boolean 
  imageFade: Boolean 
  imageFadeColor: String 
  spotlightImageId: String 
  spotlightDarkImageId: String 
  sequenceChapters: [Chapter] 
  }


input DeleteSpotlightInput{
  selector: SpotlightSelectorUniqueInput!
}

input SingleSpotlightInput {
  selector: SpotlightSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiSpotlightInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: SpotlightSelectorInput
  orderBy: SpotlightOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSpotlightOutput{
  result: Spotlight
}

type MultiSpotlightOutput{
  results: [Spotlight]
  totalCount: Int
}

type SpotlightOutput{
  data: Spotlight
}

input CreateSpotlightInput{
  data: CreateSpotlightDataInput!
}

input CreateSpotlightDataInput {
  legacyData: JSON 
  description: JSON 
  documentId: String! 
  documentType: String! 
  position: Float 
  duration: Float! 
  customTitle: String 
  customSubtitle: String 
  subtitleUrl: String 
  headerTitle: String 
  headerTitleLeftColor: String 
  headerTitleRightColor: String 
  lastPromotedAt: Date! 
  spotlightSplashImageUrl: String 
  draft: Boolean! 
  showAuthor: Boolean 
  imageFade: Boolean 
  imageFadeColor: String 
  spotlightImageId: String 
  spotlightDarkImageId: String 
}

input UpdateSpotlightInput{
  selector: SpotlightSelectorUniqueInput!
  data: UpdateSpotlightDataInput!
}

input UpsertSpotlightInput{
  selector: SpotlightSelectorUniqueInput!
  data: UpdateSpotlightDataInput!
}

input UpdateSpotlightDataInput {
  legacyData: JSON 
  description: JSON 
  documentId: String 
  documentType: String 
  position: Float 
  duration: Float 
  customTitle: String 
  customSubtitle: String 
  subtitleUrl: String 
  headerTitle: String 
  headerTitleLeftColor: String 
  headerTitleRightColor: String 
  lastPromotedAt: Date 
  spotlightSplashImageUrl: String 
  draft: Boolean 
  deletedDraft: Boolean 
  showAuthor: Boolean 
  imageFade: Boolean 
  imageFadeColor: String 
  spotlightImageId: String 
  spotlightDarkImageId: String 
}

input SpotlightSelectorInput {
  AND: [SpotlightSelectorInput]
  OR: [SpotlightSelectorInput]

}

input SpotlightSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum SpotlightOrderByInput {
  foobar
  
}



# Type for Subscriptions
  type Subscription {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  user: User! 
  state: String 
  documentId: String 
  collectionName: String 
  deleted: Boolean 
  type: String 
  }


input DeleteSubscriptionInput{
  selector: SubscriptionSelectorUniqueInput!
}

input SingleSubscriptionInput {
  selector: SubscriptionSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiSubscriptionInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: SubscriptionSelectorInput
  orderBy: SubscriptionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSubscriptionOutput{
  result: Subscription
}

type MultiSubscriptionOutput{
  results: [Subscription]
  totalCount: Int
}

type SubscriptionOutput{
  data: Subscription
}

input CreateSubscriptionInput{
  data: CreateSubscriptionDataInput!
}

input CreateSubscriptionDataInput {
  legacyData: JSON 
  state: String! 
  documentId: String! 
  collectionName: String! 
  type: String! 
}

input UpdateSubscriptionInput{
  selector: SubscriptionSelectorUniqueInput!
  data: UpdateSubscriptionDataInput!
}

input UpsertSubscriptionInput{
  selector: SubscriptionSelectorUniqueInput!
  data: UpdateSubscriptionDataInput!
}

input UpdateSubscriptionDataInput {
  legacyData: JSON 
}

input SubscriptionSelectorInput {
  AND: [SubscriptionSelectorInput]
  OR: [SubscriptionSelectorInput]

}

input SubscriptionSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum SubscriptionOrderByInput {
  foobar
  
}



# Type for SurveyQuestions
  type SurveyQuestion {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  surveyId: String 
  survey: Survey! 
  question: String 
  format: String 
  order: Float 
  }


input DeleteSurveyQuestionInput{
  selector: SurveyQuestionSelectorUniqueInput!
}

input SingleSurveyQuestionInput {
  selector: SurveyQuestionSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiSurveyQuestionInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: SurveyQuestionSelectorInput
  orderBy: SurveyQuestionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSurveyQuestionOutput{
  result: SurveyQuestion
}

type MultiSurveyQuestionOutput{
  results: [SurveyQuestion]
  totalCount: Int
}

type SurveyQuestionOutput{
  data: SurveyQuestion
}

input CreateSurveyQuestionInput{
  data: CreateSurveyQuestionDataInput!
}

input CreateSurveyQuestionDataInput {
  legacyData: JSON 
  surveyId: String! 
  question: String! 
  format: String! 
  order: Float! 
}

input UpdateSurveyQuestionInput{
  selector: SurveyQuestionSelectorUniqueInput!
  data: UpdateSurveyQuestionDataInput!
}

input UpsertSurveyQuestionInput{
  selector: SurveyQuestionSelectorUniqueInput!
  data: UpdateSurveyQuestionDataInput!
}

input UpdateSurveyQuestionDataInput {
  legacyData: JSON 
  surveyId: String 
  question: String 
  format: String 
  order: Float 
}

input SurveyQuestionSelectorInput {
  AND: [SurveyQuestionSelectorInput]
  OR: [SurveyQuestionSelectorInput]

}

input SurveyQuestionSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum SurveyQuestionOrderByInput {
  foobar
  
}



# Type for SurveyResponses
  type SurveyResponse {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  surveyId: String 
  survey: Survey! 
  surveyScheduleId: String 
  surveySchedule: SurveySchedule 
  userId: String 
  user: User 
  clientId: String 
  client: ClientId 
  response: JSON 
  }


input DeleteSurveyResponseInput{
  selector: SurveyResponseSelectorUniqueInput!
}

input SingleSurveyResponseInput {
  selector: SurveyResponseSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiSurveyResponseInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: SurveyResponseSelectorInput
  orderBy: SurveyResponseOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSurveyResponseOutput{
  result: SurveyResponse
}

type MultiSurveyResponseOutput{
  results: [SurveyResponse]
  totalCount: Int
}

type SurveyResponseOutput{
  data: SurveyResponse
}

input CreateSurveyResponseInput{
  data: CreateSurveyResponseDataInput!
}

input CreateSurveyResponseDataInput {
  legacyData: JSON 
  surveyId: String! 
  surveyScheduleId: String! 
  userId: String! 
  clientId: String! 
  response: JSON! 
}

input UpdateSurveyResponseInput{
  selector: SurveyResponseSelectorUniqueInput!
  data: UpdateSurveyResponseDataInput!
}

input UpsertSurveyResponseInput{
  selector: SurveyResponseSelectorUniqueInput!
  data: UpdateSurveyResponseDataInput!
}

input UpdateSurveyResponseDataInput {
  legacyData: JSON 
  surveyId: String 
  surveyScheduleId: String 
  userId: String 
  clientId: String 
  response: JSON 
}

input SurveyResponseSelectorInput {
  AND: [SurveyResponseSelectorInput]
  OR: [SurveyResponseSelectorInput]

}

input SurveyResponseSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum SurveyResponseOrderByInput {
  foobar
  
}



# Type for SurveySchedules
  type SurveySchedule {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  surveyId: String 
  survey: Survey! 
  name: String 
  impressionsLimit: Float 
  maxVisitorPercentage: Float 
  minKarma: Float 
  maxKarma: Float 
  target: String 
  startDate: Date 
  endDate: Date 
  deactivated: Boolean 
  clientIds: [String] 
  clients: [ClientId!]! 
  }


input DeleteSurveyScheduleInput{
  selector: SurveyScheduleSelectorUniqueInput!
}

input SingleSurveyScheduleInput {
  selector: SurveyScheduleSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiSurveyScheduleInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: SurveyScheduleSelectorInput
  orderBy: SurveyScheduleOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSurveyScheduleOutput{
  result: SurveySchedule
}

type MultiSurveyScheduleOutput{
  results: [SurveySchedule]
  totalCount: Int
}

type SurveyScheduleOutput{
  data: SurveySchedule
}

input CreateSurveyScheduleInput{
  data: CreateSurveyScheduleDataInput!
}

input CreateSurveyScheduleDataInput {
  legacyData: JSON 
  surveyId: String! 
  name: String! 
  impressionsLimit: Float 
  maxVisitorPercentage: Float 
  minKarma: Float 
  maxKarma: Float 
  target: String! 
  startDate: Date 
  endDate: Date 
  deactivated: Boolean 
  clientIds: [String]! 
}

input UpdateSurveyScheduleInput{
  selector: SurveyScheduleSelectorUniqueInput!
  data: UpdateSurveyScheduleDataInput!
}

input UpsertSurveyScheduleInput{
  selector: SurveyScheduleSelectorUniqueInput!
  data: UpdateSurveyScheduleDataInput!
}

input UpdateSurveyScheduleDataInput {
  legacyData: JSON 
  surveyId: String 
  name: String 
  impressionsLimit: Float 
  maxVisitorPercentage: Float 
  minKarma: Float 
  maxKarma: Float 
  target: String 
  startDate: Date 
  endDate: Date 
  deactivated: Boolean 
  clientIds: [String] 
}

input SurveyScheduleSelectorInput {
  AND: [SurveyScheduleSelectorInput]
  OR: [SurveyScheduleSelectorInput]

}

input SurveyScheduleSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum SurveyScheduleOrderByInput {
  foobar
  
}



# Type for Surveys
  type Survey {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  name: String 
  questions: [SurveyQuestion!]! 
  }


input DeleteSurveyInput{
  selector: SurveySelectorUniqueInput!
}

input SingleSurveyInput {
  selector: SurveySelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiSurveyInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: SurveySelectorInput
  orderBy: SurveyOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSurveyOutput{
  result: Survey
}

type MultiSurveyOutput{
  results: [Survey]
  totalCount: Int
}

type SurveyOutput{
  data: Survey
}

input CreateSurveyInput{
  data: CreateSurveyDataInput!
}

input CreateSurveyDataInput {
  legacyData: JSON 
  name: String! 
}

input UpdateSurveyInput{
  selector: SurveySelectorUniqueInput!
  data: UpdateSurveyDataInput!
}

input UpsertSurveyInput{
  selector: SurveySelectorUniqueInput!
  data: UpdateSurveyDataInput!
}

input UpdateSurveyDataInput {
  legacyData: JSON 
  name: String 
}

input SurveySelectorInput {
  AND: [SurveySelectorInput]
  OR: [SurveySelectorInput]

}

input SurveySelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum SurveyOrderByInput {
  foobar
  
}



# Type for TagFlags
  type TagFlag {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  contents(version: String): Revision 
  contents_latest: String 
  slug: String 
  name: String 
  deleted: Boolean 
  order: Float 
  }


input DeleteTagFlagInput{
  selector: TagFlagSelectorUniqueInput!
}

input SingleTagFlagInput {
  selector: TagFlagSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiTagFlagInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: TagFlagSelectorInput
  orderBy: TagFlagOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTagFlagOutput{
  result: TagFlag
}

type MultiTagFlagOutput{
  results: [TagFlag]
  totalCount: Int
}

type TagFlagOutput{
  data: TagFlag
}

input CreateTagFlagInput{
  data: CreateTagFlagDataInput!
}

input CreateTagFlagDataInput {
  legacyData: JSON 
  contents: JSON 
  name: String! 
  deleted: Boolean 
  order: Float 
}

input UpdateTagFlagInput{
  selector: TagFlagSelectorUniqueInput!
  data: UpdateTagFlagDataInput!
}

input UpsertTagFlagInput{
  selector: TagFlagSelectorUniqueInput!
  data: UpdateTagFlagDataInput!
}

input UpdateTagFlagDataInput {
  legacyData: JSON 
  contents: JSON 
  name: String 
  deleted: Boolean 
  order: Float 
}

input TagFlagSelectorInput {
  AND: [TagFlagSelectorInput]
  OR: [TagFlagSelectorInput]

}

input TagFlagSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum TagFlagOrderByInput {
  foobar
  
}



# Type for TagRels
  type TagRel {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  tagId: String 
  tag: Tag 
  postId: String 
  post: Post 
  deleted: Boolean 
  userId: String 
  user: User 
  currentUserCanVote: Boolean! 
  autoApplied: Boolean! 
  backfilled: Boolean 
  currentUserVote: String 
  currentUserExtendedVote: JSON 
  voteCount: Float 
  baseScore: Float 
  extendedScore: JSON 
  score: Float 
  afBaseScore: Float 
  afExtendedScore: JSON 
  afVoteCount: Float 
  }


input DeleteTagRelInput{
  selector: TagRelSelectorUniqueInput!
}

input SingleTagRelInput {
  selector: TagRelSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiTagRelInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: TagRelSelectorInput
  orderBy: TagRelOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTagRelOutput{
  result: TagRel
}

type MultiTagRelOutput{
  results: [TagRel]
  totalCount: Int
}

type TagRelOutput{
  data: TagRel
}

input CreateTagRelInput{
  data: CreateTagRelDataInput!
}

input CreateTagRelDataInput {
  legacyData: JSON 
  tagId: String! 
  postId: String! 
  userId: String! 
}

input UpdateTagRelInput{
  selector: TagRelSelectorUniqueInput!
  data: UpdateTagRelDataInput!
}

input UpsertTagRelInput{
  selector: TagRelSelectorUniqueInput!
  data: UpdateTagRelDataInput!
}

input UpdateTagRelDataInput {
  legacyData: JSON 
  deleted: Boolean 
}

input TagRelSelectorInput {
  AND: [TagRelSelectorInput]
  OR: [TagRelSelectorInput]

}

input TagRelSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum TagRelOrderByInput {
  foobar
  
}



# Type for Tags
  type Tag {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  description(version: String): Revision 
  description_latest: String 
  pingbacks: JSON 
  subforumWelcomeText(version: String): Revision 
  subforumWelcomeText_latest: String 
  moderationGuidelines(version: String): Revision 
  moderationGuidelines_latest: String 
  slug: String 
  oldSlugs: [String] 
  name: String 
  shortName: String 
  subtitle: String 
  core: Boolean 
  isPostType: Boolean 
  suggestedAsFilter: Boolean 
  defaultOrder: Float 
  descriptionTruncationCount: Float 
  postCount: Float 
  userId: String 
  user: User 
  adminOnly: Boolean 
  canEditUserIds: [String] 
  charsAdded: Float 
  charsRemoved: Float 
  deleted: Boolean 
  lastCommentedAt: Date 
  lastSubforumCommentAt: Date 
  needsReview: Boolean 
  reviewedByUserId: String 
  reviewedByUser: User 
  wikiGrade: Int 
  recentComments(tagCommentsLimit: Int, maxAgeHours: Int, af: Boolean, tagCommentType: String): [Comment] 
  wikiOnly: Boolean 
  bannerImageId: String 
  squareImageId: String 
  tagFlagsIds: [String] 
  tagFlags: [TagFlag!]! 
  lesswrongWikiImportRevision: String 
  lesswrongWikiImportSlug: String 
  lesswrongWikiImportCompleted: Boolean 
  lastVisitedAt: Date 
  isRead: Boolean 
  tableOfContents(version: String): JSON 
  htmlWithContributorAnnotations: String 
  contributors(limit: Int, version: String): TagContributorsList 
  contributionStats: JSON 
  introSequenceId: String 
  sequence: Sequence 
  postsDefaultSortOrder: String 
  canVoteOnRels: [String] 
  isSubforum: Boolean 
  subforumUnreadMessagesCount: Int 
  subforumModeratorIds: [String] 
  subforumModerators: [User!]! 
  subforumIntroPostId: String 
  subforumIntroPost: Post 
  parentTagId: String 
  parentTag: Tag 
  subTagIds: [String] 
  subTags: [Tag!]! 
  autoTagModel: String 
  autoTagPrompt: String 
  noindex: Boolean 
  lenses(lensSlug: String, version: String): [MultiDocument!]! 
  lensesIncludingDeleted(lensSlug: String, version: String): [MultiDocument!]! 
  isPlaceholderPage: Boolean 
  summaries: [MultiDocument!]! 
  textLastUpdatedAt: Date 
  isArbitalImport: Boolean 
  arbitalLinkedPages: ArbitalLinkedPages 
  coreTagId: String 
  maxScore: Int 
  usersWhoLiked: [UserLikingTag!]! 
  forceAllowType3Audio: Boolean 
  currentUserVote: String 
  currentUserExtendedVote: JSON 
  voteCount: Float 
  baseScore: Float 
  extendedScore: JSON 
  score: Float 
  afBaseScore: Float 
  afExtendedScore: JSON 
  afVoteCount: Float 
  }


input DeleteTagInput{
  selector: TagSelectorUniqueInput!
}

input SingleTagInput {
  selector: TagSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiTagInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: TagSelectorInput
  orderBy: TagOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTagOutput{
  result: Tag
}

type MultiTagOutput{
  results: [Tag]
  totalCount: Int
}

type TagOutput{
  data: Tag
}

input CreateTagInput{
  data: CreateTagDataInput!
}

input CreateTagDataInput {
  legacyData: JSON 
  description: JSON 
  subforumWelcomeText: JSON 
  moderationGuidelines: JSON 
  slug: String 
  name: String! 
  shortName: String 
  subtitle: String 
  core: Boolean 
  isPostType: Boolean 
  suggestedAsFilter: Boolean 
  defaultOrder: Float 
  descriptionTruncationCount: Float 
  adminOnly: Boolean 
  canEditUserIds: [String] 
  reviewedByUserId: String 
  wikiGrade: Int 
  wikiOnly: Boolean 
  bannerImageId: String 
  squareImageId: String 
  tagFlagsIds: [String] 
  introSequenceId: String 
  postsDefaultSortOrder: String 
  canVoteOnRels: [String] 
  isSubforum: Boolean 
  subforumModeratorIds: [String] 
  subforumIntroPostId: String 
  parentTagId: String 
  subTagIds: [String] 
  autoTagModel: String 
  autoTagPrompt: String 
  coreTagId: String 
  forceAllowType3Audio: Boolean 
}

input UpdateTagInput{
  selector: TagSelectorUniqueInput!
  data: UpdateTagDataInput!
}

input UpsertTagInput{
  selector: TagSelectorUniqueInput!
  data: UpdateTagDataInput!
}

input UpdateTagDataInput {
  legacyData: JSON 
  description: JSON 
  subforumWelcomeText: JSON 
  moderationGuidelines: JSON 
  slug: String 
  name: String 
  shortName: String 
  subtitle: String 
  core: Boolean 
  isPostType: Boolean 
  suggestedAsFilter: Boolean 
  defaultOrder: Float 
  descriptionTruncationCount: Float 
  adminOnly: Boolean 
  canEditUserIds: [String] 
  deleted: Boolean 
  needsReview: Boolean 
  reviewedByUserId: String 
  wikiGrade: Int 
  wikiOnly: Boolean 
  bannerImageId: String 
  squareImageId: String 
  tagFlagsIds: [String] 
  introSequenceId: String 
  postsDefaultSortOrder: String 
  canVoteOnRels: [String] 
  isSubforum: Boolean 
  subforumModeratorIds: [String] 
  subforumIntroPostId: String 
  parentTagId: String 
  subTagIds: [String] 
  autoTagModel: String 
  autoTagPrompt: String 
  noindex: Boolean 
  isPlaceholderPage: Boolean 
  coreTagId: String 
  forceAllowType3Audio: Boolean 
}

input TagSelectorInput {
  AND: [TagSelectorInput]
  OR: [TagSelectorInput]

}

input TagSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum TagOrderByInput {
  foobar
  
}



# Type for Tweets
  type Tweet {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  }


input DeleteTweetInput{
  selector: TweetSelectorUniqueInput!
}

input SingleTweetInput {
  selector: TweetSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiTweetInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: TweetSelectorInput
  orderBy: TweetOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTweetOutput{
  result: Tweet
}

type MultiTweetOutput{
  results: [Tweet]
  totalCount: Int
}

type TweetOutput{
  data: Tweet
}

input CreateTweetInput{
  data: CreateTweetDataInput!
}

input CreateTweetDataInput {
  legacyData: JSON 
}

input UpdateTweetInput{
  selector: TweetSelectorUniqueInput!
  data: UpdateTweetDataInput!
}

input UpsertTweetInput{
  selector: TweetSelectorUniqueInput!
  data: UpdateTweetDataInput!
}

input UpdateTweetDataInput {
  legacyData: JSON 
}

input TweetSelectorInput {
  AND: [TweetSelectorInput]
  OR: [TweetSelectorInput]

}

input TweetSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum TweetOrderByInput {
  foobar
  
}



# Type for TypingIndicators
  type TypingIndicator {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  documentId: String 
  lastUpdated: Date 
  }


input DeleteTypingIndicatorInput{
  selector: TypingIndicatorSelectorUniqueInput!
}

input SingleTypingIndicatorInput {
  selector: TypingIndicatorSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiTypingIndicatorInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: TypingIndicatorSelectorInput
  orderBy: TypingIndicatorOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTypingIndicatorOutput{
  result: TypingIndicator
}

type MultiTypingIndicatorOutput{
  results: [TypingIndicator]
  totalCount: Int
}

type TypingIndicatorOutput{
  data: TypingIndicator
}

input CreateTypingIndicatorInput{
  data: CreateTypingIndicatorDataInput!
}

input CreateTypingIndicatorDataInput {
  legacyData: JSON 
  userId: String! 
  documentId: String! 
  lastUpdated: Date! 
}

input UpdateTypingIndicatorInput{
  selector: TypingIndicatorSelectorUniqueInput!
  data: UpdateTypingIndicatorDataInput!
}

input UpsertTypingIndicatorInput{
  selector: TypingIndicatorSelectorUniqueInput!
  data: UpdateTypingIndicatorDataInput!
}

input UpdateTypingIndicatorDataInput {
  legacyData: JSON 
  lastUpdated: Date 
}

input TypingIndicatorSelectorInput {
  AND: [TypingIndicatorSelectorInput]
  OR: [TypingIndicatorSelectorInput]

}

input TypingIndicatorSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum TypingIndicatorOrderByInput {
  foobar
  
}



# Type for UserActivities
  type UserActivity {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  }


input DeleteUserActivityInput{
  selector: UserActivitySelectorUniqueInput!
}

input SingleUserActivityInput {
  selector: UserActivitySelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiUserActivityInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: UserActivitySelectorInput
  orderBy: UserActivityOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserActivityOutput{
  result: UserActivity
}

type MultiUserActivityOutput{
  results: [UserActivity]
  totalCount: Int
}

type UserActivityOutput{
  data: UserActivity
}

input CreateUserActivityInput{
  data: CreateUserActivityDataInput!
}

input CreateUserActivityDataInput {
  legacyData: JSON 
}

input UpdateUserActivityInput{
  selector: UserActivitySelectorUniqueInput!
  data: UpdateUserActivityDataInput!
}

input UpsertUserActivityInput{
  selector: UserActivitySelectorUniqueInput!
  data: UpdateUserActivityDataInput!
}

input UpdateUserActivityDataInput {
  legacyData: JSON 
}

input UserActivitySelectorInput {
  AND: [UserActivitySelectorInput]
  OR: [UserActivitySelectorInput]

}

input UserActivitySelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum UserActivityOrderByInput {
  foobar
  
}



# Type for UserEAGDetails
  type UserEAGDetail {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  user: User 
  careerStage: [String] 
  countryOrRegion: String 
  nearestCity: String 
  willingnessToRelocate: JSON 
  experiencedIn: [String] 
  interestedIn: [String] 
  lastUpdated: Date 
  }


input DeleteUserEAGDetailInput{
  selector: UserEAGDetailSelectorUniqueInput!
}

input SingleUserEAGDetailInput {
  selector: UserEAGDetailSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiUserEAGDetailInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: UserEAGDetailSelectorInput
  orderBy: UserEAGDetailOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserEAGDetailOutput{
  result: UserEAGDetail
}

type MultiUserEAGDetailOutput{
  results: [UserEAGDetail]
  totalCount: Int
}

type UserEAGDetailOutput{
  data: UserEAGDetail
}

input CreateUserEAGDetailInput{
  data: CreateUserEAGDetailDataInput!
}

input CreateUserEAGDetailDataInput {
  legacyData: JSON 
  lastUpdated: Date 
}

input UpdateUserEAGDetailInput{
  selector: UserEAGDetailSelectorUniqueInput!
  data: UpdateUserEAGDetailDataInput!
}

input UpsertUserEAGDetailInput{
  selector: UserEAGDetailSelectorUniqueInput!
  data: UpdateUserEAGDetailDataInput!
}

input UpdateUserEAGDetailDataInput {
  legacyData: JSON 
  careerStage: [String] 
  countryOrRegion: String 
  nearestCity: String 
  willingnessToRelocate: JSON 
  experiencedIn: [String] 
  interestedIn: [String] 
  lastUpdated: Date 
}

input UserEAGDetailSelectorInput {
  AND: [UserEAGDetailSelectorInput]
  OR: [UserEAGDetailSelectorInput]

}

input UserEAGDetailSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum UserEAGDetailOrderByInput {
  foobar
  
}



# Type for UserJobAds
  type UserJobAd {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  user: User 
  jobName: String 
  adState: String 
  reminderSetAt: Date 
  lastUpdated: Date 
  }


input DeleteUserJobAdInput{
  selector: UserJobAdSelectorUniqueInput!
}

input SingleUserJobAdInput {
  selector: UserJobAdSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiUserJobAdInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: UserJobAdSelectorInput
  orderBy: UserJobAdOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserJobAdOutput{
  result: UserJobAd
}

type MultiUserJobAdOutput{
  results: [UserJobAd]
  totalCount: Int
}

type UserJobAdOutput{
  data: UserJobAd
}

input CreateUserJobAdInput{
  data: CreateUserJobAdDataInput!
}

input CreateUserJobAdDataInput {
  legacyData: JSON 
  userId: String! 
  jobName: String! 
  adState: String! 
  reminderSetAt: Date 
  lastUpdated: Date 
}

input UpdateUserJobAdInput{
  selector: UserJobAdSelectorUniqueInput!
  data: UpdateUserJobAdDataInput!
}

input UpsertUserJobAdInput{
  selector: UserJobAdSelectorUniqueInput!
  data: UpdateUserJobAdDataInput!
}

input UpdateUserJobAdDataInput {
  legacyData: JSON 
  adState: String 
  reminderSetAt: Date 
  lastUpdated: Date 
}

input UserJobAdSelectorInput {
  AND: [UserJobAdSelectorInput]
  OR: [UserJobAdSelectorInput]

}

input UserJobAdSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum UserJobAdOrderByInput {
  foobar
  
}



# Type for UserMostValuablePosts
  type UserMostValuablePost {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  user: User 
  postId: String 
  post: Post 
  deleted: Boolean 
  }


input DeleteUserMostValuablePostInput{
  selector: UserMostValuablePostSelectorUniqueInput!
}

input SingleUserMostValuablePostInput {
  selector: UserMostValuablePostSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiUserMostValuablePostInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: UserMostValuablePostSelectorInput
  orderBy: UserMostValuablePostOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserMostValuablePostOutput{
  result: UserMostValuablePost
}

type MultiUserMostValuablePostOutput{
  results: [UserMostValuablePost]
  totalCount: Int
}

type UserMostValuablePostOutput{
  data: UserMostValuablePost
}

input CreateUserMostValuablePostInput{
  data: CreateUserMostValuablePostDataInput!
}

input CreateUserMostValuablePostDataInput {
  legacyData: JSON 
  userId: String! 
  postId: String! 
  deleted: Boolean 
}

input UpdateUserMostValuablePostInput{
  selector: UserMostValuablePostSelectorUniqueInput!
  data: UpdateUserMostValuablePostDataInput!
}

input UpsertUserMostValuablePostInput{
  selector: UserMostValuablePostSelectorUniqueInput!
  data: UpdateUserMostValuablePostDataInput!
}

input UpdateUserMostValuablePostDataInput {
  legacyData: JSON 
  userId: String 
  postId: String 
  deleted: Boolean 
}

input UserMostValuablePostSelectorInput {
  AND: [UserMostValuablePostSelectorInput]
  OR: [UserMostValuablePostSelectorInput]

}

input UserMostValuablePostSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum UserMostValuablePostOrderByInput {
  foobar
  
}



# Type for UserRateLimits
  type UserRateLimit {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  userId: String 
  user: User 
  type: String 
  intervalUnit: String 
  intervalLength: Float 
  actionsPerInterval: Float 
  endedAt: Date 
  }


input DeleteUserRateLimitInput{
  selector: UserRateLimitSelectorUniqueInput!
}

input SingleUserRateLimitInput {
  selector: UserRateLimitSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiUserRateLimitInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: UserRateLimitSelectorInput
  orderBy: UserRateLimitOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserRateLimitOutput{
  result: UserRateLimit
}

type MultiUserRateLimitOutput{
  results: [UserRateLimit]
  totalCount: Int
}

type UserRateLimitOutput{
  data: UserRateLimit
}

input CreateUserRateLimitInput{
  data: CreateUserRateLimitDataInput!
}

input CreateUserRateLimitDataInput {
  legacyData: JSON 
  userId: String! 
  type: String! 
  intervalUnit: String! 
  intervalLength: Float! 
  actionsPerInterval: Float! 
  endedAt: Date 
}

input UpdateUserRateLimitInput{
  selector: UserRateLimitSelectorUniqueInput!
  data: UpdateUserRateLimitDataInput!
}

input UpsertUserRateLimitInput{
  selector: UserRateLimitSelectorUniqueInput!
  data: UpdateUserRateLimitDataInput!
}

input UpdateUserRateLimitDataInput {
  legacyData: JSON 
  userId: String 
  type: String 
  intervalUnit: String 
  intervalLength: Float 
  actionsPerInterval: Float 
  endedAt: Date 
}

input UserRateLimitSelectorInput {
  AND: [UserRateLimitSelectorInput]
  OR: [UserRateLimitSelectorInput]

}

input UserRateLimitSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum UserRateLimitOrderByInput {
  foobar
  
}



# Type for UserTagRels
  type UserTagRel {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  tagId: String 
  tag: Tag 
  userId: String 
  user: User 
  subforumShowUnreadInSidebar: Boolean 
  subforumEmailNotifications: Boolean 
  subforumHideIntroPost: Boolean 
  }


input DeleteUserTagRelInput{
  selector: UserTagRelSelectorUniqueInput!
}

input SingleUserTagRelInput {
  selector: UserTagRelSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiUserTagRelInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: UserTagRelSelectorInput
  orderBy: UserTagRelOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserTagRelOutput{
  result: UserTagRel
}

type MultiUserTagRelOutput{
  results: [UserTagRel]
  totalCount: Int
}

type UserTagRelOutput{
  data: UserTagRel
}

input CreateUserTagRelInput{
  data: CreateUserTagRelDataInput!
}

input CreateUserTagRelDataInput {
  legacyData: JSON 
  tagId: String! 
  userId: String! 
  subforumShowUnreadInSidebar: Boolean 
  subforumEmailNotifications: Boolean 
  subforumHideIntroPost: Boolean 
}

input UpdateUserTagRelInput{
  selector: UserTagRelSelectorUniqueInput!
  data: UpdateUserTagRelDataInput!
}

input UpsertUserTagRelInput{
  selector: UserTagRelSelectorUniqueInput!
  data: UpdateUserTagRelDataInput!
}

input UpdateUserTagRelDataInput {
  legacyData: JSON 
  subforumShowUnreadInSidebar: Boolean 
  subforumEmailNotifications: Boolean 
  subforumHideIntroPost: Boolean 
}

input UserTagRelSelectorInput {
  AND: [UserTagRelSelectorInput]
  OR: [UserTagRelSelectorInput]

}

input UserTagRelSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum UserTagRelOrderByInput {
  foobar
  
}



# Type for Users
  type User {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  moderationGuidelines(version: String): Revision 
  moderationGuidelines_latest: String 
  howOthersCanHelpMe(version: String): Revision 
  howOthersCanHelpMe_latest: String 
  howICanHelpOthers(version: String): Revision 
  howICanHelpOthers_latest: String 
  slug: String 
  oldSlugs: [String] 
  biography(version: String): Revision 
  biography_latest: String 
  username: String 
  emails: [JSON] 
  isAdmin: Boolean 
  services: JSON 
  hasAuth0Id: Boolean 
  displayName: String 
  previousDisplayName: String 
  email: String 
  noindex: Boolean 
  groups: [String] 
  pageUrl: String 
  pagePath: String 
  editUrl: String 
  lwWikiImport: Boolean 
  theme: JSON 
  lastUsedTimezone: String 
  whenConfirmationEmailSent: Date 
  legacy: Boolean 
  commentSorting: String 
  sortDraftsBy: String 
  reactPaletteStyle: String 
  noKibitz: Boolean 
  showHideKarmaOption: Boolean 
  showPostAuthorCard: Boolean 
  hideIntercom: Boolean 
  markDownPostEditor: Boolean 
  hideElicitPredictions: Boolean 
  hideAFNonMemberInitialWarning: Boolean 
  noSingleLineComments: Boolean 
  noCollapseCommentsPosts: Boolean 
  noCollapseCommentsFrontpage: Boolean 
  hideCommunitySection: Boolean 
  expandedFrontpageSections: JSON 
  showCommunityInRecentDiscussion: Boolean 
  hidePostsRecommendations: Boolean 
  petrovOptOut: Boolean 
  optedOutOfSurveys: Boolean 
  postGlossariesPinned: Boolean 
  generateJargonForDrafts: Boolean 
  generateJargonForPublishedPosts: Boolean 
  acceptedTos: Boolean 
  hideNavigationSidebar: Boolean 
  currentFrontpageFilter: String 
  frontpageSelectedTab: String 
  frontpageFilterSettings: JSON 
  hideFrontpageFilterSettingsDesktop: Boolean 
  allPostsTimeframe: String 
  allPostsFilter: String 
  allPostsSorting: String 
  allPostsShowLowKarma: Boolean 
  allPostsIncludeEvents: Boolean 
  allPostsHideCommunity: Boolean 
  allPostsOpenSettings: Boolean 
  draftsListSorting: String 
  draftsListShowArchived: Boolean 
  draftsListShowShared: Boolean 
  lastNotificationsCheck: Date 
  karma: Float 
  goodHeartTokens: Float 
  moderationStyle: String 
  moderatorAssistance: Boolean 
  collapseModerationGuidelines: Boolean 
  bannedUserIds: [String] 
  bannedPersonalUserIds: [String] 
  bookmarkedPostsMetadata: [JSON] 
  bookmarkedPosts: [Post!]! 
  hiddenPostsMetadata: [JSON] 
  hiddenPosts: [Post!]! 
  legacyId: String 
  deleted: Boolean 
  permanentDeletionRequestedAt: Date 
  voteBanned: Boolean 
  nullifyVotes: Boolean 
  deleteContent: Boolean 
  banned: Date 
  IPs: [String!] 
  auto_subscribe_to_my_posts: Boolean 
  auto_subscribe_to_my_comments: Boolean 
  autoSubscribeAsOrganizer: Boolean 
  notificationCommentsOnSubscribedPost: JSON 
  notificationShortformContent: JSON 
  notificationRepliesToMyComments: JSON 
  notificationRepliesToSubscribedComments: JSON 
  notificationSubscribedUserPost: JSON 
  notificationSubscribedUserComment: JSON 
  notificationPostsInGroups: JSON 
  notificationSubscribedTagPost: JSON 
  notificationSubscribedSequencePost: JSON 
  notificationPrivateMessage: JSON 
  notificationSharedWithMe: JSON 
  notificationAlignmentSubmissionApproved: JSON 
  notificationEventInRadius: JSON 
  notificationKarmaPowersGained: JSON 
  notificationRSVPs: JSON 
  notificationGroupAdministration: JSON 
  notificationCommentsOnDraft: JSON 
  notificationPostsNominatedReview: JSON 
  notificationSubforumUnread: JSON 
  notificationNewMention: JSON 
  notificationDialogueMessages: JSON 
  notificationPublishedDialogueMessages: JSON 
  notificationAddedAsCoauthor: JSON 
  notificationDebateCommentsOnSubscribedPost: JSON 
  notificationDebateReplies: JSON 
  notificationDialogueMatch: JSON 
  notificationNewDialogueChecks: JSON 
  notificationYourTurnMatchForm: JSON 
  hideDialogueFacilitation: Boolean 
  revealChecksToAdmins: Boolean 
  optedInToDialogueFacilitation: Boolean 
  showDialoguesList: Boolean 
  showMyDialogues: Boolean 
  showMatches: Boolean 
  showRecommendedPartners: Boolean 
  hideActiveDialogueUsers: Boolean 
  karmaChangeNotifierSettings: JSON 
  karmaChangeLastOpened: Date 
  karmaChangeBatchStart: Date 
  emailSubscribedToCurated: Boolean 
  subscribedToDigest: Boolean 
  unsubscribeFromAll: Boolean 
  hideSubscribePoke: Boolean 
  hideMeetupsPoke: Boolean 
  hideHomeRHS: Boolean 
  frontpagePostCount: Float 
  sequenceCount: Float 
  sequenceDraftCount: Float 
  mongoLocation: JSON 
  googleLocation: JSON 
  location: String 
  mapLocation: JSON 
  mapLocationLatLng: LatLng 
  mapLocationSet: Boolean 
  mapMarkerText: String 
  htmlMapMarkerText: String 
  nearbyEventsNotifications: Boolean 
  nearbyEventsNotificationsLocation: JSON 
  nearbyEventsNotificationsMongoLocation: JSON 
  nearbyEventsNotificationsRadius: Float 
  nearbyPeopleNotificationThreshold: Float 
  hideFrontpageMap: Boolean 
  hideTaggingProgressBar: Boolean 
  hideFrontpageBookAd: Boolean 
  hideFrontpageBook2019Ad: Boolean 
  hideFrontpageBook2020Ad: Boolean 
  sunshineNotes: String 
  sunshineFlagged: Boolean 
  needsReview: Boolean 
  sunshineSnoozed: Boolean 
  snoozedUntilContentCount: Float 
  reviewedByUserId: String 
  reviewedByUser: User 
  isReviewed: Boolean 
  reviewedAt: Date 
  spamRiskScore: Float! 
  afKarma: Float 
  voteCount: Float 
  smallUpvoteCount: Float 
  smallDownvoteCount: Float 
  bigUpvoteCount: Float 
  bigDownvoteCount: Float 
  voteReceivedCount: Float 
  smallUpvoteReceivedCount: Float 
  smallDownvoteReceivedCount: Float 
  bigUpvoteReceivedCount: Float 
  bigDownvoteReceivedCount: Float 
  usersContactedBeforeReview: [String] 
  fullName: String 
  shortformFeedId: String 
  shortformFeed: Post 
  viewUnreviewedComments: Boolean 
  partiallyReadSequences: [JSON] 
  beta: Boolean 
  reviewVotesQuadratic: Boolean 
  reviewVotesQuadratic2019: Boolean 
  reviewVoteCount: Int! 
  reviewVotesQuadratic2020: Boolean 
  petrovPressedButtonDate: Date 
  petrovLaunchCodeDate: Date 
  defaultToCKEditor: Boolean 
  signUpReCaptchaRating: Float 
  noExpandUnreadCommentsReview: Boolean 
  postCount: Float 
  maxPostCount: Float 
  posts(limit: Int = 5): [Post] 
  commentCount: Float 
  maxCommentCount: Float 
  tagRevisionCount: Float 
  abTestKey: String 
  abTestOverrides: JSON 
  reenableDraftJs: Boolean 
  walledGardenInvite: Boolean 
  hideWalledGardenUI: Boolean 
  walledGardenPortalOnboarded: Boolean 
  taggingDashboardCollapsed: Boolean 
  usernameUnset: Boolean 
  paymentEmail: String 
  paymentInfo: String 
  profileUpdatedAt: Date 
  profileImageId: String 
  jobTitle: String 
  organization: String 
  careerStage: [String] 
  website: String 
  bio: String 
  htmlBio: String! 
  fmCrosspostUserId: String 
  linkedinProfileURL: String 
  facebookProfileURL: String 
  blueskyProfileURL: String 
  twitterProfileURL: String 
  twitterProfileURLAdmin: String 
  githubProfileURL: String 
  profileTagIds: [String] 
  profileTags: [Tag!]! 
  organizerOfGroupIds: [String] 
  organizerOfGroups: [Localgroup!]! 
  programParticipation: [String] 
  postingDisabled: Boolean 
  allCommentingDisabled: Boolean 
  commentingOnOtherUsersDisabled: Boolean 
  conversationsDisabled: Boolean 
  associatedClientId: ClientId 
  associatedClientIds: [ClientId!] 
  altAccountsDetected: Boolean 
  acknowledgedNewUserGuidelines: Boolean 
  moderatorActions: [ModeratorAction] 
  subforumPreferredLayout: String 
  hideJobAdUntil: Date 
  criticismTipsDismissed: Boolean 
  hideFromPeopleDirectory: Boolean 
  allowDatadogSessionReplay: Boolean 
  afPostCount: Float 
  afCommentCount: Float 
  afSequenceCount: Float 
  afSequenceDraftCount: Float 
  reviewForAlignmentForumUserId: String 
  afApplicationText: String 
  afSubmittedApplication: Boolean 
  rateLimitNextAbleToComment(postId: String): JSON 
  rateLimitNextAbleToPost(eventForm: Boolean): JSON 
  recentKarmaInfo: JSON 
  hideSunshineSidebar: Boolean 
  inactiveSurveyEmailSentAt: Date 
  userSurveyEmailSentAt: Date 
  karmaChanges(startDate: Date, endDate: Date): KarmaChanges 
  recommendationSettings: JSON 
  }


input DeleteUserInput{
  selector: UserSelectorUniqueInput!
}

input SingleUserInput {
  selector: UserSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiUserInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: UserSelectorInput
  orderBy: UserOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserOutput{
  result: User
}

type MultiUserOutput{
  results: [User]
  totalCount: Int
}

type UserOutput{
  data: User
}

input CreateUserInput{
  data: CreateUserDataInput!
}

input CreateUserDataInput {
  legacyData: JSON 
  moderationGuidelines: JSON 
  howOthersCanHelpMe: JSON 
  howICanHelpOthers: JSON 
  biography: JSON 
  username: String 
  isAdmin: Boolean 
  displayName: String 
  previousDisplayName: String 
  email: String 
  groups: [String] 
  theme: JSON 
  lastUsedTimezone: String 
  whenConfirmationEmailSent: Date 
  legacy: Boolean 
  commentSorting: String 
  noKibitz: Boolean 
  showHideKarmaOption: Boolean 
  showPostAuthorCard: Boolean 
  hideIntercom: Boolean 
  noSingleLineComments: Boolean 
  noCollapseCommentsPosts: Boolean 
  noCollapseCommentsFrontpage: Boolean 
  hideCommunitySection: Boolean 
  expandedFrontpageSections: JSON 
  showCommunityInRecentDiscussion: Boolean 
  hidePostsRecommendations: Boolean 
  petrovOptOut: Boolean 
  optedOutOfSurveys: Boolean 
  postGlossariesPinned: Boolean 
  acceptedTos: Boolean 
  hideNavigationSidebar: Boolean 
  currentFrontpageFilter: String 
  frontpageSelectedTab: String 
  frontpageFilterSettings: JSON 
  hideFrontpageFilterSettingsDesktop: Boolean 
  allPostsTimeframe: String 
  allPostsFilter: String 
  allPostsSorting: String 
  allPostsShowLowKarma: Boolean 
  allPostsIncludeEvents: Boolean 
  allPostsHideCommunity: Boolean 
  allPostsOpenSettings: Boolean 
  draftsListSorting: String 
  draftsListShowArchived: Boolean 
  draftsListShowShared: Boolean 
  lastNotificationsCheck: Date 
  moderationStyle: String 
  moderatorAssistance: Boolean 
  collapseModerationGuidelines: Boolean 
  bannedUserIds: [String] 
  bannedPersonalUserIds: [String] 
  legacyId: String 
  voteBanned: Boolean 
  nullifyVotes: Boolean 
  deleteContent: Boolean 
  banned: Date 
  auto_subscribe_to_my_posts: Boolean 
  auto_subscribe_to_my_comments: Boolean 
  autoSubscribeAsOrganizer: Boolean 
  notificationCommentsOnSubscribedPost: JSON 
  notificationShortformContent: JSON 
  notificationRepliesToMyComments: JSON 
  notificationRepliesToSubscribedComments: JSON 
  notificationSubscribedUserPost: JSON 
  notificationSubscribedUserComment: JSON 
  notificationPostsInGroups: JSON 
  notificationSubscribedTagPost: JSON 
  notificationSubscribedSequencePost: JSON 
  notificationPrivateMessage: JSON 
  notificationSharedWithMe: JSON 
  notificationAlignmentSubmissionApproved: JSON 
  notificationEventInRadius: JSON 
  notificationKarmaPowersGained: JSON 
  notificationRSVPs: JSON 
  notificationGroupAdministration: JSON 
  notificationCommentsOnDraft: JSON 
  notificationPostsNominatedReview: JSON 
  notificationSubforumUnread: JSON 
  notificationNewMention: JSON 
  notificationDialogueMessages: JSON 
  notificationPublishedDialogueMessages: JSON 
  notificationAddedAsCoauthor: JSON 
  notificationDebateCommentsOnSubscribedPost: JSON 
  notificationDebateReplies: JSON 
  notificationDialogueMatch: JSON 
  notificationNewDialogueChecks: JSON 
  notificationYourTurnMatchForm: JSON 
  hideDialogueFacilitation: Boolean 
  revealChecksToAdmins: Boolean 
  optedInToDialogueFacilitation: Boolean 
  showDialoguesList: Boolean! 
  showMyDialogues: Boolean! 
  showMatches: Boolean! 
  showRecommendedPartners: Boolean! 
  hideActiveDialogueUsers: Boolean 
  karmaChangeNotifierSettings: JSON 
  karmaChangeLastOpened: Date 
  karmaChangeBatchStart: Date 
  emailSubscribedToCurated: Boolean 
  subscribedToDigest: Boolean 
  unsubscribeFromAll: Boolean 
  hideSubscribePoke: Boolean 
  hideMeetupsPoke: Boolean 
  hideHomeRHS: Boolean 
  googleLocation: JSON 
  location: String 
  mapLocation: JSON 
  mapMarkerText: String 
  nearbyEventsNotifications: Boolean 
  nearbyEventsNotificationsLocation: JSON 
  nearbyEventsNotificationsRadius: Float 
  nearbyPeopleNotificationThreshold: Float 
  hideFrontpageMap: Boolean 
  hideTaggingProgressBar: Boolean 
  hideFrontpageBookAd: Boolean 
  hideFrontpageBook2019Ad: Boolean 
  hideFrontpageBook2020Ad: Boolean 
  reviewedByUserId: String 
  shortformFeedId: String 
  viewUnreviewedComments: Boolean 
  noExpandUnreadCommentsReview: Boolean 
  profileUpdatedAt: Date! 
  jobTitle: String 
  organization: String 
  careerStage: [String] 
  website: String 
  fmCrosspostUserId: String 
  linkedinProfileURL: String 
  facebookProfileURL: String 
  blueskyProfileURL: String 
  twitterProfileURL: String 
  twitterProfileURLAdmin: String 
  githubProfileURL: String 
  profileTagIds: [String] 
  organizerOfGroupIds: [String] 
  programParticipation: [String] 
  postingDisabled: Boolean 
  allCommentingDisabled: Boolean 
  commentingOnOtherUsersDisabled: Boolean 
  conversationsDisabled: Boolean 
  acknowledgedNewUserGuidelines: Boolean 
  subforumPreferredLayout: String 
  hideJobAdUntil: Date 
  criticismTipsDismissed: Boolean 
  hideFromPeopleDirectory: Boolean 
  allowDatadogSessionReplay: Boolean 
  reviewForAlignmentForumUserId: String 
  afSubmittedApplication: Boolean 
  hideSunshineSidebar: Boolean 
  inactiveSurveyEmailSentAt: Date 
  userSurveyEmailSentAt: Date 
}

input UpdateUserInput{
  selector: UserSelectorUniqueInput!
  data: UpdateUserDataInput!
}

input UpsertUserInput{
  selector: UserSelectorUniqueInput!
  data: UpdateUserDataInput!
}

input UpdateUserDataInput {
  legacyData: JSON 
  moderationGuidelines: JSON 
  howOthersCanHelpMe: JSON 
  howICanHelpOthers: JSON 
  slug: String 
  biography: JSON 
  username: String 
  isAdmin: Boolean 
  displayName: String 
  previousDisplayName: String 
  email: String 
  noindex: Boolean 
  groups: [String] 
  theme: JSON 
  lastUsedTimezone: String 
  whenConfirmationEmailSent: Date 
  legacy: Boolean 
  commentSorting: String 
  sortDraftsBy: String 
  reactPaletteStyle: String 
  noKibitz: Boolean 
  showHideKarmaOption: Boolean 
  showPostAuthorCard: Boolean 
  hideIntercom: Boolean 
  markDownPostEditor: Boolean 
  hideElicitPredictions: Boolean 
  hideAFNonMemberInitialWarning: Boolean 
  noSingleLineComments: Boolean 
  noCollapseCommentsPosts: Boolean 
  noCollapseCommentsFrontpage: Boolean 
  hideCommunitySection: Boolean 
  expandedFrontpageSections: JSON 
  showCommunityInRecentDiscussion: Boolean 
  hidePostsRecommendations: Boolean 
  petrovOptOut: Boolean 
  optedOutOfSurveys: Boolean 
  postGlossariesPinned: Boolean 
  generateJargonForDrafts: Boolean 
  generateJargonForPublishedPosts: Boolean 
  acceptedTos: Boolean 
  hideNavigationSidebar: Boolean 
  currentFrontpageFilter: String 
  frontpageSelectedTab: String 
  frontpageFilterSettings: JSON 
  hideFrontpageFilterSettingsDesktop: Boolean 
  allPostsTimeframe: String 
  allPostsFilter: String 
  allPostsSorting: String 
  allPostsShowLowKarma: Boolean 
  allPostsIncludeEvents: Boolean 
  allPostsHideCommunity: Boolean 
  allPostsOpenSettings: Boolean 
  draftsListSorting: String 
  draftsListShowArchived: Boolean 
  draftsListShowShared: Boolean 
  lastNotificationsCheck: Date 
  moderationStyle: String 
  moderatorAssistance: Boolean 
  collapseModerationGuidelines: Boolean 
  bannedUserIds: [String] 
  bannedPersonalUserIds: [String] 
  bookmarkedPostsMetadata: [JSON] 
  hiddenPostsMetadata: [JSON] 
  legacyId: String 
  deleted: Boolean 
  permanentDeletionRequestedAt: Date 
  voteBanned: Boolean 
  nullifyVotes: Boolean 
  deleteContent: Boolean 
  banned: Date 
  auto_subscribe_to_my_posts: Boolean 
  auto_subscribe_to_my_comments: Boolean 
  autoSubscribeAsOrganizer: Boolean 
  notificationCommentsOnSubscribedPost: JSON 
  notificationShortformContent: JSON 
  notificationRepliesToMyComments: JSON 
  notificationRepliesToSubscribedComments: JSON 
  notificationSubscribedUserPost: JSON 
  notificationSubscribedUserComment: JSON 
  notificationPostsInGroups: JSON 
  notificationSubscribedTagPost: JSON 
  notificationSubscribedSequencePost: JSON 
  notificationPrivateMessage: JSON 
  notificationSharedWithMe: JSON 
  notificationAlignmentSubmissionApproved: JSON 
  notificationEventInRadius: JSON 
  notificationKarmaPowersGained: JSON 
  notificationRSVPs: JSON 
  notificationGroupAdministration: JSON 
  notificationCommentsOnDraft: JSON 
  notificationPostsNominatedReview: JSON 
  notificationSubforumUnread: JSON 
  notificationNewMention: JSON 
  notificationDialogueMessages: JSON 
  notificationPublishedDialogueMessages: JSON 
  notificationAddedAsCoauthor: JSON 
  notificationDebateCommentsOnSubscribedPost: JSON 
  notificationDebateReplies: JSON 
  notificationDialogueMatch: JSON 
  notificationNewDialogueChecks: JSON 
  notificationYourTurnMatchForm: JSON 
  hideDialogueFacilitation: Boolean 
  revealChecksToAdmins: Boolean 
  optedInToDialogueFacilitation: Boolean 
  showDialoguesList: Boolean 
  showMyDialogues: Boolean 
  showMatches: Boolean 
  showRecommendedPartners: Boolean 
  hideActiveDialogueUsers: Boolean 
  karmaChangeNotifierSettings: JSON 
  karmaChangeLastOpened: Date 
  karmaChangeBatchStart: Date 
  emailSubscribedToCurated: Boolean 
  subscribedToDigest: Boolean 
  unsubscribeFromAll: Boolean 
  hideSubscribePoke: Boolean 
  hideMeetupsPoke: Boolean 
  hideHomeRHS: Boolean 
  googleLocation: JSON 
  location: String 
  mapLocation: JSON 
  mapMarkerText: String 
  nearbyEventsNotifications: Boolean 
  nearbyEventsNotificationsLocation: JSON 
  nearbyEventsNotificationsRadius: Float 
  nearbyPeopleNotificationThreshold: Float 
  hideFrontpageMap: Boolean 
  hideTaggingProgressBar: Boolean 
  hideFrontpageBook2019Ad: Boolean 
  hideFrontpageBook2020Ad: Boolean 
  sunshineNotes: String 
  sunshineFlagged: Boolean 
  needsReview: Boolean 
  sunshineSnoozed: Boolean 
  snoozedUntilContentCount: Float 
  reviewedByUserId: String 
  reviewedAt: Date 
  fullName: String 
  shortformFeedId: String 
  viewUnreviewedComments: Boolean 
  partiallyReadSequences: [JSON] 
  beta: Boolean 
  reviewVotesQuadratic: Boolean 
  reviewVotesQuadratic2019: Boolean 
  reviewVotesQuadratic2020: Boolean 
  petrovPressedButtonDate: Date 
  petrovLaunchCodeDate: Date 
  defaultToCKEditor: Boolean 
  signUpReCaptchaRating: Float 
  noExpandUnreadCommentsReview: Boolean 
  abTestKey: String 
  abTestOverrides: JSON 
  walledGardenInvite: Boolean 
  walledGardenPortalOnboarded: Boolean 
  taggingDashboardCollapsed: Boolean 
  usernameUnset: Boolean 
  paymentEmail: String 
  paymentInfo: String 
  profileUpdatedAt: Date 
  profileImageId: String 
  jobTitle: String 
  organization: String 
  careerStage: [String] 
  website: String 
  fmCrosspostUserId: String 
  linkedinProfileURL: String 
  facebookProfileURL: String 
  blueskyProfileURL: String 
  twitterProfileURL: String 
  twitterProfileURLAdmin: String 
  githubProfileURL: String 
  profileTagIds: [String] 
  organizerOfGroupIds: [String] 
  programParticipation: [String] 
  postingDisabled: Boolean 
  allCommentingDisabled: Boolean 
  commentingOnOtherUsersDisabled: Boolean 
  conversationsDisabled: Boolean 
  acknowledgedNewUserGuidelines: Boolean 
  subforumPreferredLayout: String 
  hideJobAdUntil: Date 
  criticismTipsDismissed: Boolean 
  hideFromPeopleDirectory: Boolean 
  allowDatadogSessionReplay: Boolean 
  reviewForAlignmentForumUserId: String 
  afApplicationText: String 
  afSubmittedApplication: Boolean 
  hideSunshineSidebar: Boolean 
  inactiveSurveyEmailSentAt: Date 
  userSurveyEmailSentAt: Date 
  recommendationSettings: JSON 
}

input UserSelectorInput {
  AND: [UserSelectorInput]
  OR: [UserSelectorInput]

}

input UserSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum UserOrderByInput {
  foobar
  
}



# Type for Votes
  type Vote {
    _id: String 
  schemaVersion: Float 
  createdAt: Date 
  legacyData: JSON 
  documentId: String 
  collectionName: String 
  userId: String 
  authorIds: [String] 
  authorId: String 
  voteType: String 
  extendedVoteType: JSON 
  power: Float 
  afPower: Float 
  cancelled: Boolean 
  isUnvote: Boolean 
  votedAt: Date 
  tagRel: TagRel 
  comment: Comment 
  post: Post 
  documentIsAf: Boolean 
  silenceNotification: Boolean 
  }


input DeleteVoteInput{
  selector: VoteSelectorUniqueInput!
}

input SingleVoteInput {
  selector: VoteSelectorUniqueInput
  resolverArgs: JSON
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiVoteInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  resolverArgs: JSON
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # The document to create if none are found
  createIfMissing: JSON
  # OpenCRUD fields
  where: VoteSelectorInput
  orderBy: VoteOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleVoteOutput{
  result: Vote
}

type MultiVoteOutput{
  results: [Vote]
  totalCount: Int
}

type VoteOutput{
  data: Vote
}

input CreateVoteInput{
  data: CreateVoteDataInput!
}

input CreateVoteDataInput {
  legacyData: JSON 
}

input UpdateVoteInput{
  selector: VoteSelectorUniqueInput!
  data: UpdateVoteDataInput!
}

input UpsertVoteInput{
  selector: VoteSelectorUniqueInput!
  data: UpdateVoteDataInput!
}

input UpdateVoteDataInput {
  legacyData: JSON 
}

input VoteSelectorInput {
  AND: [VoteSelectorInput]
  OR: [VoteSelectorInput]

}

input VoteSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum VoteOrderByInput {
  foobar
  
}



type Query {
  # A single AdvisorRequest document fetched by ID or slug
  advisorRequest(input: SingleAdvisorRequestInput): SingleAdvisorRequestOutput
  
  # A list of AdvisorRequest documents matching a set of query terms
  advisorRequests(input: MultiAdvisorRequestInput): MultiAdvisorRequestOutput
  
  # A single ArbitalTagContentRel document fetched by ID or slug
  arbitalTagContentRel(input: SingleArbitalTagContentRelInput): SingleArbitalTagContentRelOutput
  
  # A list of ArbitalTagContentRel documents matching a set of query terms
  arbitalTagContentRels(input: MultiArbitalTagContentRelInput): MultiArbitalTagContentRelOutput
  
  # A single Ban document fetched by ID or slug
  ban(input: SingleBanInput): SingleBanOutput
  
  # A list of Ban documents matching a set of query terms
  bans(input: MultiBanInput): MultiBanOutput
  
  # A single Book document fetched by ID or slug
  book(input: SingleBookInput): SingleBookOutput
  
  # A list of Book documents matching a set of query terms
  books(input: MultiBookInput): MultiBookOutput
  
  # A single Chapter document fetched by ID or slug
  chapter(input: SingleChapterInput): SingleChapterOutput
  
  # A list of Chapter documents matching a set of query terms
  chapters(input: MultiChapterInput): MultiChapterOutput
  
  # A single CkEditorUserSession document fetched by ID or slug
  ckEditorUserSession(input: SingleCkEditorUserSessionInput): SingleCkEditorUserSessionOutput
  
  # A list of CkEditorUserSession documents matching a set of query terms
  ckEditorUserSessions(input: MultiCkEditorUserSessionInput): MultiCkEditorUserSessionOutput
  
  # A single ClientId document fetched by ID or slug
  clientId(input: SingleClientIdInput): SingleClientIdOutput
  
  # A list of ClientId documents matching a set of query terms
  clientIds(input: MultiClientIdInput): MultiClientIdOutput
  
  # A single Collection document fetched by ID or slug
  collection(input: SingleCollectionInput): SingleCollectionOutput
  
  # A list of Collection documents matching a set of query terms
  collections(input: MultiCollectionInput): MultiCollectionOutput
  
  # A single CommentModeratorAction document fetched by ID or slug
  commentModeratorAction(input: SingleCommentModeratorActionInput): SingleCommentModeratorActionOutput
  
  # A list of CommentModeratorAction documents matching a set of query terms
  commentModeratorActions(input: MultiCommentModeratorActionInput): MultiCommentModeratorActionOutput
  
  # A single Comment document fetched by ID or slug
  comment(input: SingleCommentInput): SingleCommentOutput
  
  # A list of Comment documents matching a set of query terms
  comments(input: MultiCommentInput): MultiCommentOutput
  
  # A single Conversation document fetched by ID or slug
  conversation(input: SingleConversationInput): SingleConversationOutput
  
  # A list of Conversation documents matching a set of query terms
  conversations(input: MultiConversationInput): MultiConversationOutput
  
  # A single CurationNotice document fetched by ID or slug
  curationNotice(input: SingleCurationNoticeInput): SingleCurationNoticeOutput
  
  # A list of CurationNotice documents matching a set of query terms
  curationNotices(input: MultiCurationNoticeInput): MultiCurationNoticeOutput
  
  # A single DialogueCheck document fetched by ID or slug
  dialogueCheck(input: SingleDialogueCheckInput): SingleDialogueCheckOutput
  
  # A list of DialogueCheck documents matching a set of query terms
  dialogueChecks(input: MultiDialogueCheckInput): MultiDialogueCheckOutput
  
  # A single DialogueMatchPreference document fetched by ID or slug
  dialogueMatchPreference(input: SingleDialogueMatchPreferenceInput): SingleDialogueMatchPreferenceOutput
  
  # A list of DialogueMatchPreference documents matching a set of query terms
  dialogueMatchPreferences(input: MultiDialogueMatchPreferenceInput): MultiDialogueMatchPreferenceOutput
  
  # A single DigestPost document fetched by ID or slug
  digestPost(input: SingleDigestPostInput): SingleDigestPostOutput
  
  # A list of DigestPost documents matching a set of query terms
  digestPosts(input: MultiDigestPostInput): MultiDigestPostOutput
  
  # A single Digest document fetched by ID or slug
  digest(input: SingleDigestInput): SingleDigestOutput
  
  # A list of Digest documents matching a set of query terms
  digests(input: MultiDigestInput): MultiDigestOutput
  
  # A single ElectionCandidate document fetched by ID or slug
  electionCandidate(input: SingleElectionCandidateInput): SingleElectionCandidateOutput
  
  # A list of ElectionCandidate documents matching a set of query terms
  electionCandidates(input: MultiElectionCandidateInput): MultiElectionCandidateOutput
  
  # A single ElectionVote document fetched by ID or slug
  electionVote(input: SingleElectionVoteInput): SingleElectionVoteOutput
  
  # A list of ElectionVote documents matching a set of query terms
  electionVotes(input: MultiElectionVoteInput): MultiElectionVoteOutput
  
  # A single ElicitQuestionPrediction document fetched by ID or slug
  elicitQuestionPrediction(input: SingleElicitQuestionPredictionInput): SingleElicitQuestionPredictionOutput
  
  # A list of ElicitQuestionPrediction documents matching a set of query terms
  elicitQuestionPredictions(input: MultiElicitQuestionPredictionInput): MultiElicitQuestionPredictionOutput
  
  # A single ElicitQuestion document fetched by ID or slug
  elicitQuestion(input: SingleElicitQuestionInput): SingleElicitQuestionOutput
  
  # A list of ElicitQuestion documents matching a set of query terms
  elicitQuestions(input: MultiElicitQuestionInput): MultiElicitQuestionOutput
  
  # A single FeaturedResource document fetched by ID or slug
  featuredResource(input: SingleFeaturedResourceInput): SingleFeaturedResourceOutput
  
  # A list of FeaturedResource documents matching a set of query terms
  featuredResources(input: MultiFeaturedResourceInput): MultiFeaturedResourceOutput
  
  # A single ForumEvent document fetched by ID or slug
  forumEvent(input: SingleForumEventInput): SingleForumEventOutput
  
  # A list of ForumEvent documents matching a set of query terms
  forumEvents(input: MultiForumEventInput): MultiForumEventOutput
  
  # A single GardenCode document fetched by ID or slug
  gardenCode(input: SingleGardenCodeInput): SingleGardenCodeOutput
  
  # A list of GardenCode documents matching a set of query terms
  gardenCodes(input: MultiGardenCodeInput): MultiGardenCodeOutput
  
  # A single GoogleServiceAccountSession document fetched by ID or slug
  googleServiceAccountSession(input: SingleGoogleServiceAccountSessionInput): SingleGoogleServiceAccountSessionOutput
  
  # A list of GoogleServiceAccountSession documents matching a set of query terms
  googleServiceAccountSessions(input: MultiGoogleServiceAccountSessionInput): MultiGoogleServiceAccountSessionOutput
  
  # A single JargonTerm document fetched by ID or slug
  jargonTerm(input: SingleJargonTermInput): SingleJargonTermOutput
  
  # A list of JargonTerm documents matching a set of query terms
  jargonTerms(input: MultiJargonTermInput): MultiJargonTermOutput
  
  # A single LWEvent document fetched by ID or slug
  lWEvent(input: SingleLWEventInput): SingleLWEventOutput
  
  # A list of LWEvent documents matching a set of query terms
  lWEvents(input: MultiLWEventInput): MultiLWEventOutput
  
  # A single LlmConversation document fetched by ID or slug
  llmConversation(input: SingleLlmConversationInput): SingleLlmConversationOutput
  
  # A list of LlmConversation documents matching a set of query terms
  llmConversations(input: MultiLlmConversationInput): MultiLlmConversationOutput
  
  # A single Localgroup document fetched by ID or slug
  localgroup(input: SingleLocalgroupInput): SingleLocalgroupOutput
  
  # A list of Localgroup documents matching a set of query terms
  localgroups(input: MultiLocalgroupInput): MultiLocalgroupOutput
  
  # A single Message document fetched by ID or slug
  message(input: SingleMessageInput): SingleMessageOutput
  
  # A list of Message documents matching a set of query terms
  messages(input: MultiMessageInput): MultiMessageOutput
  
  # A single ModerationTemplate document fetched by ID or slug
  moderationTemplate(input: SingleModerationTemplateInput): SingleModerationTemplateOutput
  
  # A list of ModerationTemplate documents matching a set of query terms
  moderationTemplates(input: MultiModerationTemplateInput): MultiModerationTemplateOutput
  
  # A single ModeratorAction document fetched by ID or slug
  moderatorAction(input: SingleModeratorActionInput): SingleModeratorActionOutput
  
  # A list of ModeratorAction documents matching a set of query terms
  moderatorActions(input: MultiModeratorActionInput): MultiModeratorActionOutput
  
  # A single MultiDocument document fetched by ID or slug
  multiDocument(input: SingleMultiDocumentInput): SingleMultiDocumentOutput
  
  # A list of MultiDocument documents matching a set of query terms
  multiDocuments(input: MultiMultiDocumentInput): MultiMultiDocumentOutput
  
  # A single Notification document fetched by ID or slug
  notification(input: SingleNotificationInput): SingleNotificationOutput
  
  # A list of Notification documents matching a set of query terms
  notifications(input: MultiNotificationInput): MultiNotificationOutput
  
  # A single PetrovDayAction document fetched by ID or slug
  petrovDayAction(input: SinglePetrovDayActionInput): SinglePetrovDayActionOutput
  
  # A list of PetrovDayAction documents matching a set of query terms
  petrovDayActions(input: MultiPetrovDayActionInput): MultiPetrovDayActionOutput
  
  # A single PodcastEpisode document fetched by ID or slug
  podcastEpisode(input: SinglePodcastEpisodeInput): SinglePodcastEpisodeOutput
  
  # A list of PodcastEpisode documents matching a set of query terms
  podcastEpisodes(input: MultiPodcastEpisodeInput): MultiPodcastEpisodeOutput
  
  # A single Podcast document fetched by ID or slug
  podcast(input: SinglePodcastInput): SinglePodcastOutput
  
  # A list of Podcast documents matching a set of query terms
  podcasts(input: MultiPodcastInput): MultiPodcastOutput
  
  # A single PostEmbedding document fetched by ID or slug
  postEmbedding(input: SinglePostEmbeddingInput): SinglePostEmbeddingOutput
  
  # A list of PostEmbedding documents matching a set of query terms
  postEmbeddings(input: MultiPostEmbeddingInput): MultiPostEmbeddingOutput
  
  # A single PostRelation document fetched by ID or slug
  postRelation(input: SinglePostRelationInput): SinglePostRelationOutput
  
  # A list of PostRelation documents matching a set of query terms
  postRelations(input: MultiPostRelationInput): MultiPostRelationOutput
  
  # A single PostViewTime document fetched by ID or slug
  postViewTime(input: SinglePostViewTimeInput): SinglePostViewTimeOutput
  
  # A list of PostViewTime documents matching a set of query terms
  postViewTimes(input: MultiPostViewTimeInput): MultiPostViewTimeOutput
  
  # A single PostView document fetched by ID or slug
  postViews(input: SinglePostViewsInput): SinglePostViewsOutput
  
  # A list of PostView documents matching a set of query terms
  postViewses(input: MultiPostViewsInput): MultiPostViewsOutput
  
  # A single Post document fetched by ID or slug
  post(input: SinglePostInput): SinglePostOutput
  
  # A list of Post documents matching a set of query terms
  posts(input: MultiPostInput): MultiPostOutput
  
  # A single RSSFeed document fetched by ID or slug
  rSSFeed(input: SingleRSSFeedInput): SingleRSSFeedOutput
  
  # A list of RSSFeed documents matching a set of query terms
  rSSFeeds(input: MultiRSSFeedInput): MultiRSSFeedOutput
  
  # A single Report document fetched by ID or slug
  report(input: SingleReportInput): SingleReportOutput
  
  # A list of Report documents matching a set of query terms
  reports(input: MultiReportInput): MultiReportOutput
  
  # A single ReviewVote document fetched by ID or slug
  reviewVote(input: SingleReviewVoteInput): SingleReviewVoteOutput
  
  # A list of ReviewVote documents matching a set of query terms
  reviewVotes(input: MultiReviewVoteInput): MultiReviewVoteOutput
  
  # A single ReviewWinnerArt document fetched by ID or slug
  reviewWinnerArt(input: SingleReviewWinnerArtInput): SingleReviewWinnerArtOutput
  
  # A list of ReviewWinnerArt documents matching a set of query terms
  reviewWinnerArts(input: MultiReviewWinnerArtInput): MultiReviewWinnerArtOutput
  
  # A single ReviewWinner document fetched by ID or slug
  reviewWinner(input: SingleReviewWinnerInput): SingleReviewWinnerOutput
  
  # A list of ReviewWinner documents matching a set of query terms
  reviewWinners(input: MultiReviewWinnerInput): MultiReviewWinnerOutput
  
  # A single Revision document fetched by ID or slug
  revision(input: SingleRevisionInput): SingleRevisionOutput
  
  # A list of Revision documents matching a set of query terms
  revisions(input: MultiRevisionInput): MultiRevisionOutput
  
  # A single Sequence document fetched by ID or slug
  sequence(input: SingleSequenceInput): SingleSequenceOutput
  
  # A list of Sequence documents matching a set of query terms
  sequences(input: MultiSequenceInput): MultiSequenceOutput
  
  # A single SplashArtCoordinate document fetched by ID or slug
  splashArtCoordinate(input: SingleSplashArtCoordinateInput): SingleSplashArtCoordinateOutput
  
  # A list of SplashArtCoordinate documents matching a set of query terms
  splashArtCoordinates(input: MultiSplashArtCoordinateInput): MultiSplashArtCoordinateOutput
  
  # A single Spotlight document fetched by ID or slug
  spotlight(input: SingleSpotlightInput): SingleSpotlightOutput
  
  # A list of Spotlight documents matching a set of query terms
  spotlights(input: MultiSpotlightInput): MultiSpotlightOutput
  
  # A single Subscription document fetched by ID or slug
  subscription(input: SingleSubscriptionInput): SingleSubscriptionOutput
  
  # A list of Subscription documents matching a set of query terms
  subscriptions(input: MultiSubscriptionInput): MultiSubscriptionOutput
  
  # A single SurveyQuestion document fetched by ID or slug
  surveyQuestion(input: SingleSurveyQuestionInput): SingleSurveyQuestionOutput
  
  # A list of SurveyQuestion documents matching a set of query terms
  surveyQuestions(input: MultiSurveyQuestionInput): MultiSurveyQuestionOutput
  
  # A single SurveyResponse document fetched by ID or slug
  surveyResponse(input: SingleSurveyResponseInput): SingleSurveyResponseOutput
  
  # A list of SurveyResponse documents matching a set of query terms
  surveyResponses(input: MultiSurveyResponseInput): MultiSurveyResponseOutput
  
  # A single SurveySchedule document fetched by ID or slug
  surveySchedule(input: SingleSurveyScheduleInput): SingleSurveyScheduleOutput
  
  # A list of SurveySchedule documents matching a set of query terms
  surveySchedules(input: MultiSurveyScheduleInput): MultiSurveyScheduleOutput
  
  # A single Survey document fetched by ID or slug
  survey(input: SingleSurveyInput): SingleSurveyOutput
  
  # A list of Survey documents matching a set of query terms
  surveys(input: MultiSurveyInput): MultiSurveyOutput
  
  # A single TagFlag document fetched by ID or slug
  tagFlag(input: SingleTagFlagInput): SingleTagFlagOutput
  
  # A list of TagFlag documents matching a set of query terms
  tagFlags(input: MultiTagFlagInput): MultiTagFlagOutput
  
  # A single TagRel document fetched by ID or slug
  tagRel(input: SingleTagRelInput): SingleTagRelOutput
  
  # A list of TagRel documents matching a set of query terms
  tagRels(input: MultiTagRelInput): MultiTagRelOutput
  
  # A single Tag document fetched by ID or slug
  tag(input: SingleTagInput): SingleTagOutput
  
  # A list of Tag documents matching a set of query terms
  tags(input: MultiTagInput): MultiTagOutput
  
  # A single TypingIndicator document fetched by ID or slug
  typingIndicator(input: SingleTypingIndicatorInput): SingleTypingIndicatorOutput
  
  # A list of TypingIndicator documents matching a set of query terms
  typingIndicators(input: MultiTypingIndicatorInput): MultiTypingIndicatorOutput
  
  # A single UserEAGDetail document fetched by ID or slug
  userEAGDetail(input: SingleUserEAGDetailInput): SingleUserEAGDetailOutput
  
  # A list of UserEAGDetail documents matching a set of query terms
  userEAGDetails(input: MultiUserEAGDetailInput): MultiUserEAGDetailOutput
  
  # A single UserJobAd document fetched by ID or slug
  userJobAd(input: SingleUserJobAdInput): SingleUserJobAdOutput
  
  # A list of UserJobAd documents matching a set of query terms
  userJobAds(input: MultiUserJobAdInput): MultiUserJobAdOutput
  
  # A single UserMostValuablePost document fetched by ID or slug
  userMostValuablePost(input: SingleUserMostValuablePostInput): SingleUserMostValuablePostOutput
  
  # A list of UserMostValuablePost documents matching a set of query terms
  userMostValuablePosts(input: MultiUserMostValuablePostInput): MultiUserMostValuablePostOutput
  
  # A single UserRateLimit document fetched by ID or slug
  userRateLimit(input: SingleUserRateLimitInput): SingleUserRateLimitOutput
  
  # A list of UserRateLimit documents matching a set of query terms
  userRateLimits(input: MultiUserRateLimitInput): MultiUserRateLimitOutput
  
  # A single UserTagRel document fetched by ID or slug
  userTagRel(input: SingleUserTagRelInput): SingleUserTagRelOutput
  
  # A list of UserTagRel documents matching a set of query terms
  userTagRels(input: MultiUserTagRelInput): MultiUserTagRelOutput
  
  # A single User document fetched by ID or slug
  user(input: SingleUserInput): SingleUserOutput
  
  # A list of User documents matching a set of query terms
  users(input: MultiUserInput): MultiUserOutput
  
  # A single Vote document fetched by ID or slug
  vote(input: SingleVoteInput): SingleVoteOutput
  
  # A list of Vote documents matching a set of query terms
  votes(input: MultiVoteInput): MultiVoteOutput
  
}


type Mutation {

  # Mutation for creating new AdvisorRequest documents
  createAdvisorRequest(data: CreateAdvisorRequestDataInput!) : AdvisorRequestOutput

  # Mutation for updating a AdvisorRequest document
  updateAdvisorRequest(selector: AdvisorRequestSelectorUniqueInput!, data: UpdateAdvisorRequestDataInput! ) : AdvisorRequestOutput

  # Mutation for creating new ArbitalTagContentRel documents
  createArbitalTagContentRel(data: CreateArbitalTagContentRelDataInput!) : ArbitalTagContentRelOutput

  # Mutation for updating a ArbitalTagContentRel document
  updateArbitalTagContentRel(selector: ArbitalTagContentRelSelectorUniqueInput!, data: UpdateArbitalTagContentRelDataInput! ) : ArbitalTagContentRelOutput

  # Mutation for creating new Ban documents
  createBan(data: CreateBanDataInput!) : BanOutput

  # Mutation for updating a Ban document
  updateBan(selector: BanSelectorUniqueInput!, data: UpdateBanDataInput! ) : BanOutput

  # Mutation for creating new Book documents
  createBook(data: CreateBookDataInput!) : BookOutput

  # Mutation for updating a Book document
  updateBook(selector: BookSelectorUniqueInput!, data: UpdateBookDataInput! ) : BookOutput

  # Mutation for creating new Chapter documents
  createChapter(data: CreateChapterDataInput!) : ChapterOutput

  # Mutation for updating a Chapter document
  updateChapter(selector: ChapterSelectorUniqueInput!, data: UpdateChapterDataInput! ) : ChapterOutput

  # Mutation for creating new Collection documents
  createCollection(data: CreateCollectionDataInput!) : CollectionOutput

  # Mutation for updating a Collection document
  updateCollection(selector: CollectionSelectorUniqueInput!, data: UpdateCollectionDataInput! ) : CollectionOutput

  # Mutation for creating new CommentModeratorAction documents
  createCommentModeratorAction(data: CreateCommentModeratorActionDataInput!) : CommentModeratorActionOutput

  # Mutation for updating a CommentModeratorAction document
  updateCommentModeratorAction(selector: CommentModeratorActionSelectorUniqueInput!, data: UpdateCommentModeratorActionDataInput! ) : CommentModeratorActionOutput

  # Mutation for creating new Comment documents
  createComment(data: CreateCommentDataInput!) : CommentOutput

  # Mutation for updating a Comment document
  updateComment(selector: CommentSelectorUniqueInput!, data: UpdateCommentDataInput! ) : CommentOutput

  # Mutation for creating new Conversation documents
  createConversation(data: CreateConversationDataInput!) : ConversationOutput

  # Mutation for updating a Conversation document
  updateConversation(selector: ConversationSelectorUniqueInput!, data: UpdateConversationDataInput! ) : ConversationOutput

  # Mutation for creating new CurationNotice documents
  createCurationNotice(data: CreateCurationNoticeDataInput!) : CurationNoticeOutput

  # Mutation for updating a CurationNotice document
  updateCurationNotice(selector: CurationNoticeSelectorUniqueInput!, data: UpdateCurationNoticeDataInput! ) : CurationNoticeOutput

  # Mutation for creating new DialogueMatchPreference documents
  createDialogueMatchPreference(data: CreateDialogueMatchPreferenceDataInput!) : DialogueMatchPreferenceOutput

  # Mutation for updating a DialogueMatchPreference document
  updateDialogueMatchPreference(selector: DialogueMatchPreferenceSelectorUniqueInput!, data: UpdateDialogueMatchPreferenceDataInput! ) : DialogueMatchPreferenceOutput

  # Mutation for creating new DigestPost documents
  createDigestPost(data: CreateDigestPostDataInput!) : DigestPostOutput

  # Mutation for updating a DigestPost document
  updateDigestPost(selector: DigestPostSelectorUniqueInput!, data: UpdateDigestPostDataInput! ) : DigestPostOutput

  # Mutation for creating new Digest documents
  createDigest(data: CreateDigestDataInput!) : DigestOutput

  # Mutation for updating a Digest document
  updateDigest(selector: DigestSelectorUniqueInput!, data: UpdateDigestDataInput! ) : DigestOutput

  # Mutation for creating new ElectionCandidate documents
  createElectionCandidate(data: CreateElectionCandidateDataInput!) : ElectionCandidateOutput

  # Mutation for updating a ElectionCandidate document
  updateElectionCandidate(selector: ElectionCandidateSelectorUniqueInput!, data: UpdateElectionCandidateDataInput! ) : ElectionCandidateOutput

  # Mutation for creating new ElectionVote documents
  createElectionVote(data: CreateElectionVoteDataInput!) : ElectionVoteOutput

  # Mutation for updating a ElectionVote document
  updateElectionVote(selector: ElectionVoteSelectorUniqueInput!, data: UpdateElectionVoteDataInput! ) : ElectionVoteOutput

  # Mutation for creating new ElicitQuestion documents
  createElicitQuestion(data: CreateElicitQuestionDataInput!) : ElicitQuestionOutput

  # Mutation for updating a ElicitQuestion document
  updateElicitQuestion(selector: ElicitQuestionSelectorUniqueInput!, data: UpdateElicitQuestionDataInput! ) : ElicitQuestionOutput

  # Mutation for creating new ForumEvent documents
  createForumEvent(data: CreateForumEventDataInput!) : ForumEventOutput

  # Mutation for updating a ForumEvent document
  updateForumEvent(selector: ForumEventSelectorUniqueInput!, data: UpdateForumEventDataInput! ) : ForumEventOutput

  # Mutation for creating new GardenCode documents
  createGardenCode(data: CreateGardenCodeDataInput!) : GardenCodeOutput

  # Mutation for updating a GardenCode document
  updateGardenCode(selector: GardenCodeSelectorUniqueInput!, data: UpdateGardenCodeDataInput! ) : GardenCodeOutput

  # Mutation for creating new GoogleServiceAccountSession documents
  createGoogleServiceAccountSession(data: CreateGoogleServiceAccountSessionDataInput!) : GoogleServiceAccountSessionOutput

  # Mutation for updating a GoogleServiceAccountSession document
  updateGoogleServiceAccountSession(selector: GoogleServiceAccountSessionSelectorUniqueInput!, data: UpdateGoogleServiceAccountSessionDataInput! ) : GoogleServiceAccountSessionOutput

  # Mutation for creating new JargonTerm documents
  createJargonTerm(data: CreateJargonTermDataInput!) : JargonTermOutput

  # Mutation for updating a JargonTerm document
  updateJargonTerm(selector: JargonTermSelectorUniqueInput!, data: UpdateJargonTermDataInput! ) : JargonTermOutput

  # Mutation for creating new LWEvent documents
  createLWEvent(data: CreateLWEventDataInput!) : LWEventOutput

  # Mutation for updating a LWEvent document
  updateLWEvent(selector: LWEventSelectorUniqueInput!, data: UpdateLWEventDataInput! ) : LWEventOutput

  # Mutation for creating new LlmConversation documents
  createLlmConversation(data: CreateLlmConversationDataInput!) : LlmConversationOutput

  # Mutation for updating a LlmConversation document
  updateLlmConversation(selector: LlmConversationSelectorUniqueInput!, data: UpdateLlmConversationDataInput! ) : LlmConversationOutput

  # Mutation for creating new Localgroup documents
  createLocalgroup(data: CreateLocalgroupDataInput!) : LocalgroupOutput

  # Mutation for updating a Localgroup document
  updateLocalgroup(selector: LocalgroupSelectorUniqueInput!, data: UpdateLocalgroupDataInput! ) : LocalgroupOutput

  # Mutation for creating new Message documents
  createMessage(data: CreateMessageDataInput!) : MessageOutput

  # Mutation for updating a Message document
  updateMessage(selector: MessageSelectorUniqueInput!, data: UpdateMessageDataInput! ) : MessageOutput

  # Mutation for creating new ModerationTemplate documents
  createModerationTemplate(data: CreateModerationTemplateDataInput!) : ModerationTemplateOutput

  # Mutation for updating a ModerationTemplate document
  updateModerationTemplate(selector: ModerationTemplateSelectorUniqueInput!, data: UpdateModerationTemplateDataInput! ) : ModerationTemplateOutput

  # Mutation for creating new ModeratorAction documents
  createModeratorAction(data: CreateModeratorActionDataInput!) : ModeratorActionOutput

  # Mutation for updating a ModeratorAction document
  updateModeratorAction(selector: ModeratorActionSelectorUniqueInput!, data: UpdateModeratorActionDataInput! ) : ModeratorActionOutput

  # Mutation for creating new MultiDocument documents
  createMultiDocument(data: CreateMultiDocumentDataInput!) : MultiDocumentOutput

  # Mutation for updating a MultiDocument document
  updateMultiDocument(selector: MultiDocumentSelectorUniqueInput!, data: UpdateMultiDocumentDataInput! ) : MultiDocumentOutput

  # Mutation for creating new Notification documents
  createNotification(data: CreateNotificationDataInput!) : NotificationOutput

  # Mutation for updating a Notification document
  updateNotification(selector: NotificationSelectorUniqueInput!, data: UpdateNotificationDataInput! ) : NotificationOutput

  # Mutation for creating new PetrovDayAction documents
  createPetrovDayAction(data: CreatePetrovDayActionDataInput!) : PetrovDayActionOutput

  # Mutation for updating a PetrovDayAction document
  updatePetrovDayAction(selector: PetrovDayActionSelectorUniqueInput!, data: UpdatePetrovDayActionDataInput! ) : PetrovDayActionOutput

  # Mutation for creating new PodcastEpisode documents
  createPodcastEpisode(data: CreatePodcastEpisodeDataInput!) : PodcastEpisodeOutput

  # Mutation for updating a PodcastEpisode document
  updatePodcastEpisode(selector: PodcastEpisodeSelectorUniqueInput!, data: UpdatePodcastEpisodeDataInput! ) : PodcastEpisodeOutput

  # Mutation for creating new PostEmbedding documents
  createPostEmbedding(data: CreatePostEmbeddingDataInput!) : PostEmbeddingOutput

  # Mutation for updating a PostEmbedding document
  updatePostEmbedding(selector: PostEmbeddingSelectorUniqueInput!, data: UpdatePostEmbeddingDataInput! ) : PostEmbeddingOutput

  # Mutation for creating new PostViewTime documents
  createPostViewTime(data: CreatePostViewTimeDataInput!) : PostViewTimeOutput

  # Mutation for updating a PostViewTime document
  updatePostViewTime(selector: PostViewTimeSelectorUniqueInput!, data: UpdatePostViewTimeDataInput! ) : PostViewTimeOutput

  # Mutation for creating new PostView documents
  createPostViews(data: CreatePostViewsDataInput!) : PostViewsOutput

  # Mutation for updating a PostView document
  updatePostViews(selector: PostViewsSelectorUniqueInput!, data: UpdatePostViewsDataInput! ) : PostViewsOutput

  # Mutation for creating new Post documents
  createPost(data: CreatePostDataInput!) : PostOutput

  # Mutation for updating a Post document
  updatePost(selector: PostSelectorUniqueInput!, data: UpdatePostDataInput! ) : PostOutput

  # Mutation for creating new RSSFeed documents
  createRSSFeed(data: CreateRSSFeedDataInput!) : RSSFeedOutput

  # Mutation for updating a RSSFeed document
  updateRSSFeed(selector: RSSFeedSelectorUniqueInput!, data: UpdateRSSFeedDataInput! ) : RSSFeedOutput

  # Mutation for creating new Report documents
  createReport(data: CreateReportDataInput!) : ReportOutput

  # Mutation for updating a Report document
  updateReport(selector: ReportSelectorUniqueInput!, data: UpdateReportDataInput! ) : ReportOutput

  # Mutation for creating new ReviewWinnerArt documents
  createReviewWinnerArt(data: CreateReviewWinnerArtDataInput!) : ReviewWinnerArtOutput

  # Mutation for updating a ReviewWinnerArt document
  updateReviewWinnerArt(selector: ReviewWinnerArtSelectorUniqueInput!, data: UpdateReviewWinnerArtDataInput! ) : ReviewWinnerArtOutput

  # Mutation for creating new ReviewWinner documents
  createReviewWinner(data: CreateReviewWinnerDataInput!) : ReviewWinnerOutput

  # Mutation for updating a ReviewWinner document
  updateReviewWinner(selector: ReviewWinnerSelectorUniqueInput!, data: UpdateReviewWinnerDataInput! ) : ReviewWinnerOutput

  # Mutation for updating a Revision document
  updateRevision(selector: RevisionSelectorUniqueInput!, data: UpdateRevisionDataInput! ) : RevisionOutput

  # Mutation for creating new Sequence documents
  createSequence(data: CreateSequenceDataInput!) : SequenceOutput

  # Mutation for updating a Sequence document
  updateSequence(selector: SequenceSelectorUniqueInput!, data: UpdateSequenceDataInput! ) : SequenceOutput

  # Mutation for creating new SplashArtCoordinate documents
  createSplashArtCoordinate(data: CreateSplashArtCoordinateDataInput!) : SplashArtCoordinateOutput

  # Mutation for updating a SplashArtCoordinate document
  updateSplashArtCoordinate(selector: SplashArtCoordinateSelectorUniqueInput!, data: UpdateSplashArtCoordinateDataInput! ) : SplashArtCoordinateOutput

  # Mutation for creating new Spotlight documents
  createSpotlight(data: CreateSpotlightDataInput!) : SpotlightOutput

  # Mutation for updating a Spotlight document
  updateSpotlight(selector: SpotlightSelectorUniqueInput!, data: UpdateSpotlightDataInput! ) : SpotlightOutput

  # Mutation for creating new Subscription documents
  createSubscription(data: CreateSubscriptionDataInput!) : SubscriptionOutput

  # Mutation for creating new SurveyQuestion documents
  createSurveyQuestion(data: CreateSurveyQuestionDataInput!) : SurveyQuestionOutput

  # Mutation for updating a SurveyQuestion document
  updateSurveyQuestion(selector: SurveyQuestionSelectorUniqueInput!, data: UpdateSurveyQuestionDataInput! ) : SurveyQuestionOutput

  # Mutation for creating new SurveyResponse documents
  createSurveyResponse(data: CreateSurveyResponseDataInput!) : SurveyResponseOutput

  # Mutation for updating a SurveyResponse document
  updateSurveyResponse(selector: SurveyResponseSelectorUniqueInput!, data: UpdateSurveyResponseDataInput! ) : SurveyResponseOutput

  # Mutation for creating new SurveySchedule documents
  createSurveySchedule(data: CreateSurveyScheduleDataInput!) : SurveyScheduleOutput

  # Mutation for updating a SurveySchedule document
  updateSurveySchedule(selector: SurveyScheduleSelectorUniqueInput!, data: UpdateSurveyScheduleDataInput! ) : SurveyScheduleOutput

  # Mutation for creating new Survey documents
  createSurvey(data: CreateSurveyDataInput!) : SurveyOutput

  # Mutation for updating a Survey document
  updateSurvey(selector: SurveySelectorUniqueInput!, data: UpdateSurveyDataInput! ) : SurveyOutput

  # Mutation for creating new TagFlag documents
  createTagFlag(data: CreateTagFlagDataInput!) : TagFlagOutput

  # Mutation for updating a TagFlag document
  updateTagFlag(selector: TagFlagSelectorUniqueInput!, data: UpdateTagFlagDataInput! ) : TagFlagOutput

  # Mutation for creating new TagRel documents
  createTagRel(data: CreateTagRelDataInput!) : TagRelOutput

  # Mutation for updating a TagRel document
  updateTagRel(selector: TagRelSelectorUniqueInput!, data: UpdateTagRelDataInput! ) : TagRelOutput

  # Mutation for creating new Tag documents
  createTag(data: CreateTagDataInput!) : TagOutput

  # Mutation for updating a Tag document
  updateTag(selector: TagSelectorUniqueInput!, data: UpdateTagDataInput! ) : TagOutput

  # Mutation for creating new UserEAGDetail documents
  createUserEAGDetail(data: CreateUserEAGDetailDataInput!) : UserEAGDetailOutput

  # Mutation for updating a UserEAGDetail document
  updateUserEAGDetail(selector: UserEAGDetailSelectorUniqueInput!, data: UpdateUserEAGDetailDataInput! ) : UserEAGDetailOutput

  # Mutation for creating new UserJobAd documents
  createUserJobAd(data: CreateUserJobAdDataInput!) : UserJobAdOutput

  # Mutation for updating a UserJobAd document
  updateUserJobAd(selector: UserJobAdSelectorUniqueInput!, data: UpdateUserJobAdDataInput! ) : UserJobAdOutput

  # Mutation for creating new UserMostValuablePost documents
  createUserMostValuablePost(data: CreateUserMostValuablePostDataInput!) : UserMostValuablePostOutput

  # Mutation for updating a UserMostValuablePost document
  updateUserMostValuablePost(selector: UserMostValuablePostSelectorUniqueInput!, data: UpdateUserMostValuablePostDataInput! ) : UserMostValuablePostOutput

  # Mutation for creating new UserRateLimit documents
  createUserRateLimit(data: CreateUserRateLimitDataInput!) : UserRateLimitOutput

  # Mutation for updating a UserRateLimit document
  updateUserRateLimit(selector: UserRateLimitSelectorUniqueInput!, data: UpdateUserRateLimitDataInput! ) : UserRateLimitOutput

  # Mutation for creating new UserTagRel documents
  createUserTagRel(data: CreateUserTagRelDataInput!) : UserTagRelOutput

  # Mutation for updating a UserTagRel document
  updateUserTagRel(selector: UserTagRelSelectorUniqueInput!, data: UpdateUserTagRelDataInput! ) : UserTagRelOutput

  # Mutation for creating new User documents
  createUser(data: CreateUserDataInput!) : UserOutput

  # Mutation for updating a User document
  updateUser(selector: UserSelectorUniqueInput!, data: UpdateUserDataInput! ) : UserOutput

}


