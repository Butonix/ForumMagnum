# Generated file - run 'yarn generate' to update.

scalar JSON

scalar Date

type AdvisorRequest {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  interestedInMetaculus: Boolean
  jobAds: JSON
}

input DeleteAdvisorRequestInput {
  selector: AdvisorRequestSelectorUniqueInput!
}

input SingleAdvisorRequestInput {
  selector: AdvisorRequestSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiAdvisorRequestInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: AdvisorRequestSelectorInput
  orderBy: AdvisorRequestOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleAdvisorRequestOutput {
  result: AdvisorRequest
}

type MultiAdvisorRequestOutput {
  results: [AdvisorRequest]
  totalCount: Int
}

type AdvisorRequestOutput {
  data: AdvisorRequest
}

input CreateAdvisorRequestInput {
  data: CreateAdvisorRequestDataInput!
}

input CreateAdvisorRequestDataInput {
  legacyData: JSON
  userId: String!
  interestedInMetaculus: Boolean
  jobAds: JSON
}

input UpdateAdvisorRequestInput {
  selector: AdvisorRequestSelectorUniqueInput!
  data: UpdateAdvisorRequestDataInput!
}

input UpsertAdvisorRequestInput {
  selector: AdvisorRequestSelectorUniqueInput!
  data: UpdateAdvisorRequestDataInput!
}

input UpdateAdvisorRequestDataInput {
  legacyData: JSON
  userId: String
  interestedInMetaculus: Boolean
  jobAds: JSON
}

input AdvisorRequestSelectorInput {
  AND: [AdvisorRequestSelectorInput]
  OR: [AdvisorRequestSelectorInput]
}

input AdvisorRequestSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum AdvisorRequestOrderByInput {
  foobar
}

type ArbitalCaches {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteArbitalCachesInput {
  selector: ArbitalCachesSelectorUniqueInput!
}

input SingleArbitalCachesInput {
  selector: ArbitalCachesSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiArbitalCachesInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ArbitalCachesSelectorInput
  orderBy: ArbitalCachesOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleArbitalCachesOutput {
  result: ArbitalCaches
}

type MultiArbitalCachesOutput {
  results: [ArbitalCaches]
  totalCount: Int
}

type ArbitalCachesOutput {
  data: ArbitalCaches
}

input CreateArbitalCachesInput {
  data: CreateArbitalCachesDataInput!
}

input CreateArbitalCachesDataInput {
  legacyData: JSON
}

input UpdateArbitalCachesInput {
  selector: ArbitalCachesSelectorUniqueInput!
  data: UpdateArbitalCachesDataInput!
}

input UpsertArbitalCachesInput {
  selector: ArbitalCachesSelectorUniqueInput!
  data: UpdateArbitalCachesDataInput!
}

input UpdateArbitalCachesDataInput {
  legacyData: JSON
}

input ArbitalCachesSelectorInput {
  AND: [ArbitalCachesSelectorInput]
  OR: [ArbitalCachesSelectorInput]
}

input ArbitalCachesSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ArbitalCachesOrderByInput {
  foobar
}

type ArbitalTagContentRel {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  parentDocumentId: String
  childDocumentId: String
  parentCollectionName: String
  childCollectionName: String
  type: String
  level: Float
  isStrong: Boolean
}

input DeleteArbitalTagContentRelInput {
  selector: ArbitalTagContentRelSelectorUniqueInput!
}

input SingleArbitalTagContentRelInput {
  selector: ArbitalTagContentRelSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiArbitalTagContentRelInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ArbitalTagContentRelSelectorInput
  orderBy: ArbitalTagContentRelOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleArbitalTagContentRelOutput {
  result: ArbitalTagContentRel
}

type MultiArbitalTagContentRelOutput {
  results: [ArbitalTagContentRel]
  totalCount: Int
}

type ArbitalTagContentRelOutput {
  data: ArbitalTagContentRel
}

input CreateArbitalTagContentRelInput {
  data: CreateArbitalTagContentRelDataInput!
}

input CreateArbitalTagContentRelDataInput {
  legacyData: JSON
  parentDocumentId: String!
  childDocumentId: String!
  parentCollectionName: String!
  childCollectionName: String!
  type: String!
  level: Float!
  isStrong: Boolean!
}

input UpdateArbitalTagContentRelInput {
  selector: ArbitalTagContentRelSelectorUniqueInput!
  data: UpdateArbitalTagContentRelDataInput!
}

input UpsertArbitalTagContentRelInput {
  selector: ArbitalTagContentRelSelectorUniqueInput!
  data: UpdateArbitalTagContentRelDataInput!
}

input UpdateArbitalTagContentRelDataInput {
  legacyData: JSON
}

input ArbitalTagContentRelSelectorInput {
  AND: [ArbitalTagContentRelSelectorInput]
  OR: [ArbitalTagContentRelSelectorInput]
}

input ArbitalTagContentRelSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ArbitalTagContentRelOrderByInput {
  foobar
}

type Ban {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  expirationDate: Date
  userId: String
  user: User
  ip: String
  reason: String
  comment: String
  properties: JSON
}

input DeleteBanInput {
  selector: BanSelectorUniqueInput!
}

input SingleBanInput {
  selector: BanSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiBanInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: BanSelectorInput
  orderBy: BanOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleBanOutput {
  result: Ban
}

type MultiBanOutput {
  results: [Ban]
  totalCount: Int
}

type BanOutput {
  data: Ban
}

input CreateBanInput {
  data: CreateBanDataInput!
}

input CreateBanDataInput {
  legacyData: JSON
  expirationDate: Date!
  userId: String
  ip: String
  reason: String
  comment: String
  properties: JSON
}

input UpdateBanInput {
  selector: BanSelectorUniqueInput!
  data: UpdateBanDataInput!
}

input UpsertBanInput {
  selector: BanSelectorUniqueInput!
  data: UpdateBanDataInput!
}

input UpdateBanDataInput {
  legacyData: JSON
  expirationDate: Date
  userId: String
  ip: String
  reason: String
  comment: String
  properties: JSON
}

input BanSelectorInput {
  AND: [BanSelectorInput]
  OR: [BanSelectorInput]
}

input BanSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum BanOrderByInput {
  foobar
}

type Book {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  postedAt: Date
  title: String
  subtitle: String
  tocTitle: String
  collectionId: String
  number: Float
  postIds: [String]
  posts: [Post!]!
  sequenceIds: [String]
  sequences: [Sequence!]!
  displaySequencesAsGrid: Boolean
  hideProgressBar: Boolean
  showChapters: Boolean
}

input DeleteBookInput {
  selector: BookSelectorUniqueInput!
}

input SingleBookInput {
  selector: BookSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiBookInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: BookSelectorInput
  orderBy: BookOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleBookOutput {
  result: Book
}

type MultiBookOutput {
  results: [Book]
  totalCount: Int
}

type BookOutput {
  data: Book
}

input CreateBookInput {
  data: CreateBookDataInput!
}

input CreateBookDataInput {
  legacyData: JSON
  contents: JSON
  title: String
  subtitle: String
  tocTitle: String
  collectionId: String!
  number: Float
  postIds: [String]
  sequenceIds: [String]
  displaySequencesAsGrid: Boolean
  hideProgressBar: Boolean
  showChapters: Boolean
}

input UpdateBookInput {
  selector: BookSelectorUniqueInput!
  data: UpdateBookDataInput!
}

input UpsertBookInput {
  selector: BookSelectorUniqueInput!
  data: UpdateBookDataInput!
}

input UpdateBookDataInput {
  legacyData: JSON
  contents: JSON
  title: String
  subtitle: String
  tocTitle: String
  collectionId: String
  number: Float
  postIds: [String]
  sequenceIds: [String]
  displaySequencesAsGrid: Boolean
  hideProgressBar: Boolean
  showChapters: Boolean
}

input BookSelectorInput {
  AND: [BookSelectorInput]
  OR: [BookSelectorInput]
}

input BookSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum BookOrderByInput {
  foobar
}

type Chapter {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  title: String
  subtitle: String
  number: Float
  sequenceId: String
  sequence: Sequence
  postIds: [String]
  posts: [Post!]!
}

input DeleteChapterInput {
  selector: ChapterSelectorUniqueInput!
}

input SingleChapterInput {
  selector: ChapterSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiChapterInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ChapterSelectorInput
  orderBy: ChapterOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleChapterOutput {
  result: Chapter
}

type MultiChapterOutput {
  results: [Chapter]
  totalCount: Int
}

type ChapterOutput {
  data: Chapter
}

input CreateChapterInput {
  data: CreateChapterDataInput!
}

input CreateChapterDataInput {
  legacyData: JSON
  contents: JSON
  title: String
  subtitle: String
  number: Float
  sequenceId: String
  postIds: [String]!
}

input UpdateChapterInput {
  selector: ChapterSelectorUniqueInput!
  data: UpdateChapterDataInput!
}

input UpsertChapterInput {
  selector: ChapterSelectorUniqueInput!
  data: UpdateChapterDataInput!
}

input UpdateChapterDataInput {
  legacyData: JSON
  contents: JSON
  title: String
  subtitle: String
  number: Float
  sequenceId: String
  postIds: [String]
}

input ChapterSelectorInput {
  AND: [ChapterSelectorInput]
  OR: [ChapterSelectorInput]
}

input ChapterSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ChapterOrderByInput {
  foobar
}

type CkEditorUserSession {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  documentId: String
  userId: String
  endedAt: Date
  endedBy: String
}

input DeleteCkEditorUserSessionInput {
  selector: CkEditorUserSessionSelectorUniqueInput!
}

input SingleCkEditorUserSessionInput {
  selector: CkEditorUserSessionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiCkEditorUserSessionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: CkEditorUserSessionSelectorInput
  orderBy: CkEditorUserSessionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCkEditorUserSessionOutput {
  result: CkEditorUserSession
}

type MultiCkEditorUserSessionOutput {
  results: [CkEditorUserSession]
  totalCount: Int
}

type CkEditorUserSessionOutput {
  data: CkEditorUserSession
}

input CreateCkEditorUserSessionInput {
  data: CreateCkEditorUserSessionDataInput!
}

input CreateCkEditorUserSessionDataInput {
  legacyData: JSON
  documentId: String!
  userId: String!
  endedAt: Date
  endedBy: String
}

input UpdateCkEditorUserSessionInput {
  selector: CkEditorUserSessionSelectorUniqueInput!
  data: UpdateCkEditorUserSessionDataInput!
}

input UpsertCkEditorUserSessionInput {
  selector: CkEditorUserSessionSelectorUniqueInput!
  data: UpdateCkEditorUserSessionDataInput!
}

input UpdateCkEditorUserSessionDataInput {
  legacyData: JSON
  documentId: String
  userId: String
  endedAt: Date
  endedBy: String
}

input CkEditorUserSessionSelectorInput {
  AND: [CkEditorUserSessionSelectorInput]
  OR: [CkEditorUserSessionSelectorInput]
}

input CkEditorUserSessionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum CkEditorUserSessionOrderByInput {
  foobar
}

type ClientId {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  clientId: String
  firstSeenReferrer: String
  firstSeenLandingPage: String
  userIds: [String]
  users: [User!]
  invalidated: Boolean
  lastSeenAt: Date
  timesSeen: Float
}

input DeleteClientIdInput {
  selector: ClientIdSelectorUniqueInput!
}

input SingleClientIdInput {
  selector: ClientIdSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiClientIdInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ClientIdSelectorInput
  orderBy: ClientIdOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleClientIdOutput {
  result: ClientId
}

type MultiClientIdOutput {
  results: [ClientId]
  totalCount: Int
}

type ClientIdOutput {
  data: ClientId
}

input CreateClientIdInput {
  data: CreateClientIdDataInput!
}

input CreateClientIdDataInput {
  legacyData: JSON
}

input UpdateClientIdInput {
  selector: ClientIdSelectorUniqueInput!
  data: UpdateClientIdDataInput!
}

input UpsertClientIdInput {
  selector: ClientIdSelectorUniqueInput!
  data: UpdateClientIdDataInput!
}

input UpdateClientIdDataInput {
  legacyData: JSON
}

input ClientIdSelectorInput {
  AND: [ClientIdSelectorInput]
  OR: [ClientIdSelectorInput]
}

input ClientIdSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ClientIdOrderByInput {
  foobar
}

type Collection {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  userId: String
  user: User
  title: String
  slug: String
  books: [Book]
  postsCount: Int!
  readPostsCount: Int!
  gridImageId: String
  firstPageLink: String
  hideStartReadingButton: Boolean
  noindex: Boolean
}

input DeleteCollectionInput {
  selector: CollectionSelectorUniqueInput!
}

input SingleCollectionInput {
  selector: CollectionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiCollectionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: CollectionSelectorInput
  orderBy: CollectionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCollectionOutput {
  result: Collection
}

type MultiCollectionOutput {
  results: [Collection]
  totalCount: Int
}

type CollectionOutput {
  data: Collection
}

input CreateCollectionInput {
  data: CreateCollectionDataInput!
}

input CreateCollectionDataInput {
  createdAt: Date
  legacyData: JSON
  contents: JSON
  title: String!
  slug: String!
  gridImageId: String
  firstPageLink: String
  hideStartReadingButton: Boolean
  noindex: Boolean
}

input UpdateCollectionInput {
  selector: CollectionSelectorUniqueInput!
  data: UpdateCollectionDataInput!
}

input UpsertCollectionInput {
  selector: CollectionSelectorUniqueInput!
  data: UpdateCollectionDataInput!
}

input UpdateCollectionDataInput {
  createdAt: Date
  legacyData: JSON
  contents: JSON
  title: String
  slug: String
  gridImageId: String
  firstPageLink: String
  hideStartReadingButton: Boolean
  noindex: Boolean
}

input CollectionSelectorInput {
  AND: [CollectionSelectorInput]
  OR: [CollectionSelectorInput]
}

input CollectionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum CollectionOrderByInput {
  foobar
}

type CommentModeratorAction {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  commentId: String
  comment: Comment
  type: String
  endedAt: Date
  active: Boolean
}

input DeleteCommentModeratorActionInput {
  selector: CommentModeratorActionSelectorUniqueInput!
}

input SingleCommentModeratorActionInput {
  selector: CommentModeratorActionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiCommentModeratorActionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: CommentModeratorActionSelectorInput
  orderBy: CommentModeratorActionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCommentModeratorActionOutput {
  result: CommentModeratorAction
}

type MultiCommentModeratorActionOutput {
  results: [CommentModeratorAction]
  totalCount: Int
}

type CommentModeratorActionOutput {
  data: CommentModeratorAction
}

input CreateCommentModeratorActionInput {
  data: CreateCommentModeratorActionDataInput!
}

input CreateCommentModeratorActionDataInput {
  legacyData: JSON
  commentId: String
  type: String!
  endedAt: Date
}

input UpdateCommentModeratorActionInput {
  selector: CommentModeratorActionSelectorUniqueInput!
  data: UpdateCommentModeratorActionDataInput!
}

input UpsertCommentModeratorActionInput {
  selector: CommentModeratorActionSelectorUniqueInput!
  data: UpdateCommentModeratorActionDataInput!
}

input UpdateCommentModeratorActionDataInput {
  legacyData: JSON
  commentId: String
  type: String
  endedAt: Date
}

input CommentModeratorActionSelectorInput {
  AND: [CommentModeratorActionSelectorInput]
  OR: [CommentModeratorActionSelectorInput]
}

input CommentModeratorActionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum CommentModeratorActionOrderByInput {
  foobar
}

type Comment {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  pingbacks: JSON
  parentCommentId: String
  parentComment: Comment
  topLevelCommentId: String
  topLevelComment: Comment
  postedAt: Date
  lastEditedAt: Date
  author: String
  postId: String
  post: Post
  tagId: String
  tag: Tag
  forumEventId: String
  forumEvent: ForumEvent
  forumEventMetadata: JSON
  tagCommentType: String
  subforumStickyPriority: Float
  userId: String
  user: User
  userIP: String
  userAgent: String
  referrer: String
  authorIsUnreviewed: Boolean
  pageUrl: String
  pageUrlRelative: String
  answer: Boolean
  parentAnswerId: String
  parentAnswer: Comment
  directChildrenCount: Float
  descendentCount: Float
  latestChildren: [Comment]
  shortform: Boolean
  shortformFrontpage: Boolean
  nominatedForReview: String
  reviewingForReview: String
  lastSubthreadActivity: Date
  postVersion: String
  promoted: Boolean
  promotedByUserId: String
  promotedByUser: User
  promotedAt: Date
  hideKarma: Boolean
  wordCount: Int
  htmlBody: String
  votingSystem: String!
  legacy: Boolean
  legacyId: String
  legacyPoll: Boolean
  legacyParentId: String
  retracted: Boolean
  deleted: Boolean
  deletedPublic: Boolean
  deletedReason: String
  deletedDate: Date
  deletedByUserId: String
  deletedByUser: User
  spam: Boolean
  repliesBlockedUntil: Date
  needsReview: Boolean
  reviewedByUserId: String
  reviewedByUser: User
  hideAuthor: Boolean
  moderatorHat: Boolean
  hideModeratorHat: Boolean
  isPinnedOnProfile: Boolean
  title: String
  relevantTagIds: [String]
  relevantTags: [Tag!]!
  debateResponse: Boolean
  rejected: Boolean
  modGPTAnalysis: String
  modGPTRecommendation: String
  rejectedReason: String
  rejectedByUserId: String
  rejectedByUser: User
  emojiReactors: JSON
  af: Boolean
  suggestForAlignmentUserIds: [String]
  suggestForAlignmentUsers: [User!]!
  reviewForAlignmentUserId: String
  afDate: Date
  moveToAlignmentUserId: String
  moveToAlignmentUser: User
  agentFoundationsId: String
  originalDialogueId: String
  originalDialogue: Post
  currentUserVote: String
  currentUserExtendedVote: JSON
  allVotes: [Vote]
  voteCount: Float
  baseScore: Float
  extendedScore: JSON
  score: Float
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input DeleteCommentInput {
  selector: CommentSelectorUniqueInput!
}

input SingleCommentInput {
  selector: CommentSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiCommentInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: CommentSelectorInput
  orderBy: CommentOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCommentOutput {
  result: Comment
}

type MultiCommentOutput {
  results: [Comment]
  totalCount: Int
}

type CommentOutput {
  data: Comment
}

input CreateCommentInput {
  data: CreateCommentDataInput!
}

input CreateCommentDataInput {
  legacyData: JSON
  contents: JSON
  parentCommentId: String
  topLevelCommentId: String
  postId: String
  tagId: String
  forumEventId: String
  forumEventMetadata: JSON
  tagCommentType: String
  subforumStickyPriority: Float
  userId: String
  authorIsUnreviewed: Boolean
  answer: Boolean
  parentAnswerId: String
  shortform: Boolean
  shortformFrontpage: Boolean
  nominatedForReview: String
  reviewingForReview: String
  promotedByUserId: String
  hideKarma: Boolean
  legacy: Boolean
  legacyId: String
  legacyPoll: Boolean
  legacyParentId: String
  retracted: Boolean
  deleted: Boolean
  deletedPublic: Boolean
  deletedReason: String
  deletedDate: Date
  deletedByUserId: String
  spam: Boolean
  needsReview: Boolean
  reviewedByUserId: String
  moderatorHat: Boolean
  hideModeratorHat: Boolean
  isPinnedOnProfile: Boolean
  title: String
  relevantTagIds: [String]
  debateResponse: Boolean
  rejected: Boolean
  modGPTAnalysis: String
  modGPTRecommendation: String
  rejectedReason: String
  rejectedByUserId: String
  af: Boolean
  afDate: Date
  agentFoundationsId: String
  originalDialogueId: String
}

input UpdateCommentInput {
  selector: CommentSelectorUniqueInput!
  data: UpdateCommentDataInput!
}

input UpsertCommentInput {
  selector: CommentSelectorUniqueInput!
  data: UpdateCommentDataInput!
}

input UpdateCommentDataInput {
  legacyData: JSON
  contents: JSON
  subforumStickyPriority: Float
  authorIsUnreviewed: Boolean
  answer: Boolean
  shortform: Boolean
  shortformFrontpage: Boolean
  nominatedForReview: String
  reviewingForReview: String
  promoted: Boolean
  promotedByUserId: String
  hideKarma: Boolean
  legacy: Boolean
  legacyId: String
  legacyPoll: Boolean
  legacyParentId: String
  retracted: Boolean
  deleted: Boolean
  deletedPublic: Boolean
  deletedReason: String
  deletedDate: Date
  deletedByUserId: String
  spam: Boolean
  repliesBlockedUntil: Date
  needsReview: Boolean
  reviewedByUserId: String
  hideAuthor: Boolean
  moderatorHat: Boolean
  hideModeratorHat: Boolean
  isPinnedOnProfile: Boolean
  title: String
  relevantTagIds: [String]
  debateResponse: Boolean
  rejected: Boolean
  modGPTAnalysis: String
  modGPTRecommendation: String
  rejectedReason: String
  rejectedByUserId: String
  af: Boolean
  suggestForAlignmentUserIds: [String]
  reviewForAlignmentUserId: String
  afDate: Date
  moveToAlignmentUserId: String
  agentFoundationsId: String
  originalDialogueId: String
}

input CommentSelectorInput {
  AND: [CommentSelectorInput]
  OR: [CommentSelectorInput]
}

input CommentSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum CommentOrderByInput {
  foobar
}

type Conversation {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  title: String
  participantIds: [String]
  participants: [User!]
  latestActivity: Date
  af: Boolean
  messageCount: Float
  moderator: Boolean
  archivedByIds: [String]
  archivedBy: [User!]!
  latestMessage: Message
  hasUnreadMessages: Boolean
}

input DeleteConversationInput {
  selector: ConversationSelectorUniqueInput!
}

input SingleConversationInput {
  selector: ConversationSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiConversationInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ConversationSelectorInput
  orderBy: ConversationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleConversationOutput {
  result: Conversation
}

type MultiConversationOutput {
  results: [Conversation]
  totalCount: Int
}

type ConversationOutput {
  data: Conversation
}

input CreateConversationInput {
  data: CreateConversationDataInput!
}

input CreateConversationDataInput {
  legacyData: JSON
  title: String
  participantIds: [String]
  af: Boolean
  moderator: Boolean
  archivedByIds: [String]
}

input UpdateConversationInput {
  selector: ConversationSelectorUniqueInput!
  data: UpdateConversationDataInput!
}

input UpsertConversationInput {
  selector: ConversationSelectorUniqueInput!
  data: UpdateConversationDataInput!
}

input UpdateConversationDataInput {
  legacyData: JSON
  title: String
  participantIds: [String]
  af: Boolean
  moderator: Boolean
  archivedByIds: [String]
}

input ConversationSelectorInput {
  AND: [ConversationSelectorInput]
  OR: [ConversationSelectorInput]
}

input ConversationSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ConversationOrderByInput {
  foobar
}

type CronHistory {
  _id: String
  intendedAt: Date
  name: String
  startedAt: Date
  finishedAt: Date
  result: JSON
}

input DeleteCronHistoryInput {
  selector: CronHistorySelectorUniqueInput!
}

input SingleCronHistoryInput {
  selector: CronHistorySelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiCronHistoryInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: CronHistorySelectorInput
  orderBy: CronHistoryOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCronHistoryOutput {
  result: CronHistory
}

type MultiCronHistoryOutput {
  results: [CronHistory]
  totalCount: Int
}

type CronHistoryOutput {
  data: CronHistory
}

input CreateCronHistoryInput {
  data: CreateCronHistoryDataInput!
}

input CreateCronHistoryDataInput {
  _id: String!
  intendedAt: Date!
  name: String!
  startedAt: Date!
  finishedAt: Date
  result: JSON
}

input UpdateCronHistoryInput {
  selector: CronHistorySelectorUniqueInput!
  data: UpdateCronHistoryDataInput!
}

input UpsertCronHistoryInput {
  selector: CronHistorySelectorUniqueInput!
  data: UpdateCronHistoryDataInput!
}

input UpdateCronHistoryDataInput {
  _id: String
  intendedAt: Date
  name: String
  startedAt: Date
  finishedAt: Date
  result: JSON
}

input CronHistorySelectorInput {
  AND: [CronHistorySelectorInput]
  OR: [CronHistorySelectorInput]
}

input CronHistorySelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum CronHistoryOrderByInput {
  foobar
}

type CurationEmail {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  postId: String
}

input DeleteCurationEmailInput {
  selector: CurationEmailSelectorUniqueInput!
}

input SingleCurationEmailInput {
  selector: CurationEmailSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiCurationEmailInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: CurationEmailSelectorInput
  orderBy: CurationEmailOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCurationEmailOutput {
  result: CurationEmail
}

type MultiCurationEmailOutput {
  results: [CurationEmail]
  totalCount: Int
}

type CurationEmailOutput {
  data: CurationEmail
}

input CreateCurationEmailInput {
  data: CreateCurationEmailDataInput!
}

input CreateCurationEmailDataInput {
  legacyData: JSON
  userId: String!
  postId: String!
}

input UpdateCurationEmailInput {
  selector: CurationEmailSelectorUniqueInput!
  data: UpdateCurationEmailDataInput!
}

input UpsertCurationEmailInput {
  selector: CurationEmailSelectorUniqueInput!
  data: UpdateCurationEmailDataInput!
}

input UpdateCurationEmailDataInput {
  legacyData: JSON
  userId: String
  postId: String
}

input CurationEmailSelectorInput {
  AND: [CurationEmailSelectorInput]
  OR: [CurationEmailSelectorInput]
}

input CurationEmailSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum CurationEmailOrderByInput {
  foobar
}

type CurationNotice {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  userId: String
  user: User
  commentId: String
  comment: Comment
  postId: String
  post: Post
  deleted: Boolean
}

input DeleteCurationNoticeInput {
  selector: CurationNoticeSelectorUniqueInput!
}

input SingleCurationNoticeInput {
  selector: CurationNoticeSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiCurationNoticeInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: CurationNoticeSelectorInput
  orderBy: CurationNoticeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCurationNoticeOutput {
  result: CurationNotice
}

type MultiCurationNoticeOutput {
  results: [CurationNotice]
  totalCount: Int
}

type CurationNoticeOutput {
  data: CurationNotice
}

input CreateCurationNoticeInput {
  data: CreateCurationNoticeDataInput!
}

input CreateCurationNoticeDataInput {
  legacyData: JSON
  contents: JSON
  userId: String!
  commentId: String
  postId: String!
}

input UpdateCurationNoticeInput {
  selector: CurationNoticeSelectorUniqueInput!
  data: UpdateCurationNoticeDataInput!
}

input UpsertCurationNoticeInput {
  selector: CurationNoticeSelectorUniqueInput!
  data: UpdateCurationNoticeDataInput!
}

input UpdateCurationNoticeDataInput {
  legacyData: JSON
  contents: JSON
  commentId: String
  deleted: Boolean
}

input CurationNoticeSelectorInput {
  AND: [CurationNoticeSelectorInput]
  OR: [CurationNoticeSelectorInput]
}

input CurationNoticeSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum CurationNoticeOrderByInput {
  foobar
}

type DatabaseMetadata {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteDatabaseMetadataInput {
  selector: DatabaseMetadataSelectorUniqueInput!
}

input SingleDatabaseMetadataInput {
  selector: DatabaseMetadataSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiDatabaseMetadataInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: DatabaseMetadataSelectorInput
  orderBy: DatabaseMetadataOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDatabaseMetadataOutput {
  result: DatabaseMetadata
}

type MultiDatabaseMetadataOutput {
  results: [DatabaseMetadata]
  totalCount: Int
}

type DatabaseMetadataOutput {
  data: DatabaseMetadata
}

input CreateDatabaseMetadataInput {
  data: CreateDatabaseMetadataDataInput!
}

input CreateDatabaseMetadataDataInput {
  legacyData: JSON
}

input UpdateDatabaseMetadataInput {
  selector: DatabaseMetadataSelectorUniqueInput!
  data: UpdateDatabaseMetadataDataInput!
}

input UpsertDatabaseMetadataInput {
  selector: DatabaseMetadataSelectorUniqueInput!
  data: UpdateDatabaseMetadataDataInput!
}

input UpdateDatabaseMetadataDataInput {
  legacyData: JSON
}

input DatabaseMetadataSelectorInput {
  AND: [DatabaseMetadataSelectorInput]
  OR: [DatabaseMetadataSelectorInput]
}

input DatabaseMetadataSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum DatabaseMetadataOrderByInput {
  foobar
}

type DebouncerEvents {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteDebouncerEventsInput {
  selector: DebouncerEventsSelectorUniqueInput!
}

input SingleDebouncerEventsInput {
  selector: DebouncerEventsSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiDebouncerEventsInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: DebouncerEventsSelectorInput
  orderBy: DebouncerEventsOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDebouncerEventsOutput {
  result: DebouncerEvents
}

type MultiDebouncerEventsOutput {
  results: [DebouncerEvents]
  totalCount: Int
}

type DebouncerEventsOutput {
  data: DebouncerEvents
}

input CreateDebouncerEventsInput {
  data: CreateDebouncerEventsDataInput!
}

input CreateDebouncerEventsDataInput {
  legacyData: JSON
}

input UpdateDebouncerEventsInput {
  selector: DebouncerEventsSelectorUniqueInput!
  data: UpdateDebouncerEventsDataInput!
}

input UpsertDebouncerEventsInput {
  selector: DebouncerEventsSelectorUniqueInput!
  data: UpdateDebouncerEventsDataInput!
}

input UpdateDebouncerEventsDataInput {
  legacyData: JSON
}

input DebouncerEventsSelectorInput {
  AND: [DebouncerEventsSelectorInput]
  OR: [DebouncerEventsSelectorInput]
}

input DebouncerEventsSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum DebouncerEventsOrderByInput {
  foobar
}

type DialogueCheck {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  targetUserId: String
  checked: Boolean
  checkedAt: Date
  hideInRecommendations: Boolean
  matchPreference: DialogueMatchPreference
  reciprocalMatchPreference: DialogueMatchPreference
}

input DeleteDialogueCheckInput {
  selector: DialogueCheckSelectorUniqueInput!
}

input SingleDialogueCheckInput {
  selector: DialogueCheckSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiDialogueCheckInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: DialogueCheckSelectorInput
  orderBy: DialogueCheckOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDialogueCheckOutput {
  result: DialogueCheck
}

type MultiDialogueCheckOutput {
  results: [DialogueCheck]
  totalCount: Int
}

type DialogueCheckOutput {
  data: DialogueCheck
}

input CreateDialogueCheckInput {
  data: CreateDialogueCheckDataInput!
}

input CreateDialogueCheckDataInput {
  legacyData: JSON
  userId: String!
  targetUserId: String!
  checked: Boolean!
  checkedAt: Date!
  hideInRecommendations: Boolean!
}

input UpdateDialogueCheckInput {
  selector: DialogueCheckSelectorUniqueInput!
  data: UpdateDialogueCheckDataInput!
}

input UpsertDialogueCheckInput {
  selector: DialogueCheckSelectorUniqueInput!
  data: UpdateDialogueCheckDataInput!
}

input UpdateDialogueCheckDataInput {
  legacyData: JSON
}

input DialogueCheckSelectorInput {
  AND: [DialogueCheckSelectorInput]
  OR: [DialogueCheckSelectorInput]
}

input DialogueCheckSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum DialogueCheckOrderByInput {
  foobar
}

type DialogueMatchPreference {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  dialogueCheckId: String
  dialogueCheck: DialogueCheck
  topicPreferences: [JSON]
  topicNotes: String
  syncPreference: String
  asyncPreference: String
  formatNotes: String
  calendlyLink: String
  generatedDialogueId: String
  deleted: Boolean
}

input DeleteDialogueMatchPreferenceInput {
  selector: DialogueMatchPreferenceSelectorUniqueInput!
}

input SingleDialogueMatchPreferenceInput {
  selector: DialogueMatchPreferenceSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiDialogueMatchPreferenceInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: DialogueMatchPreferenceSelectorInput
  orderBy: DialogueMatchPreferenceOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDialogueMatchPreferenceOutput {
  result: DialogueMatchPreference
}

type MultiDialogueMatchPreferenceOutput {
  results: [DialogueMatchPreference]
  totalCount: Int
}

type DialogueMatchPreferenceOutput {
  data: DialogueMatchPreference
}

input CreateDialogueMatchPreferenceInput {
  data: CreateDialogueMatchPreferenceDataInput!
}

input CreateDialogueMatchPreferenceDataInput {
  legacyData: JSON
  dialogueCheckId: String!
  topicPreferences: [JSON]!
  topicNotes: String!
  syncPreference: String!
  asyncPreference: String!
  formatNotes: String!
  calendlyLink: String
  generatedDialogueId: String
  deleted: Boolean
}

input UpdateDialogueMatchPreferenceInput {
  selector: DialogueMatchPreferenceSelectorUniqueInput!
  data: UpdateDialogueMatchPreferenceDataInput!
}

input UpsertDialogueMatchPreferenceInput {
  selector: DialogueMatchPreferenceSelectorUniqueInput!
  data: UpdateDialogueMatchPreferenceDataInput!
}

input UpdateDialogueMatchPreferenceDataInput {
  legacyData: JSON
  dialogueCheckId: String
  topicPreferences: [JSON]
  topicNotes: String
  syncPreference: String
  asyncPreference: String
  formatNotes: String
  calendlyLink: String
  generatedDialogueId: String
  deleted: Boolean
}

input DialogueMatchPreferenceSelectorInput {
  AND: [DialogueMatchPreferenceSelectorInput]
  OR: [DialogueMatchPreferenceSelectorInput]
}

input DialogueMatchPreferenceSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum DialogueMatchPreferenceOrderByInput {
  foobar
}

type DigestPost {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  digestId: String
  digest: Digest!
  postId: String
  post: Post
  emailDigestStatus: String
  onsiteDigestStatus: String
}

input DeleteDigestPostInput {
  selector: DigestPostSelectorUniqueInput!
}

input SingleDigestPostInput {
  selector: DigestPostSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiDigestPostInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: DigestPostSelectorInput
  orderBy: DigestPostOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDigestPostOutput {
  result: DigestPost
}

type MultiDigestPostOutput {
  results: [DigestPost]
  totalCount: Int
}

type DigestPostOutput {
  data: DigestPost
}

input CreateDigestPostInput {
  data: CreateDigestPostDataInput!
}

input CreateDigestPostDataInput {
  legacyData: JSON
  digestId: String!
  postId: String!
  emailDigestStatus: String
  onsiteDigestStatus: String
}

input UpdateDigestPostInput {
  selector: DigestPostSelectorUniqueInput!
  data: UpdateDigestPostDataInput!
}

input UpsertDigestPostInput {
  selector: DigestPostSelectorUniqueInput!
  data: UpdateDigestPostDataInput!
}

input UpdateDigestPostDataInput {
  legacyData: JSON
  digestId: String
  postId: String
  emailDigestStatus: String
  onsiteDigestStatus: String
}

input DigestPostSelectorInput {
  AND: [DigestPostSelectorInput]
  OR: [DigestPostSelectorInput]
}

input DigestPostSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum DigestPostOrderByInput {
  foobar
}

type Digest {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  num: Float
  startDate: Date
  endDate: Date
  publishedDate: Date
  onsiteImageId: String
  onsitePrimaryColor: String
}

input DeleteDigestInput {
  selector: DigestSelectorUniqueInput!
}

input SingleDigestInput {
  selector: DigestSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiDigestInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: DigestSelectorInput
  orderBy: DigestOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleDigestOutput {
  result: Digest
}

type MultiDigestOutput {
  results: [Digest]
  totalCount: Int
}

type DigestOutput {
  data: Digest
}

input CreateDigestInput {
  data: CreateDigestDataInput!
}

input CreateDigestDataInput {
  legacyData: JSON
  num: Float!
  startDate: Date!
  endDate: Date
  publishedDate: Date
  onsiteImageId: String
  onsitePrimaryColor: String
}

input UpdateDigestInput {
  selector: DigestSelectorUniqueInput!
  data: UpdateDigestDataInput!
}

input UpsertDigestInput {
  selector: DigestSelectorUniqueInput!
  data: UpdateDigestDataInput!
}

input UpdateDigestDataInput {
  legacyData: JSON
  num: Float
  startDate: Date
  endDate: Date
  publishedDate: Date
  onsiteImageId: String
  onsitePrimaryColor: String
}

input DigestSelectorInput {
  AND: [DigestSelectorInput]
  OR: [DigestSelectorInput]
}

input DigestSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum DigestOrderByInput {
  foobar
}

type ElectionCandidate {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  electionName: String
  name: String
  logoSrc: String
  href: String
  fundraiserLink: String
  gwwcLink: String
  gwwcId: String
  description: String
  userId: String
  user: User
  postCount: Float
  tagId: String
  tag: Tag
  isElectionFundraiser: Boolean
  amountRaised: Float
  targetAmount: Float
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float
  baseScore: Float
  extendedScore: JSON
  score: Float
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input DeleteElectionCandidateInput {
  selector: ElectionCandidateSelectorUniqueInput!
}

input SingleElectionCandidateInput {
  selector: ElectionCandidateSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiElectionCandidateInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ElectionCandidateSelectorInput
  orderBy: ElectionCandidateOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleElectionCandidateOutput {
  result: ElectionCandidate
}

type MultiElectionCandidateOutput {
  results: [ElectionCandidate]
  totalCount: Int
}

type ElectionCandidateOutput {
  data: ElectionCandidate
}

input CreateElectionCandidateInput {
  data: CreateElectionCandidateDataInput!
}

input CreateElectionCandidateDataInput {
  legacyData: JSON
  electionName: String!
  name: String!
  logoSrc: String!
  href: String!
  fundraiserLink: String
  gwwcLink: String
  gwwcId: String
  description: String!
  userId: String
  tagId: String!
  isElectionFundraiser: Boolean
  amountRaised: Float
  targetAmount: Float
}

input UpdateElectionCandidateInput {
  selector: ElectionCandidateSelectorUniqueInput!
  data: UpdateElectionCandidateDataInput!
}

input UpsertElectionCandidateInput {
  selector: ElectionCandidateSelectorUniqueInput!
  data: UpdateElectionCandidateDataInput!
}

input UpdateElectionCandidateDataInput {
  legacyData: JSON
  electionName: String
  name: String
  logoSrc: String
  href: String
  fundraiserLink: String
  gwwcLink: String
  gwwcId: String
  description: String
  userId: String
  tagId: String
  isElectionFundraiser: Boolean
  amountRaised: Float
  targetAmount: Float
}

input ElectionCandidateSelectorInput {
  AND: [ElectionCandidateSelectorInput]
  OR: [ElectionCandidateSelectorInput]
}

input ElectionCandidateSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ElectionCandidateOrderByInput {
  foobar
}

type ElectionVote {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  electionName: String
  userId: String
  user: User
  compareState: JSON
  vote: JSON
  submittedAt: Date
  submissionComments: JSON
  userExplanation: String
  userOtherComments: String
}

input DeleteElectionVoteInput {
  selector: ElectionVoteSelectorUniqueInput!
}

input SingleElectionVoteInput {
  selector: ElectionVoteSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiElectionVoteInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ElectionVoteSelectorInput
  orderBy: ElectionVoteOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleElectionVoteOutput {
  result: ElectionVote
}

type MultiElectionVoteOutput {
  results: [ElectionVote]
  totalCount: Int
}

type ElectionVoteOutput {
  data: ElectionVote
}

input CreateElectionVoteInput {
  data: CreateElectionVoteDataInput!
}

input CreateElectionVoteDataInput {
  legacyData: JSON
  electionName: String!
  userId: String!
  compareState: JSON
  vote: JSON
  submittedAt: Date
  submissionComments: JSON
  userExplanation: String
  userOtherComments: String
}

input UpdateElectionVoteInput {
  selector: ElectionVoteSelectorUniqueInput!
  data: UpdateElectionVoteDataInput!
}

input UpsertElectionVoteInput {
  selector: ElectionVoteSelectorUniqueInput!
  data: UpdateElectionVoteDataInput!
}

input UpdateElectionVoteDataInput {
  legacyData: JSON
  electionName: String
  userId: String
  compareState: JSON
  vote: JSON
  submittedAt: Date
  submissionComments: JSON
  userExplanation: String
  userOtherComments: String
}

input ElectionVoteSelectorInput {
  AND: [ElectionVoteSelectorInput]
  OR: [ElectionVoteSelectorInput]
}

input ElectionVoteSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ElectionVoteOrderByInput {
  foobar
}

type ElicitQuestionPrediction {
  _id: String
  predictionId: String
  prediction: Float
  createdAt: Date
  notes: String
  creator: JSON
  userId: String
  user: User
  sourceUrl: String
  sourceId: String
  binaryQuestionId: String
  question: ElicitQuestion!
  isDeleted: Boolean
}

input DeleteElicitQuestionPredictionInput {
  selector: ElicitQuestionPredictionSelectorUniqueInput!
}

input SingleElicitQuestionPredictionInput {
  selector: ElicitQuestionPredictionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiElicitQuestionPredictionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ElicitQuestionPredictionSelectorInput
  orderBy: ElicitQuestionPredictionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleElicitQuestionPredictionOutput {
  result: ElicitQuestionPrediction
}

type MultiElicitQuestionPredictionOutput {
  results: [ElicitQuestionPrediction]
  totalCount: Int
}

type ElicitQuestionPredictionOutput {
  data: ElicitQuestionPrediction
}

input CreateElicitQuestionPredictionInput {
  data: CreateElicitQuestionPredictionDataInput!
}

input CreateElicitQuestionPredictionDataInput {
  _id: String!
  prediction: Float
  createdAt: Date!
  notes: String
  creator: JSON!
  userId: String
  sourceUrl: String
  sourceId: String
  binaryQuestionId: String!
  isDeleted: Boolean!
}

input UpdateElicitQuestionPredictionInput {
  selector: ElicitQuestionPredictionSelectorUniqueInput!
  data: UpdateElicitQuestionPredictionDataInput!
}

input UpsertElicitQuestionPredictionInput {
  selector: ElicitQuestionPredictionSelectorUniqueInput!
  data: UpdateElicitQuestionPredictionDataInput!
}

input UpdateElicitQuestionPredictionDataInput {
  _id: String
  prediction: Float
  createdAt: Date
  notes: String
  creator: JSON
  userId: String
  sourceUrl: String
  sourceId: String
  binaryQuestionId: String
  isDeleted: Boolean
}

input ElicitQuestionPredictionSelectorInput {
  AND: [ElicitQuestionPredictionSelectorInput]
  OR: [ElicitQuestionPredictionSelectorInput]
}

input ElicitQuestionPredictionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ElicitQuestionPredictionOrderByInput {
  foobar
}

type ElicitQuestion {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  title: String
  notes: String
  resolution: String
  resolvesBy: Date
}

input DeleteElicitQuestionInput {
  selector: ElicitQuestionSelectorUniqueInput!
}

input SingleElicitQuestionInput {
  selector: ElicitQuestionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiElicitQuestionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ElicitQuestionSelectorInput
  orderBy: ElicitQuestionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleElicitQuestionOutput {
  result: ElicitQuestion
}

type MultiElicitQuestionOutput {
  results: [ElicitQuestion]
  totalCount: Int
}

type ElicitQuestionOutput {
  data: ElicitQuestion
}

input CreateElicitQuestionInput {
  data: CreateElicitQuestionDataInput!
}

input CreateElicitQuestionDataInput {
  legacyData: JSON
  title: String!
  notes: String
  resolution: String
  resolvesBy: Date
}

input UpdateElicitQuestionInput {
  selector: ElicitQuestionSelectorUniqueInput!
  data: UpdateElicitQuestionDataInput!
}

input UpsertElicitQuestionInput {
  selector: ElicitQuestionSelectorUniqueInput!
  data: UpdateElicitQuestionDataInput!
}

input UpdateElicitQuestionDataInput {
  legacyData: JSON
  title: String
  notes: String
  resolution: String
  resolvesBy: Date
}

input ElicitQuestionSelectorInput {
  AND: [ElicitQuestionSelectorInput]
  OR: [ElicitQuestionSelectorInput]
}

input ElicitQuestionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ElicitQuestionOrderByInput {
  foobar
}

type EmailTokens {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteEmailTokensInput {
  selector: EmailTokensSelectorUniqueInput!
}

input SingleEmailTokensInput {
  selector: EmailTokensSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiEmailTokensInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: EmailTokensSelectorInput
  orderBy: EmailTokensOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleEmailTokensOutput {
  result: EmailTokens
}

type MultiEmailTokensOutput {
  results: [EmailTokens]
  totalCount: Int
}

type EmailTokensOutput {
  data: EmailTokens
}

input CreateEmailTokensInput {
  data: CreateEmailTokensDataInput!
}

input CreateEmailTokensDataInput {
  legacyData: JSON
}

input UpdateEmailTokensInput {
  selector: EmailTokensSelectorUniqueInput!
  data: UpdateEmailTokensDataInput!
}

input UpsertEmailTokensInput {
  selector: EmailTokensSelectorUniqueInput!
  data: UpdateEmailTokensDataInput!
}

input UpdateEmailTokensDataInput {
  legacyData: JSON
}

input EmailTokensSelectorInput {
  AND: [EmailTokensSelectorInput]
  OR: [EmailTokensSelectorInput]
}

input EmailTokensSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum EmailTokensOrderByInput {
  foobar
}

type FeaturedResource {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  title: String
  body: String
  ctaText: String
  ctaUrl: String
  expiresAt: Date
}

input DeleteFeaturedResourceInput {
  selector: FeaturedResourceSelectorUniqueInput!
}

input SingleFeaturedResourceInput {
  selector: FeaturedResourceSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiFeaturedResourceInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: FeaturedResourceSelectorInput
  orderBy: FeaturedResourceOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleFeaturedResourceOutput {
  result: FeaturedResource
}

type MultiFeaturedResourceOutput {
  results: [FeaturedResource]
  totalCount: Int
}

type FeaturedResourceOutput {
  data: FeaturedResource
}

input CreateFeaturedResourceInput {
  data: CreateFeaturedResourceDataInput!
}

input CreateFeaturedResourceDataInput {
  legacyData: JSON
  title: String!
  body: String!
  ctaText: String!
  ctaUrl: String!
  expiresAt: Date
}

input UpdateFeaturedResourceInput {
  selector: FeaturedResourceSelectorUniqueInput!
  data: UpdateFeaturedResourceDataInput!
}

input UpsertFeaturedResourceInput {
  selector: FeaturedResourceSelectorUniqueInput!
  data: UpdateFeaturedResourceDataInput!
}

input UpdateFeaturedResourceDataInput {
  legacyData: JSON
  title: String
  body: String
  ctaText: String
  ctaUrl: String
  expiresAt: Date
}

input FeaturedResourceSelectorInput {
  AND: [FeaturedResourceSelectorInput]
  OR: [FeaturedResourceSelectorInput]
}

input FeaturedResourceSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum FeaturedResourceOrderByInput {
  foobar
}

type FieldChange {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  changeGroup: String
  documentId: String
  fieldName: String
  oldValue: JSON
  newValue: JSON
}

input DeleteFieldChangeInput {
  selector: FieldChangeSelectorUniqueInput!
}

input SingleFieldChangeInput {
  selector: FieldChangeSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiFieldChangeInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: FieldChangeSelectorInput
  orderBy: FieldChangeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleFieldChangeOutput {
  result: FieldChange
}

type MultiFieldChangeOutput {
  results: [FieldChange]
  totalCount: Int
}

type FieldChangeOutput {
  data: FieldChange
}

input CreateFieldChangeInput {
  data: CreateFieldChangeDataInput!
}

input CreateFieldChangeDataInput {
  legacyData: JSON
}

input UpdateFieldChangeInput {
  selector: FieldChangeSelectorUniqueInput!
  data: UpdateFieldChangeDataInput!
}

input UpsertFieldChangeInput {
  selector: FieldChangeSelectorUniqueInput!
  data: UpdateFieldChangeDataInput!
}

input UpdateFieldChangeDataInput {
  legacyData: JSON
}

input FieldChangeSelectorInput {
  AND: [FieldChangeSelectorInput]
  OR: [FieldChangeSelectorInput]
}

input FieldChangeSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum FieldChangeOrderByInput {
  foobar
}

type ForumEvent {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  frontpageDescription(version: String): Revision
  frontpageDescription_latest: String
  frontpageDescriptionMobile(version: String): Revision
  frontpageDescriptionMobile_latest: String
  postPageDescription(version: String): Revision
  postPageDescription_latest: String
  title: String
  startDate: Date
  endDate: Date
  darkColor: String
  lightColor: String
  bannerTextColor: String
  contrastColor: String
  tagId: String
  tag: Tag
  postId: String
  post: Post
  bannerImageId: String
  includesPoll: Boolean
  eventFormat: String
  pollQuestion(version: String): Revision
  pollQuestion_latest: String
  pollAgreeWording: String
  pollDisagreeWording: String
  maxStickersPerUser: Float
  customComponent: String
  commentPrompt: String
  publicData: JSON
  voteCount: Int!
}

input DeleteForumEventInput {
  selector: ForumEventSelectorUniqueInput!
}

input SingleForumEventInput {
  selector: ForumEventSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiForumEventInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ForumEventSelectorInput
  orderBy: ForumEventOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleForumEventOutput {
  result: ForumEvent
}

type MultiForumEventOutput {
  results: [ForumEvent]
  totalCount: Int
}

type ForumEventOutput {
  data: ForumEvent
}

input CreateForumEventInput {
  data: CreateForumEventDataInput!
}

input CreateForumEventDataInput {
  legacyData: JSON
  frontpageDescription: JSON
  frontpageDescriptionMobile: JSON
  postPageDescription: JSON
  title: String!
  startDate: Date!
  endDate: Date!
  darkColor: String!
  lightColor: String!
  bannerTextColor: String!
  contrastColor: String
  tagId: String
  postId: String
  bannerImageId: String
  includesPoll: Boolean
  eventFormat: String
  pollQuestion: JSON
  pollAgreeWording: String
  pollDisagreeWording: String
  maxStickersPerUser: Float
  customComponent: String
  commentPrompt: String
  publicData: JSON
}

input UpdateForumEventInput {
  selector: ForumEventSelectorUniqueInput!
  data: UpdateForumEventDataInput!
}

input UpsertForumEventInput {
  selector: ForumEventSelectorUniqueInput!
  data: UpdateForumEventDataInput!
}

input UpdateForumEventDataInput {
  legacyData: JSON
  frontpageDescription: JSON
  frontpageDescriptionMobile: JSON
  postPageDescription: JSON
  title: String
  startDate: Date
  endDate: Date
  darkColor: String
  lightColor: String
  bannerTextColor: String
  contrastColor: String
  tagId: String
  postId: String
  bannerImageId: String
  includesPoll: Boolean
  eventFormat: String
  pollQuestion: JSON
  pollAgreeWording: String
  pollDisagreeWording: String
  maxStickersPerUser: Float
  customComponent: String
  commentPrompt: String
}

input ForumEventSelectorInput {
  AND: [ForumEventSelectorInput]
  OR: [ForumEventSelectorInput]
}

input ForumEventSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ForumEventOrderByInput {
  foobar
}

type GardenCode {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  pingbacks: JSON
  slug: String
  code: String
  title: String
  userId: String
  user: User
  startTime: Date
  endTime: Date
  fbLink: String
  type: String
  hidden: Boolean
  deleted: Boolean
  afOnly: Boolean
}

input DeleteGardenCodeInput {
  selector: GardenCodeSelectorUniqueInput!
}

input SingleGardenCodeInput {
  selector: GardenCodeSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiGardenCodeInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: GardenCodeSelectorInput
  orderBy: GardenCodeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleGardenCodeOutput {
  result: GardenCode
}

type MultiGardenCodeOutput {
  results: [GardenCode]
  totalCount: Int
}

type GardenCodeOutput {
  data: GardenCode
}

input CreateGardenCodeInput {
  data: CreateGardenCodeDataInput!
}

input CreateGardenCodeDataInput {
  legacyData: JSON
  contents: JSON
  title: String!
  startTime: Date
  fbLink: String
  type: String
  afOnly: Boolean
}

input UpdateGardenCodeInput {
  selector: GardenCodeSelectorUniqueInput!
  data: UpdateGardenCodeDataInput!
}

input UpsertGardenCodeInput {
  selector: GardenCodeSelectorUniqueInput!
  data: UpdateGardenCodeDataInput!
}

input UpdateGardenCodeDataInput {
  legacyData: JSON
  contents: JSON
  title: String
  startTime: Date
  endTime: Date
  fbLink: String
  type: String
  hidden: Boolean
  deleted: Boolean
  afOnly: Boolean
}

input GardenCodeSelectorInput {
  AND: [GardenCodeSelectorInput]
  OR: [GardenCodeSelectorInput]
}

input GardenCodeSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum GardenCodeOrderByInput {
  foobar
}

type GoogleServiceAccountSession {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  email: String
  refreshToken: String
  estimatedExpiry: Date
  active: Boolean
  revoked: Boolean
}

input DeleteGoogleServiceAccountSessionInput {
  selector: GoogleServiceAccountSessionSelectorUniqueInput!
}

input SingleGoogleServiceAccountSessionInput {
  selector: GoogleServiceAccountSessionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiGoogleServiceAccountSessionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: GoogleServiceAccountSessionSelectorInput
  orderBy: GoogleServiceAccountSessionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleGoogleServiceAccountSessionOutput {
  result: GoogleServiceAccountSession
}

type MultiGoogleServiceAccountSessionOutput {
  results: [GoogleServiceAccountSession]
  totalCount: Int
}

type GoogleServiceAccountSessionOutput {
  data: GoogleServiceAccountSession
}

input CreateGoogleServiceAccountSessionInput {
  data: CreateGoogleServiceAccountSessionDataInput!
}

input CreateGoogleServiceAccountSessionDataInput {
  legacyData: JSON
  email: String!
  refreshToken: String!
  estimatedExpiry: Date!
  active: Boolean!
  revoked: Boolean!
}

input UpdateGoogleServiceAccountSessionInput {
  selector: GoogleServiceAccountSessionSelectorUniqueInput!
  data: UpdateGoogleServiceAccountSessionDataInput!
}

input UpsertGoogleServiceAccountSessionInput {
  selector: GoogleServiceAccountSessionSelectorUniqueInput!
  data: UpdateGoogleServiceAccountSessionDataInput!
}

input UpdateGoogleServiceAccountSessionDataInput {
  legacyData: JSON
  email: String
  refreshToken: String
  estimatedExpiry: Date
  active: Boolean
  revoked: Boolean
}

input GoogleServiceAccountSessionSelectorInput {
  AND: [GoogleServiceAccountSessionSelectorInput]
  OR: [GoogleServiceAccountSessionSelectorInput]
}

input GoogleServiceAccountSessionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum GoogleServiceAccountSessionOrderByInput {
  foobar
}

type Images {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteImagesInput {
  selector: ImagesSelectorUniqueInput!
}

input SingleImagesInput {
  selector: ImagesSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiImagesInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ImagesSelectorInput
  orderBy: ImagesOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleImagesOutput {
  result: Images
}

type MultiImagesOutput {
  results: [Images]
  totalCount: Int
}

type ImagesOutput {
  data: Images
}

input CreateImagesInput {
  data: CreateImagesDataInput!
}

input CreateImagesDataInput {
  legacyData: JSON
}

input UpdateImagesInput {
  selector: ImagesSelectorUniqueInput!
  data: UpdateImagesDataInput!
}

input UpsertImagesInput {
  selector: ImagesSelectorUniqueInput!
  data: UpdateImagesDataInput!
}

input UpdateImagesDataInput {
  legacyData: JSON
}

input ImagesSelectorInput {
  AND: [ImagesSelectorInput]
  OR: [ImagesSelectorInput]
}

input ImagesSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ImagesOrderByInput {
  foobar
}

type JargonTerm {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  postId: String
  post: Post
  term: String
  humansAndOrAIEdited: String
  approved: Boolean
  deleted: Boolean
  altTerms: [String]
}

input DeleteJargonTermInput {
  selector: JargonTermSelectorUniqueInput!
}

input SingleJargonTermInput {
  selector: JargonTermSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiJargonTermInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: JargonTermSelectorInput
  orderBy: JargonTermOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleJargonTermOutput {
  result: JargonTerm
}

type MultiJargonTermOutput {
  results: [JargonTerm]
  totalCount: Int
}

type JargonTermOutput {
  data: JargonTerm
}

input CreateJargonTermInput {
  data: CreateJargonTermDataInput!
}

input CreateJargonTermDataInput {
  legacyData: JSON
  contents: JSON
  postId: String!
  term: String!
  approved: Boolean
  deleted: Boolean
  altTerms: [String]!
}

input UpdateJargonTermInput {
  selector: JargonTermSelectorUniqueInput!
  data: UpdateJargonTermDataInput!
}

input UpsertJargonTermInput {
  selector: JargonTermSelectorUniqueInput!
  data: UpdateJargonTermDataInput!
}

input UpdateJargonTermDataInput {
  legacyData: JSON
  contents: JSON
  term: String
  approved: Boolean
  deleted: Boolean
  altTerms: [String]
}

input JargonTermSelectorInput {
  AND: [JargonTermSelectorInput]
  OR: [JargonTermSelectorInput]
}

input JargonTermSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum JargonTermOrderByInput {
  foobar
}

type LWEvent {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  name: String
  documentId: String
  important: Boolean
  properties: JSON
  intercom: Boolean
}

input DeleteLWEventInput {
  selector: LWEventSelectorUniqueInput!
}

input SingleLWEventInput {
  selector: LWEventSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiLWEventInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: LWEventSelectorInput
  orderBy: LWEventOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLWEventOutput {
  result: LWEvent
}

type MultiLWEventOutput {
  results: [LWEvent]
  totalCount: Int
}

type LWEventOutput {
  data: LWEvent
}

input CreateLWEventInput {
  data: CreateLWEventDataInput!
}

input CreateLWEventDataInput {
  legacyData: JSON
  userId: String
  name: String!
  documentId: String
  important: Boolean
  properties: JSON
  intercom: Boolean
}

input UpdateLWEventInput {
  selector: LWEventSelectorUniqueInput!
  data: UpdateLWEventDataInput!
}

input UpsertLWEventInput {
  selector: LWEventSelectorUniqueInput!
  data: UpdateLWEventDataInput!
}

input UpdateLWEventDataInput {
  legacyData: JSON
  important: Boolean
}

input LWEventSelectorInput {
  AND: [LWEventSelectorInput]
  OR: [LWEventSelectorInput]
}

input LWEventSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum LWEventOrderByInput {
  foobar
}

type LegacyData {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteLegacyDataInput {
  selector: LegacyDataSelectorUniqueInput!
}

input SingleLegacyDataInput {
  selector: LegacyDataSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiLegacyDataInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: LegacyDataSelectorInput
  orderBy: LegacyDataOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLegacyDataOutput {
  result: LegacyData
}

type MultiLegacyDataOutput {
  results: [LegacyData]
  totalCount: Int
}

type LegacyDataOutput {
  data: LegacyData
}

input CreateLegacyDataInput {
  data: CreateLegacyDataDataInput!
}

input CreateLegacyDataDataInput {
  legacyData: JSON
}

input UpdateLegacyDataInput {
  selector: LegacyDataSelectorUniqueInput!
  data: UpdateLegacyDataDataInput!
}

input UpsertLegacyDataInput {
  selector: LegacyDataSelectorUniqueInput!
  data: UpdateLegacyDataDataInput!
}

input UpdateLegacyDataDataInput {
  legacyData: JSON
}

input LegacyDataSelectorInput {
  AND: [LegacyDataSelectorInput]
  OR: [LegacyDataSelectorInput]
}

input LegacyDataSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum LegacyDataOrderByInput {
  foobar
}

type LlmConversation {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  title: String
  model: String
  systemPrompt: String
  lastUpdatedAt: Date
  messages: [LlmMessage]
  deleted: Boolean
  totalCharacterCount: Int
}

input DeleteLlmConversationInput {
  selector: LlmConversationSelectorUniqueInput!
}

input SingleLlmConversationInput {
  selector: LlmConversationSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiLlmConversationInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: LlmConversationSelectorInput
  orderBy: LlmConversationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLlmConversationOutput {
  result: LlmConversation
}

type MultiLlmConversationOutput {
  results: [LlmConversation]
  totalCount: Int
}

type LlmConversationOutput {
  data: LlmConversation
}

input CreateLlmConversationInput {
  data: CreateLlmConversationDataInput!
}

input CreateLlmConversationDataInput {
  legacyData: JSON
  userId: String!
  title: String!
  model: String!
  systemPrompt: String
  deleted: Boolean
}

input UpdateLlmConversationInput {
  selector: LlmConversationSelectorUniqueInput!
  data: UpdateLlmConversationDataInput!
}

input UpsertLlmConversationInput {
  selector: LlmConversationSelectorUniqueInput!
  data: UpdateLlmConversationDataInput!
}

input UpdateLlmConversationDataInput {
  legacyData: JSON
  userId: String
  title: String
  model: String
  systemPrompt: String
  deleted: Boolean
}

input LlmConversationSelectorInput {
  AND: [LlmConversationSelectorInput]
  OR: [LlmConversationSelectorInput]
}

input LlmConversationSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum LlmConversationOrderByInput {
  foobar
}

type LlmMessage {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  conversationId: String
  role: String
  content: String
}

input DeleteLlmMessageInput {
  selector: LlmMessageSelectorUniqueInput!
}

input SingleLlmMessageInput {
  selector: LlmMessageSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiLlmMessageInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: LlmMessageSelectorInput
  orderBy: LlmMessageOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLlmMessageOutput {
  result: LlmMessage
}

type MultiLlmMessageOutput {
  results: [LlmMessage]
  totalCount: Int
}

type LlmMessageOutput {
  data: LlmMessage
}

input CreateLlmMessageInput {
  data: CreateLlmMessageDataInput!
}

input CreateLlmMessageDataInput {
  legacyData: JSON
  userId: String!
  conversationId: String
  role: String!
  content: String!
}

input UpdateLlmMessageInput {
  selector: LlmMessageSelectorUniqueInput!
  data: UpdateLlmMessageDataInput!
}

input UpsertLlmMessageInput {
  selector: LlmMessageSelectorUniqueInput!
  data: UpdateLlmMessageDataInput!
}

input UpdateLlmMessageDataInput {
  legacyData: JSON
  userId: String
  conversationId: String
  role: String
  content: String
}

input LlmMessageSelectorInput {
  AND: [LlmMessageSelectorInput]
  OR: [LlmMessageSelectorInput]
}

input LlmMessageSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum LlmMessageOrderByInput {
  foobar
}

type Localgroup {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  name: String
  nameInAnotherLanguage: String
  organizerIds: [String]
  organizers: [User!]!
  lastActivity: Date
  types: [String]
  categories: [String]
  isOnline: Boolean
  mongoLocation: JSON
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  facebookPageLink: String
  meetupLink: String
  slackLink: String
  website: String
  bannerImageId: String
  inactive: Boolean
  deleted: Boolean
}

input DeleteLocalgroupInput {
  selector: LocalgroupSelectorUniqueInput!
}

input SingleLocalgroupInput {
  selector: LocalgroupSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiLocalgroupInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: LocalgroupSelectorInput
  orderBy: LocalgroupOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleLocalgroupOutput {
  result: Localgroup
}

type MultiLocalgroupOutput {
  results: [Localgroup]
  totalCount: Int
}

type LocalgroupOutput {
  data: Localgroup
}

input CreateLocalgroupInput {
  data: CreateLocalgroupDataInput!
}

input CreateLocalgroupDataInput {
  legacyData: JSON
  contents: JSON
  name: String!
  nameInAnotherLanguage: String
  organizerIds: [String]!
  lastActivity: Date
  types: [String]!
  categories: [String]
  isOnline: Boolean
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  facebookPageLink: String
  meetupLink: String
  slackLink: String
  website: String
  bannerImageId: String
  inactive: Boolean
  deleted: Boolean
}

input UpdateLocalgroupInput {
  selector: LocalgroupSelectorUniqueInput!
  data: UpdateLocalgroupDataInput!
}

input UpsertLocalgroupInput {
  selector: LocalgroupSelectorUniqueInput!
  data: UpdateLocalgroupDataInput!
}

input UpdateLocalgroupDataInput {
  legacyData: JSON
  contents: JSON
  name: String
  nameInAnotherLanguage: String
  organizerIds: [String]
  lastActivity: Date
  types: [String]
  categories: [String]
  isOnline: Boolean
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  facebookPageLink: String
  meetupLink: String
  slackLink: String
  website: String
  bannerImageId: String
  inactive: Boolean
  deleted: Boolean
}

input LocalgroupSelectorInput {
  AND: [LocalgroupSelectorInput]
  OR: [LocalgroupSelectorInput]
}

input LocalgroupSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum LocalgroupOrderByInput {
  foobar
}

type ManifoldProbabilitiesCache {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  marketId: String
  probability: Float
  isResolved: Boolean
  year: Float
  lastUpdated: Date
  url: String
}

input DeleteManifoldProbabilitiesCacheInput {
  selector: ManifoldProbabilitiesCacheSelectorUniqueInput!
}

input SingleManifoldProbabilitiesCacheInput {
  selector: ManifoldProbabilitiesCacheSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiManifoldProbabilitiesCacheInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ManifoldProbabilitiesCacheSelectorInput
  orderBy: ManifoldProbabilitiesCacheOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleManifoldProbabilitiesCacheOutput {
  result: ManifoldProbabilitiesCache
}

type MultiManifoldProbabilitiesCacheOutput {
  results: [ManifoldProbabilitiesCache]
  totalCount: Int
}

type ManifoldProbabilitiesCacheOutput {
  data: ManifoldProbabilitiesCache
}

input CreateManifoldProbabilitiesCacheInput {
  data: CreateManifoldProbabilitiesCacheDataInput!
}

input CreateManifoldProbabilitiesCacheDataInput {
  legacyData: JSON
  marketId: String!
  probability: Float!
  isResolved: Boolean!
  year: Float!
  lastUpdated: Date!
  url: String
}

input UpdateManifoldProbabilitiesCacheInput {
  selector: ManifoldProbabilitiesCacheSelectorUniqueInput!
  data: UpdateManifoldProbabilitiesCacheDataInput!
}

input UpsertManifoldProbabilitiesCacheInput {
  selector: ManifoldProbabilitiesCacheSelectorUniqueInput!
  data: UpdateManifoldProbabilitiesCacheDataInput!
}

input UpdateManifoldProbabilitiesCacheDataInput {
  legacyData: JSON
}

input ManifoldProbabilitiesCacheSelectorInput {
  AND: [ManifoldProbabilitiesCacheSelectorInput]
  OR: [ManifoldProbabilitiesCacheSelectorInput]
}

input ManifoldProbabilitiesCacheSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ManifoldProbabilitiesCacheOrderByInput {
  foobar
}

type Message {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  userId: String
  user: User
  conversationId: String
  conversation: Conversation
  noEmail: Boolean
}

input DeleteMessageInput {
  selector: MessageSelectorUniqueInput!
}

input SingleMessageInput {
  selector: MessageSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiMessageInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: MessageSelectorInput
  orderBy: MessageOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleMessageOutput {
  result: Message
}

type MultiMessageOutput {
  results: [Message]
  totalCount: Int
}

type MessageOutput {
  data: Message
}

input CreateMessageInput {
  data: CreateMessageDataInput!
}

input CreateMessageDataInput {
  legacyData: JSON
  contents: JSON
  userId: String
  conversationId: String!
  noEmail: Boolean
}

input UpdateMessageInput {
  selector: MessageSelectorUniqueInput!
  data: UpdateMessageDataInput!
}

input UpsertMessageInput {
  selector: MessageSelectorUniqueInput!
  data: UpdateMessageDataInput!
}

input UpdateMessageDataInput {
  legacyData: JSON
  contents: JSON
}

input MessageSelectorInput {
  AND: [MessageSelectorInput]
  OR: [MessageSelectorInput]
}

input MessageSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum MessageOrderByInput {
  foobar
}

type Migration {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteMigrationInput {
  selector: MigrationSelectorUniqueInput!
}

input SingleMigrationInput {
  selector: MigrationSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiMigrationInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: MigrationSelectorInput
  orderBy: MigrationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleMigrationOutput {
  result: Migration
}

type MultiMigrationOutput {
  results: [Migration]
  totalCount: Int
}

type MigrationOutput {
  data: Migration
}

input CreateMigrationInput {
  data: CreateMigrationDataInput!
}

input CreateMigrationDataInput {
  legacyData: JSON
}

input UpdateMigrationInput {
  selector: MigrationSelectorUniqueInput!
  data: UpdateMigrationDataInput!
}

input UpsertMigrationInput {
  selector: MigrationSelectorUniqueInput!
  data: UpdateMigrationDataInput!
}

input UpdateMigrationDataInput {
  legacyData: JSON
}

input MigrationSelectorInput {
  AND: [MigrationSelectorInput]
  OR: [MigrationSelectorInput]
}

input MigrationSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum MigrationOrderByInput {
  foobar
}

type ModerationTemplate {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  name: String
  collectionName: String
  order: Float
  deleted: Boolean
}

input DeleteModerationTemplateInput {
  selector: ModerationTemplateSelectorUniqueInput!
}

input SingleModerationTemplateInput {
  selector: ModerationTemplateSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiModerationTemplateInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ModerationTemplateSelectorInput
  orderBy: ModerationTemplateOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleModerationTemplateOutput {
  result: ModerationTemplate
}

type MultiModerationTemplateOutput {
  results: [ModerationTemplate]
  totalCount: Int
}

type ModerationTemplateOutput {
  data: ModerationTemplate
}

input CreateModerationTemplateInput {
  data: CreateModerationTemplateDataInput!
}

input CreateModerationTemplateDataInput {
  legacyData: JSON
  contents: JSON
  name: String!
  collectionName: String!
  order: Float
}

input UpdateModerationTemplateInput {
  selector: ModerationTemplateSelectorUniqueInput!
  data: UpdateModerationTemplateDataInput!
}

input UpsertModerationTemplateInput {
  selector: ModerationTemplateSelectorUniqueInput!
  data: UpdateModerationTemplateDataInput!
}

input UpdateModerationTemplateDataInput {
  legacyData: JSON
  contents: JSON
  name: String
  collectionName: String
  order: Float
  deleted: Boolean
}

input ModerationTemplateSelectorInput {
  AND: [ModerationTemplateSelectorInput]
  OR: [ModerationTemplateSelectorInput]
}

input ModerationTemplateSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ModerationTemplateOrderByInput {
  foobar
}

type ModeratorAction {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  type: String
  endedAt: Date
  active: Boolean!
}

input DeleteModeratorActionInput {
  selector: ModeratorActionSelectorUniqueInput!
}

input SingleModeratorActionInput {
  selector: ModeratorActionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiModeratorActionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ModeratorActionSelectorInput
  orderBy: ModeratorActionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleModeratorActionOutput {
  result: ModeratorAction
}

type MultiModeratorActionOutput {
  results: [ModeratorAction]
  totalCount: Int
}

type ModeratorActionOutput {
  data: ModeratorAction
}

input CreateModeratorActionInput {
  data: CreateModeratorActionDataInput!
}

input CreateModeratorActionDataInput {
  legacyData: JSON
  userId: String
  type: String!
  endedAt: Date
}

input UpdateModeratorActionInput {
  selector: ModeratorActionSelectorUniqueInput!
  data: UpdateModeratorActionDataInput!
}

input UpsertModeratorActionInput {
  selector: ModeratorActionSelectorUniqueInput!
  data: UpdateModeratorActionDataInput!
}

input UpdateModeratorActionDataInput {
  legacyData: JSON
  userId: String
  type: String
  endedAt: Date
}

input ModeratorActionSelectorInput {
  AND: [ModeratorActionSelectorInput]
  OR: [ModeratorActionSelectorInput]
}

input ModeratorActionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ModeratorActionOrderByInput {
  foobar
}

type MultiDocument {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  pingbacks: JSON
  slug: String
  oldSlugs: [String]
  title: String
  preview: String
  tabTitle: String
  tabSubtitle: String
  userId: String
  user: User
  parentDocumentId: String
  parentTag: Tag
  parentLens: MultiDocument
  collectionName: String
  fieldName: String
  index: Float
  tableOfContents(version: String): JSON
  contributors(limit: Int, version: String): TagContributorsList
  contributionStats: JSON
  arbitalLinkedPages: ArbitalLinkedPages
  htmlWithContributorAnnotations: String
  summaries: [MultiDocument!]!
  textLastUpdatedAt: Date
  deleted: Boolean
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float
  baseScore: Float
  extendedScore: JSON
  score: Float
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input DeleteMultiDocumentInput {
  selector: MultiDocumentSelectorUniqueInput!
}

input SingleMultiDocumentInput {
  selector: MultiDocumentSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiMultiDocumentInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: MultiDocumentSelectorInput
  orderBy: MultiDocumentOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleMultiDocumentOutput {
  result: MultiDocument
}

type MultiMultiDocumentOutput {
  results: [MultiDocument]
  totalCount: Int
}

type MultiDocumentOutput {
  data: MultiDocument
}

input CreateMultiDocumentInput {
  data: CreateMultiDocumentDataInput!
}

input CreateMultiDocumentDataInput {
  legacyData: JSON
  contents: JSON
  title: String
  tabTitle: String!
  tabSubtitle: String
  userId: String
  parentDocumentId: String!
  collectionName: String!
  fieldName: String!
}

input UpdateMultiDocumentInput {
  selector: MultiDocumentSelectorUniqueInput!
  data: UpdateMultiDocumentDataInput!
}

input UpsertMultiDocumentInput {
  selector: MultiDocumentSelectorUniqueInput!
  data: UpdateMultiDocumentDataInput!
}

input UpdateMultiDocumentDataInput {
  legacyData: JSON
  contents: JSON
  title: String
  tabTitle: String
  tabSubtitle: String
  index: Float
  deleted: Boolean
}

input MultiDocumentSelectorInput {
  AND: [MultiDocumentSelectorInput]
  OR: [MultiDocumentSelectorInput]
}

input MultiDocumentSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum MultiDocumentOrderByInput {
  foobar
}

type Notification {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  documentId: String
  documentType: String
  extraData: JSON
  link: String
  title: String
  message: String
  type: String
  deleted: Boolean
  viewed: Boolean
  emailed: Boolean
  waitingForBatch: Boolean
}

input DeleteNotificationInput {
  selector: NotificationSelectorUniqueInput!
}

input SingleNotificationInput {
  selector: NotificationSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiNotificationInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: NotificationSelectorInput
  orderBy: NotificationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleNotificationOutput {
  result: Notification
}

type MultiNotificationOutput {
  results: [Notification]
  totalCount: Int
}

type NotificationOutput {
  data: Notification
}

input CreateNotificationInput {
  data: CreateNotificationDataInput!
}

input CreateNotificationDataInput {
  legacyData: JSON
  viewed: Boolean
}

input UpdateNotificationInput {
  selector: NotificationSelectorUniqueInput!
  data: UpdateNotificationDataInput!
}

input UpsertNotificationInput {
  selector: NotificationSelectorUniqueInput!
  data: UpdateNotificationDataInput!
}

input UpdateNotificationDataInput {
  legacyData: JSON
  viewed: Boolean
}

input NotificationSelectorInput {
  AND: [NotificationSelectorInput]
  OR: [NotificationSelectorInput]
}

input NotificationSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum NotificationOrderByInput {
  foobar
}

type PageCacheEntry {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeletePageCacheEntryInput {
  selector: PageCacheEntrySelectorUniqueInput!
}

input SinglePageCacheEntryInput {
  selector: PageCacheEntrySelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPageCacheEntryInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PageCacheEntrySelectorInput
  orderBy: PageCacheEntryOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePageCacheEntryOutput {
  result: PageCacheEntry
}

type MultiPageCacheEntryOutput {
  results: [PageCacheEntry]
  totalCount: Int
}

type PageCacheEntryOutput {
  data: PageCacheEntry
}

input CreatePageCacheEntryInput {
  data: CreatePageCacheEntryDataInput!
}

input CreatePageCacheEntryDataInput {
  legacyData: JSON
}

input UpdatePageCacheEntryInput {
  selector: PageCacheEntrySelectorUniqueInput!
  data: UpdatePageCacheEntryDataInput!
}

input UpsertPageCacheEntryInput {
  selector: PageCacheEntrySelectorUniqueInput!
  data: UpdatePageCacheEntryDataInput!
}

input UpdatePageCacheEntryDataInput {
  legacyData: JSON
}

input PageCacheEntrySelectorInput {
  AND: [PageCacheEntrySelectorInput]
  OR: [PageCacheEntrySelectorInput]
}

input PageCacheEntrySelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PageCacheEntryOrderByInput {
  foobar
}

type PetrovDayAction {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  actionType: String
  data: JSON
  userId: String
}

input DeletePetrovDayActionInput {
  selector: PetrovDayActionSelectorUniqueInput!
}

input SinglePetrovDayActionInput {
  selector: PetrovDayActionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPetrovDayActionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PetrovDayActionSelectorInput
  orderBy: PetrovDayActionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePetrovDayActionOutput {
  result: PetrovDayAction
}

type MultiPetrovDayActionOutput {
  results: [PetrovDayAction]
  totalCount: Int
}

type PetrovDayActionOutput {
  data: PetrovDayAction
}

input CreatePetrovDayActionInput {
  data: CreatePetrovDayActionDataInput!
}

input CreatePetrovDayActionDataInput {
  legacyData: JSON
  actionType: String!
  data: JSON
  userId: String!
}

input UpdatePetrovDayActionInput {
  selector: PetrovDayActionSelectorUniqueInput!
  data: UpdatePetrovDayActionDataInput!
}

input UpsertPetrovDayActionInput {
  selector: PetrovDayActionSelectorUniqueInput!
  data: UpdatePetrovDayActionDataInput!
}

input UpdatePetrovDayActionDataInput {
  legacyData: JSON
}

input PetrovDayActionSelectorInput {
  AND: [PetrovDayActionSelectorInput]
  OR: [PetrovDayActionSelectorInput]
}

input PetrovDayActionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PetrovDayActionOrderByInput {
  foobar
}

type PetrovDayLaunch {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  launchCode: String
  hashedLaunchCode: String
  userId: String
}

input DeletePetrovDayLaunchInput {
  selector: PetrovDayLaunchSelectorUniqueInput!
}

input SinglePetrovDayLaunchInput {
  selector: PetrovDayLaunchSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPetrovDayLaunchInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PetrovDayLaunchSelectorInput
  orderBy: PetrovDayLaunchOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePetrovDayLaunchOutput {
  result: PetrovDayLaunch
}

type MultiPetrovDayLaunchOutput {
  results: [PetrovDayLaunch]
  totalCount: Int
}

type PetrovDayLaunchOutput {
  data: PetrovDayLaunch
}

input CreatePetrovDayLaunchInput {
  data: CreatePetrovDayLaunchDataInput!
}

input CreatePetrovDayLaunchDataInput {
  legacyData: JSON
  launchCode: String
  hashedLaunchCode: String
  userId: String
}

input UpdatePetrovDayLaunchInput {
  selector: PetrovDayLaunchSelectorUniqueInput!
  data: UpdatePetrovDayLaunchDataInput!
}

input UpsertPetrovDayLaunchInput {
  selector: PetrovDayLaunchSelectorUniqueInput!
  data: UpdatePetrovDayLaunchDataInput!
}

input UpdatePetrovDayLaunchDataInput {
  legacyData: JSON
  launchCode: String
  hashedLaunchCode: String
  userId: String
}

input PetrovDayLaunchSelectorInput {
  AND: [PetrovDayLaunchSelectorInput]
  OR: [PetrovDayLaunchSelectorInput]
}

input PetrovDayLaunchSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PetrovDayLaunchOrderByInput {
  foobar
}

type PodcastEpisode {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  podcastId: String
  podcast: Podcast!
  title: String
  episodeLink: String
  externalEpisodeId: String
}

input DeletePodcastEpisodeInput {
  selector: PodcastEpisodeSelectorUniqueInput!
}

input SinglePodcastEpisodeInput {
  selector: PodcastEpisodeSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPodcastEpisodeInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PodcastEpisodeSelectorInput
  orderBy: PodcastEpisodeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePodcastEpisodeOutput {
  result: PodcastEpisode
}

type MultiPodcastEpisodeOutput {
  results: [PodcastEpisode]
  totalCount: Int
}

type PodcastEpisodeOutput {
  data: PodcastEpisode
}

input CreatePodcastEpisodeInput {
  data: CreatePodcastEpisodeDataInput!
}

input CreatePodcastEpisodeDataInput {
  legacyData: JSON
  podcastId: String
  title: String!
  episodeLink: String!
  externalEpisodeId: String!
}

input UpdatePodcastEpisodeInput {
  selector: PodcastEpisodeSelectorUniqueInput!
  data: UpdatePodcastEpisodeDataInput!
}

input UpsertPodcastEpisodeInput {
  selector: PodcastEpisodeSelectorUniqueInput!
  data: UpdatePodcastEpisodeDataInput!
}

input UpdatePodcastEpisodeDataInput {
  legacyData: JSON
}

input PodcastEpisodeSelectorInput {
  AND: [PodcastEpisodeSelectorInput]
  OR: [PodcastEpisodeSelectorInput]
}

input PodcastEpisodeSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PodcastEpisodeOrderByInput {
  foobar
}

type Podcast {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  title: String
  applePodcastLink: String
  spotifyPodcastLink: String
}

input DeletePodcastInput {
  selector: PodcastSelectorUniqueInput!
}

input SinglePodcastInput {
  selector: PodcastSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPodcastInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PodcastSelectorInput
  orderBy: PodcastOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePodcastOutput {
  result: Podcast
}

type MultiPodcastOutput {
  results: [Podcast]
  totalCount: Int
}

type PodcastOutput {
  data: Podcast
}

input CreatePodcastInput {
  data: CreatePodcastDataInput!
}

input CreatePodcastDataInput {
  legacyData: JSON
}

input UpdatePodcastInput {
  selector: PodcastSelectorUniqueInput!
  data: UpdatePodcastDataInput!
}

input UpsertPodcastInput {
  selector: PodcastSelectorUniqueInput!
  data: UpdatePodcastDataInput!
}

input UpdatePodcastDataInput {
  legacyData: JSON
}

input PodcastSelectorInput {
  AND: [PodcastSelectorInput]
  OR: [PodcastSelectorInput]
}

input PodcastSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PodcastOrderByInput {
  foobar
}

type PostEmbedding {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  postId: String
  post: Post
  postHash: String
  lastGeneratedAt: Date
  model: String
  embeddings: [Float]
}

input DeletePostEmbeddingInput {
  selector: PostEmbeddingSelectorUniqueInput!
}

input SinglePostEmbeddingInput {
  selector: PostEmbeddingSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPostEmbeddingInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PostEmbeddingSelectorInput
  orderBy: PostEmbeddingOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostEmbeddingOutput {
  result: PostEmbedding
}

type MultiPostEmbeddingOutput {
  results: [PostEmbedding]
  totalCount: Int
}

type PostEmbeddingOutput {
  data: PostEmbedding
}

input CreatePostEmbeddingInput {
  data: CreatePostEmbeddingDataInput!
}

input CreatePostEmbeddingDataInput {
  legacyData: JSON
  postId: String!
  postHash: String!
  lastGeneratedAt: Date!
  model: String!
  embeddings: [Float]!
}

input UpdatePostEmbeddingInput {
  selector: PostEmbeddingSelectorUniqueInput!
  data: UpdatePostEmbeddingDataInput!
}

input UpsertPostEmbeddingInput {
  selector: PostEmbeddingSelectorUniqueInput!
  data: UpdatePostEmbeddingDataInput!
}

input UpdatePostEmbeddingDataInput {
  legacyData: JSON
  postId: String
  postHash: String
  lastGeneratedAt: Date
  model: String
  embeddings: [Float]
}

input PostEmbeddingSelectorInput {
  AND: [PostEmbeddingSelectorInput]
  OR: [PostEmbeddingSelectorInput]
}

input PostEmbeddingSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PostEmbeddingOrderByInput {
  foobar
}

type PostRecommendation {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  clientId: String
  postId: String
  post: Post
  strategyName: String
  strategySettings: JSON
  recommendationCount: Int
  lastRecommendedAt: Date
  clickedAt: Date
}

input DeletePostRecommendationInput {
  selector: PostRecommendationSelectorUniqueInput!
}

input SinglePostRecommendationInput {
  selector: PostRecommendationSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPostRecommendationInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PostRecommendationSelectorInput
  orderBy: PostRecommendationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostRecommendationOutput {
  result: PostRecommendation
}

type MultiPostRecommendationOutput {
  results: [PostRecommendation]
  totalCount: Int
}

type PostRecommendationOutput {
  data: PostRecommendation
}

input CreatePostRecommendationInput {
  data: CreatePostRecommendationDataInput!
}

input CreatePostRecommendationDataInput {
  legacyData: JSON
  userId: String
  clientId: String
  postId: String!
  strategyName: String!
  strategySettings: JSON
  recommendationCount: Int!
  lastRecommendedAt: Date!
  clickedAt: Date
}

input UpdatePostRecommendationInput {
  selector: PostRecommendationSelectorUniqueInput!
  data: UpdatePostRecommendationDataInput!
}

input UpsertPostRecommendationInput {
  selector: PostRecommendationSelectorUniqueInput!
  data: UpdatePostRecommendationDataInput!
}

input UpdatePostRecommendationDataInput {
  legacyData: JSON
  userId: String
  clientId: String
  postId: String
  strategyName: String
  strategySettings: JSON
  recommendationCount: Int
  lastRecommendedAt: Date
  clickedAt: Date
}

input PostRecommendationSelectorInput {
  AND: [PostRecommendationSelectorInput]
  OR: [PostRecommendationSelectorInput]
}

input PostRecommendationSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PostRecommendationOrderByInput {
  foobar
}

type PostRelation {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  type: String
  sourcePostId: String
  sourcePost: Post
  targetPostId: String
  targetPost: Post
  order: Float
}

input DeletePostRelationInput {
  selector: PostRelationSelectorUniqueInput!
}

input SinglePostRelationInput {
  selector: PostRelationSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPostRelationInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PostRelationSelectorInput
  orderBy: PostRelationOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostRelationOutput {
  result: PostRelation
}

type MultiPostRelationOutput {
  results: [PostRelation]
  totalCount: Int
}

type PostRelationOutput {
  data: PostRelation
}

input CreatePostRelationInput {
  data: CreatePostRelationDataInput!
}

input CreatePostRelationDataInput {
  legacyData: JSON
  type: String
  sourcePostId: String!
  targetPostId: String!
  order: Float
}

input UpdatePostRelationInput {
  selector: PostRelationSelectorUniqueInput!
  data: UpdatePostRelationDataInput!
}

input UpsertPostRelationInput {
  selector: PostRelationSelectorUniqueInput!
  data: UpdatePostRelationDataInput!
}

input UpdatePostRelationDataInput {
  legacyData: JSON
  type: String
  order: Float
}

input PostRelationSelectorInput {
  AND: [PostRelationSelectorInput]
  OR: [PostRelationSelectorInput]
}

input PostRelationSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PostRelationOrderByInput {
  foobar
}

type PostViewTime {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeletePostViewTimeInput {
  selector: PostViewTimeSelectorUniqueInput!
}

input SinglePostViewTimeInput {
  selector: PostViewTimeSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPostViewTimeInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PostViewTimeSelectorInput
  orderBy: PostViewTimeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostViewTimeOutput {
  result: PostViewTime
}

type MultiPostViewTimeOutput {
  results: [PostViewTime]
  totalCount: Int
}

type PostViewTimeOutput {
  data: PostViewTime
}

input CreatePostViewTimeInput {
  data: CreatePostViewTimeDataInput!
}

input CreatePostViewTimeDataInput {
  legacyData: JSON
}

input UpdatePostViewTimeInput {
  selector: PostViewTimeSelectorUniqueInput!
  data: UpdatePostViewTimeDataInput!
}

input UpsertPostViewTimeInput {
  selector: PostViewTimeSelectorUniqueInput!
  data: UpdatePostViewTimeDataInput!
}

input UpdatePostViewTimeDataInput {
  legacyData: JSON
}

input PostViewTimeSelectorInput {
  AND: [PostViewTimeSelectorInput]
  OR: [PostViewTimeSelectorInput]
}

input PostViewTimeSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PostViewTimeOrderByInput {
  foobar
}

type PostViews {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeletePostViewsInput {
  selector: PostViewsSelectorUniqueInput!
}

input SinglePostViewsInput {
  selector: PostViewsSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPostViewsInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PostViewsSelectorInput
  orderBy: PostViewsOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostViewsOutput {
  result: PostViews
}

type MultiPostViewsOutput {
  results: [PostViews]
  totalCount: Int
}

type PostViewsOutput {
  data: PostViews
}

input CreatePostViewsInput {
  data: CreatePostViewsDataInput!
}

input CreatePostViewsDataInput {
  legacyData: JSON
}

input UpdatePostViewsInput {
  selector: PostViewsSelectorUniqueInput!
  data: UpdatePostViewsDataInput!
}

input UpsertPostViewsInput {
  selector: PostViewsSelectorUniqueInput!
  data: UpdatePostViewsDataInput!
}

input UpdatePostViewsDataInput {
  legacyData: JSON
}

input PostViewsSelectorInput {
  AND: [PostViewsSelectorInput]
  OR: [PostViewsSelectorInput]
}

input PostViewsSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PostViewsOrderByInput {
  foobar
}

type Post {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  revisions(limit: Int = 5): [Revision]
  version: String
  pingbacks: JSON
  moderationGuidelines(version: String): Revision
  moderationGuidelines_latest: String
  customHighlight(version: String): Revision
  customHighlight_latest: String
  slug: String
  postedAt: Date
  modifiedAt: Date
  url: String
  postCategory: String
  title: String
  viewCount: Float
  lastCommentedAt: Date
  clickCount: Float
  deletedDraft: Boolean
  status: Float
  isFuture: Boolean
  sticky: Boolean
  stickyPriority: Int
  userIP: String
  userAgent: String
  referrer: String
  author: String
  userId: String
  user: User
  domain: String
  pageUrl: String!
  pageUrlRelative: String
  linkUrl: String
  postedAtFormatted: String
  emailShareUrl: String
  twitterShareUrl: String
  facebookShareUrl: String
  socialPreviewImageUrl: String
  question: Boolean
  authorIsUnreviewed: Boolean
  readTimeMinutesOverride: Float
  readTimeMinutes: Int!
  wordCount: Int
  htmlBody: String
  submitToFrontpage: Boolean
  hiddenRelatedQuestion: Boolean
  originalPostRelationSourceId: String
  sourcePostRelations: [PostRelation!]!
  targetPostRelations: [PostRelation!]!
  shortform: Boolean
  canonicalSource: String
  nominationCount2018: Float
  nominationCount2019: Float
  reviewCount2018: Float
  reviewCount2019: Float
  reviewCount: Float
  reviewVoteCount: Float
  positiveReviewVoteCount: Float
  manifoldReviewMarketId: String
  annualReviewMarketProbability: Float
  annualReviewMarketIsResolved: Boolean
  annualReviewMarketYear: Int
  annualReviewMarketUrl: String
  glossary: [JargonTerm!]!
  reviewVoteScoreAF: Float
  reviewVotesAF: [Float]
  reviewVoteScoreHighKarma: Float
  reviewVotesHighKarma: [Float]
  reviewVoteScoreAllKarma: Float
  reviewVotesAllKarma: [Float]
  finalReviewVoteScoreHighKarma: Float
  finalReviewVotesHighKarma: [Float]
  finalReviewVoteScoreAllKarma: Float
  finalReviewVotesAllKarma: [Float]
  finalReviewVoteScoreAF: Float
  finalReviewVotesAF: [Float]
  lastCommentPromotedAt: Date
  tagRel(tagId: String): TagRel
  tags: [Tag]
  tagRelevance: JSON
  lastPromotedComment: Comment
  bestAnswer: Comment
  noIndex: Boolean
  rsvps: [JSON]
  rsvpCounts: JSON!
  activateRSVPs: Boolean
  nextDayReminderSent: Boolean
  onlyVisibleToLoggedIn: Boolean
  onlyVisibleToEstablishedAccounts: Boolean
  hideFromRecentDiscussions: Boolean
  currentUserReviewVote: ReviewVote
  reviewWinner: ReviewWinner
  spotlight: Spotlight
  votingSystem: String
  myEditorAccess: String!
  podcastEpisodeId: String
  podcastEpisode: PodcastEpisode
  forceAllowType3Audio: Boolean
  legacy: Boolean
  legacyId: String
  legacySpam: Boolean
  feedId: String
  feed: RSSFeed
  feedLink: String
  lastVisitedAt: Date
  isRead: Boolean
  curatedDate: Date
  metaDate: Date
  suggestForCuratedUserIds: [String]
  suggestForCuratedUsernames: String
  frontpageDate: Date
  autoFrontpage: String
  collectionTitle: String
  coauthorStatuses: [JSON]
  coauthors: [User!]
  hasCoauthorPermission: Boolean
  socialPreviewImageId: String
  socialPreviewImageAutoUrl: String
  socialPreview: JSON
  socialPreviewData: SocialPreviewType
  fmCrosspost: JSON
  canonicalSequenceId: String
  canonicalSequence: Sequence
  canonicalCollectionSlug: String
  canonicalCollection: Collection
  canonicalBookId: String
  canonicalBook: Book
  canonicalNextPostSlug: String
  canonicalPrevPostSlug: String
  nextPost(sequenceId: String): Post
  prevPost(sequenceId: String): Post
  sequence(sequenceId: String, prevOrNext: String): Sequence
  unlisted: Boolean
  disableRecommendation: Boolean
  defaultRecommendation: Boolean
  hideFromPopularComments: Boolean
  draft: Boolean
  wasEverUndrafted: Boolean
  meta: Boolean
  hideFrontpageComments: Boolean
  maxBaseScore: Float
  scoreExceeded2Date: Date
  scoreExceeded30Date: Date
  scoreExceeded45Date: Date
  scoreExceeded75Date: Date
  scoreExceeded125Date: Date
  scoreExceeded200Date: Date
  bannedUserIds: [String]
  commentsLocked: Boolean
  commentsLockedToAccountsCreatedAfter: Date
  organizerIds: [String]
  organizers: [User!]
  groupId: String
  group: Localgroup
  eventType: String
  isEvent: Boolean
  reviewedByUserId: String
  reviewedByUser: User
  reviewForCuratedUserId: String
  startTime: Date
  localStartTime: Date
  endTime: Date
  localEndTime: Date
  eventRegistrationLink: String
  joinEventLink: String
  onlineEvent: Boolean
  globalEvent: Boolean
  mongoLocation: JSON
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  meetupLink: String
  website: String
  eventImageId: String
  types: [String]
  metaSticky: Boolean
  sharingSettings: JSON
  shareWithUsers: [String]
  usersSharedWith: [User!]
  linkSharingKey: String
  linkSharingKeyUsedBy: [String]
  commentSortOrder: String
  hideAuthor: Boolean
  tableOfContents: JSON
  tableOfContentsRevision(version: String): JSON
  sideComments: JSON
  sideCommentsCache: SideCommentCache
  sideCommentVisibility: String
  disableSidenotes: Boolean
  moderationStyle: String
  ignoreRateLimits: Boolean
  hideCommentKarma: Boolean
  commentCount: Float
  topLevelCommentCount: Float
  recentComments(commentsLimit: Int, maxAgeHours: Int, af: Boolean): [Comment]
  languageModelSummary: String
  debate: Boolean
  collabEditorDialogue: Boolean
  totalDialogueResponseCount: Int!
  mostRecentPublishedDialogueResponseDate: Date
  unreadDebateResponseCount: Int!
  emojiReactors: JSON
  commentEmojiReactors: JSON
  rejected: Boolean
  rejectedReason: String
  rejectedByUserId: String
  rejectedByUser: User
  dialogTooltipPreview: String
  dialogueMessageContents(dialogueMessageId: String): String
  firstVideoAttribsForPreview: JSON
  subforumTagId: String
  subforumTag: Tag
  af: Boolean
  afDate: Date
  afCommentCount: Float
  afLastCommentedAt: Date
  afSticky: Boolean
  suggestForAlignmentUserIds: [String]
  suggestForAlignmentUsers: [User!]!
  reviewForAlignmentUserId: String
  agentFoundationsId: String
  swrCachingEnabled: Boolean
  generateDraftJargon: Boolean
  curationNotices: [CurationNotice]
  reviews: [Comment]
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float
  baseScore: Float
  extendedScore: JSON
  score: Float
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input DeletePostInput {
  selector: PostSelectorUniqueInput!
}

input SinglePostInput {
  selector: PostSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiPostInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: PostSelectorInput
  orderBy: PostOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePostOutput {
  result: Post
}

type MultiPostOutput {
  results: [Post]
  totalCount: Int
}

type PostOutput {
  data: Post
}

input CreatePostInput {
  data: CreatePostDataInput!
}

input CreatePostDataInput {
  legacyData: JSON
  contents: JSON
  moderationGuidelines: JSON
  customHighlight: JSON
  postedAt: Date
  url: String
  postCategory: String
  title: String!
  status: Float
  sticky: Boolean
  stickyPriority: Int
  userId: String
  question: Boolean
  authorIsUnreviewed: Boolean
  readTimeMinutesOverride: Float
  submitToFrontpage: Boolean
  hiddenRelatedQuestion: Boolean
  originalPostRelationSourceId: String
  shortform: Boolean
  canonicalSource: String
  manifoldReviewMarketId: String
  tagRelevance: JSON
  noIndex: Boolean
  activateRSVPs: Boolean
  nextDayReminderSent: Boolean
  onlyVisibleToLoggedIn: Boolean
  onlyVisibleToEstablishedAccounts: Boolean
  hideFromRecentDiscussions: Boolean
  podcastEpisodeId: String
  forceAllowType3Audio: Boolean
  legacy: Boolean
  legacyId: String
  legacySpam: Boolean
  feedId: String
  feedLink: String
  curatedDate: Date
  metaDate: Date
  suggestForCuratedUserIds: [String]
  frontpageDate: Date
  autoFrontpage: String
  collectionTitle: String
  coauthorStatuses: [JSON]
  hasCoauthorPermission: Boolean
  socialPreviewImageId: String
  socialPreviewImageAutoUrl: String
  socialPreview: JSON
  fmCrosspost: JSON
  canonicalSequenceId: String
  canonicalCollectionSlug: String
  canonicalBookId: String
  canonicalNextPostSlug: String
  canonicalPrevPostSlug: String
  unlisted: Boolean
  disableRecommendation: Boolean
  defaultRecommendation: Boolean
  hideFromPopularComments: Boolean
  draft: Boolean
  wasEverUndrafted: Boolean
  meta: Boolean
  hideFrontpageComments: Boolean
  bannedUserIds: [String]
  commentsLocked: Boolean
  commentsLockedToAccountsCreatedAfter: Date
  organizerIds: [String]
  groupId: String
  eventType: String
  isEvent: Boolean
  reviewedByUserId: String
  reviewForCuratedUserId: String
  startTime: Date
  endTime: Date
  eventRegistrationLink: String
  joinEventLink: String
  onlineEvent: Boolean
  globalEvent: Boolean
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  meetupLink: String
  website: String
  eventImageId: String
  types: [String]
  metaSticky: Boolean
  sharingSettings: JSON
  shareWithUsers: [String]
  commentSortOrder: String
  hideAuthor: Boolean
  sideCommentVisibility: String
  disableSidenotes: Boolean
  moderationStyle: String
  ignoreRateLimits: Boolean
  hideCommentKarma: Boolean
  debate: Boolean
  collabEditorDialogue: Boolean
  rejected: Boolean
  rejectedReason: String
  rejectedByUserId: String
  subforumTagId: String
  af: Boolean
  afDate: Date
  afSticky: Boolean
  suggestForAlignmentUserIds: [String]
  reviewForAlignmentUserId: String
  agentFoundationsId: String
  swrCachingEnabled: Boolean
  generateDraftJargon: Boolean
}

input UpdatePostInput {
  selector: PostSelectorUniqueInput!
  data: UpdatePostDataInput!
}

input UpsertPostInput {
  selector: PostSelectorUniqueInput!
  data: UpdatePostDataInput!
}

input UpdatePostDataInput {
  legacyData: JSON
  contents: JSON
  moderationGuidelines: JSON
  customHighlight: JSON
  postedAt: Date
  url: String
  postCategory: String
  title: String
  deletedDraft: Boolean
  status: Float
  sticky: Boolean
  stickyPriority: Int
  userId: String
  question: Boolean
  authorIsUnreviewed: Boolean
  readTimeMinutesOverride: Float
  submitToFrontpage: Boolean
  hiddenRelatedQuestion: Boolean
  shortform: Boolean
  canonicalSource: String
  manifoldReviewMarketId: String
  tagRelevance: JSON
  noIndex: Boolean
  activateRSVPs: Boolean
  nextDayReminderSent: Boolean
  onlyVisibleToLoggedIn: Boolean
  onlyVisibleToEstablishedAccounts: Boolean
  hideFromRecentDiscussions: Boolean
  votingSystem: String
  podcastEpisodeId: String
  forceAllowType3Audio: Boolean
  legacy: Boolean
  legacyId: String
  legacySpam: Boolean
  feedId: String
  feedLink: String
  curatedDate: Date
  metaDate: Date
  suggestForCuratedUserIds: [String]
  frontpageDate: Date
  autoFrontpage: String
  collectionTitle: String
  coauthorStatuses: [JSON]
  hasCoauthorPermission: Boolean
  socialPreviewImageId: String
  socialPreviewImageAutoUrl: String
  socialPreview: JSON
  fmCrosspost: JSON
  canonicalSequenceId: String
  canonicalCollectionSlug: String
  canonicalBookId: String
  canonicalNextPostSlug: String
  canonicalPrevPostSlug: String
  unlisted: Boolean
  disableRecommendation: Boolean
  defaultRecommendation: Boolean
  hideFromPopularComments: Boolean
  draft: Boolean
  wasEverUndrafted: Boolean
  meta: Boolean
  hideFrontpageComments: Boolean
  bannedUserIds: [String]
  commentsLocked: Boolean
  commentsLockedToAccountsCreatedAfter: Date
  organizerIds: [String]
  groupId: String
  eventType: String
  isEvent: Boolean
  reviewedByUserId: String
  reviewForCuratedUserId: String
  startTime: Date
  endTime: Date
  eventRegistrationLink: String
  joinEventLink: String
  onlineEvent: Boolean
  globalEvent: Boolean
  googleLocation: JSON
  location: String
  contactInfo: String
  facebookLink: String
  meetupLink: String
  website: String
  eventImageId: String
  types: [String]
  metaSticky: Boolean
  sharingSettings: JSON
  shareWithUsers: [String]
  linkSharingKey: String
  commentSortOrder: String
  hideAuthor: Boolean
  sideCommentVisibility: String
  disableSidenotes: Boolean
  moderationStyle: String
  ignoreRateLimits: Boolean
  hideCommentKarma: Boolean
  debate: Boolean
  collabEditorDialogue: Boolean
  rejected: Boolean
  rejectedReason: String
  rejectedByUserId: String
  subforumTagId: String
  af: Boolean
  afDate: Date
  afSticky: Boolean
  suggestForAlignmentUserIds: [String]
  reviewForAlignmentUserId: String
  agentFoundationsId: String
  swrCachingEnabled: Boolean
  generateDraftJargon: Boolean
}

input PostSelectorInput {
  AND: [PostSelectorInput]
  OR: [PostSelectorInput]
}

input PostSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum PostOrderByInput {
  foobar
}

type RSSFeed {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  ownedByUser: Boolean
  displayFullContent: Boolean
  nickname: String
  url: String
  status: String
  rawFeed: JSON
  setCanonicalUrl: Boolean
  importAsDraft: Boolean
}

input DeleteRSSFeedInput {
  selector: RSSFeedSelectorUniqueInput!
}

input SingleRSSFeedInput {
  selector: RSSFeedSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiRSSFeedInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: RSSFeedSelectorInput
  orderBy: RSSFeedOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleRSSFeedOutput {
  result: RSSFeed
}

type MultiRSSFeedOutput {
  results: [RSSFeed]
  totalCount: Int
}

type RSSFeedOutput {
  data: RSSFeed
}

input CreateRSSFeedInput {
  data: CreateRSSFeedDataInput!
}

input CreateRSSFeedDataInput {
  legacyData: JSON
  userId: String
  ownedByUser: Boolean
  displayFullContent: Boolean
  nickname: String
  url: String
  rawFeed: JSON
  setCanonicalUrl: Boolean
  importAsDraft: Boolean
}

input UpdateRSSFeedInput {
  selector: RSSFeedSelectorUniqueInput!
  data: UpdateRSSFeedDataInput!
}

input UpsertRSSFeedInput {
  selector: RSSFeedSelectorUniqueInput!
  data: UpdateRSSFeedDataInput!
}

input UpdateRSSFeedDataInput {
  legacyData: JSON
  userId: String
  ownedByUser: Boolean
  displayFullContent: Boolean
  nickname: String
  url: String
  status: String
  rawFeed: JSON
  setCanonicalUrl: Boolean
  importAsDraft: Boolean
}

input RSSFeedSelectorInput {
  AND: [RSSFeedSelectorInput]
  OR: [RSSFeedSelectorInput]
}

input RSSFeedSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum RSSFeedOrderByInput {
  foobar
}

type ReadStatus {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteReadStatusInput {
  selector: ReadStatusSelectorUniqueInput!
}

input SingleReadStatusInput {
  selector: ReadStatusSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiReadStatusInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ReadStatusSelectorInput
  orderBy: ReadStatusOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReadStatusOutput {
  result: ReadStatus
}

type MultiReadStatusOutput {
  results: [ReadStatus]
  totalCount: Int
}

type ReadStatusOutput {
  data: ReadStatus
}

input CreateReadStatusInput {
  data: CreateReadStatusDataInput!
}

input CreateReadStatusDataInput {
  legacyData: JSON
}

input UpdateReadStatusInput {
  selector: ReadStatusSelectorUniqueInput!
  data: UpdateReadStatusDataInput!
}

input UpsertReadStatusInput {
  selector: ReadStatusSelectorUniqueInput!
  data: UpdateReadStatusDataInput!
}

input UpdateReadStatusDataInput {
  legacyData: JSON
}

input ReadStatusSelectorInput {
  AND: [ReadStatusSelectorInput]
  OR: [ReadStatusSelectorInput]
}

input ReadStatusSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ReadStatusOrderByInput {
  foobar
}

type RecommendationsCache {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  postId: String
  source: String
  scenario: String
  attributionId: String
  ttlMs: Float
}

input DeleteRecommendationsCacheInput {
  selector: RecommendationsCacheSelectorUniqueInput!
}

input SingleRecommendationsCacheInput {
  selector: RecommendationsCacheSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiRecommendationsCacheInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: RecommendationsCacheSelectorInput
  orderBy: RecommendationsCacheOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleRecommendationsCacheOutput {
  result: RecommendationsCache
}

type MultiRecommendationsCacheOutput {
  results: [RecommendationsCache]
  totalCount: Int
}

type RecommendationsCacheOutput {
  data: RecommendationsCache
}

input CreateRecommendationsCacheInput {
  data: CreateRecommendationsCacheDataInput!
}

input CreateRecommendationsCacheDataInput {
  legacyData: JSON
  userId: String!
  postId: String!
  source: String!
  scenario: String!
  attributionId: String!
  ttlMs: Float!
}

input UpdateRecommendationsCacheInput {
  selector: RecommendationsCacheSelectorUniqueInput!
  data: UpdateRecommendationsCacheDataInput!
}

input UpsertRecommendationsCacheInput {
  selector: RecommendationsCacheSelectorUniqueInput!
  data: UpdateRecommendationsCacheDataInput!
}

input UpdateRecommendationsCacheDataInput {
  legacyData: JSON
  userId: String
  postId: String
  source: String
  scenario: String
  attributionId: String
  ttlMs: Float
}

input RecommendationsCacheSelectorInput {
  AND: [RecommendationsCacheSelectorInput]
  OR: [RecommendationsCacheSelectorInput]
}

input RecommendationsCacheSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum RecommendationsCacheOrderByInput {
  foobar
}

type Report {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  reportedUserId: String
  reportedUser: User
  commentId: String
  comment: Comment
  postId: String
  post: Post
  link: String
  claimedUserId: String
  claimedUser: User
  description: String
  closedAt: Date
  markedAsSpam: Boolean
  reportedAsSpam: Boolean
}

input DeleteReportInput {
  selector: ReportSelectorUniqueInput!
}

input SingleReportInput {
  selector: ReportSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiReportInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ReportSelectorInput
  orderBy: ReportOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReportOutput {
  result: Report
}

type MultiReportOutput {
  results: [Report]
  totalCount: Int
}

type ReportOutput {
  data: Report
}

input CreateReportInput {
  data: CreateReportDataInput!
}

input CreateReportDataInput {
  legacyData: JSON
  userId: String
  reportedUserId: String
  commentId: String
  postId: String
  link: String!
  claimedUserId: String
  description: String
  reportedAsSpam: Boolean
}

input UpdateReportInput {
  selector: ReportSelectorUniqueInput!
  data: UpdateReportDataInput!
}

input UpsertReportInput {
  selector: ReportSelectorUniqueInput!
  data: UpdateReportDataInput!
}

input UpdateReportDataInput {
  createdAt: Date
  legacyData: JSON
  claimedUserId: String
  description: String
  closedAt: Date
  markedAsSpam: Boolean
  reportedAsSpam: Boolean
}

input ReportSelectorInput {
  AND: [ReportSelectorInput]
  OR: [ReportSelectorInput]
}

input ReportSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ReportOrderByInput {
  foobar
}

type ReviewVote {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  postId: String
  post: Post
  qualitativeScore: Int
  quadraticScore: Int
  comment: String
  year: String
  dummy: Boolean
  reactions: [String]
}

input DeleteReviewVoteInput {
  selector: ReviewVoteSelectorUniqueInput!
}

input SingleReviewVoteInput {
  selector: ReviewVoteSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiReviewVoteInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ReviewVoteSelectorInput
  orderBy: ReviewVoteOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReviewVoteOutput {
  result: ReviewVote
}

type MultiReviewVoteOutput {
  results: [ReviewVote]
  totalCount: Int
}

type ReviewVoteOutput {
  data: ReviewVote
}

input CreateReviewVoteInput {
  data: CreateReviewVoteDataInput!
}

input CreateReviewVoteDataInput {
  legacyData: JSON
}

input UpdateReviewVoteInput {
  selector: ReviewVoteSelectorUniqueInput!
  data: UpdateReviewVoteDataInput!
}

input UpsertReviewVoteInput {
  selector: ReviewVoteSelectorUniqueInput!
  data: UpdateReviewVoteDataInput!
}

input UpdateReviewVoteDataInput {
  legacyData: JSON
}

input ReviewVoteSelectorInput {
  AND: [ReviewVoteSelectorInput]
  OR: [ReviewVoteSelectorInput]
}

input ReviewVoteSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ReviewVoteOrderByInput {
  foobar
}

type ReviewWinnerArt {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  postId: String
  splashArtImagePrompt: String
  splashArtImageUrl: String
  activeSplashArtCoordinates: SplashArtCoordinate
}

input DeleteReviewWinnerArtInput {
  selector: ReviewWinnerArtSelectorUniqueInput!
}

input SingleReviewWinnerArtInput {
  selector: ReviewWinnerArtSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiReviewWinnerArtInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ReviewWinnerArtSelectorInput
  orderBy: ReviewWinnerArtOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReviewWinnerArtOutput {
  result: ReviewWinnerArt
}

type MultiReviewWinnerArtOutput {
  results: [ReviewWinnerArt]
  totalCount: Int
}

type ReviewWinnerArtOutput {
  data: ReviewWinnerArt
}

input CreateReviewWinnerArtInput {
  data: CreateReviewWinnerArtDataInput!
}

input CreateReviewWinnerArtDataInput {
  legacyData: JSON
  postId: String!
  splashArtImagePrompt: String!
  splashArtImageUrl: String!
}

input UpdateReviewWinnerArtInput {
  selector: ReviewWinnerArtSelectorUniqueInput!
  data: UpdateReviewWinnerArtDataInput!
}

input UpsertReviewWinnerArtInput {
  selector: ReviewWinnerArtSelectorUniqueInput!
  data: UpdateReviewWinnerArtDataInput!
}

input UpdateReviewWinnerArtDataInput {
  legacyData: JSON
  postId: String
  splashArtImagePrompt: String
  splashArtImageUrl: String
}

input ReviewWinnerArtSelectorInput {
  AND: [ReviewWinnerArtSelectorInput]
  OR: [ReviewWinnerArtSelectorInput]
}

input ReviewWinnerArtSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ReviewWinnerArtOrderByInput {
  foobar
}

type ReviewWinner {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  postId: String
  post: Post
  reviewWinnerArt: ReviewWinnerArt
  competitorCount: Int
  reviewYear: Float
  category: String
  curatedOrder: Float
  reviewRanking: Float
  isAI: Boolean
}

input DeleteReviewWinnerInput {
  selector: ReviewWinnerSelectorUniqueInput!
}

input SingleReviewWinnerInput {
  selector: ReviewWinnerSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiReviewWinnerInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: ReviewWinnerSelectorInput
  orderBy: ReviewWinnerOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleReviewWinnerOutput {
  result: ReviewWinner
}

type MultiReviewWinnerOutput {
  results: [ReviewWinner]
  totalCount: Int
}

type ReviewWinnerOutput {
  data: ReviewWinner
}

input CreateReviewWinnerInput {
  data: CreateReviewWinnerDataInput!
}

input CreateReviewWinnerDataInput {
  legacyData: JSON
  postId: String!
  reviewYear: Float!
  category: String!
  curatedOrder: Float
  reviewRanking: Float!
  isAI: Boolean
}

input UpdateReviewWinnerInput {
  selector: ReviewWinnerSelectorUniqueInput!
  data: UpdateReviewWinnerDataInput!
}

input UpsertReviewWinnerInput {
  selector: ReviewWinnerSelectorUniqueInput!
  data: UpdateReviewWinnerDataInput!
}

input UpdateReviewWinnerDataInput {
  legacyData: JSON
  postId: String
  reviewYear: Float
  category: String
  curatedOrder: Float
  reviewRanking: Float
  isAI: Boolean
}

input ReviewWinnerSelectorInput {
  AND: [ReviewWinnerSelectorInput]
  OR: [ReviewWinnerSelectorInput]
}

input ReviewWinnerSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum ReviewWinnerOrderByInput {
  foobar
}

type Revision {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  documentId: String
  collectionName: String
  fieldName: String
  editedAt: Date
  updateType: String
  version: String
  commitMessage: String
  userId: String
  user: User
  draft: Boolean
  originalContents: ContentType
  html: String
  markdown: String
  draftJS: JSON
  ckEditorMarkup: String
  wordCount: Float
  htmlHighlight: String!
  htmlHighlightStartingAtHash(hash: String): String!
  plaintextDescription: String!
  plaintextMainText: String!
  hasFootnotes: Boolean
  changeMetrics: JSON
  googleDocMetadata: JSON
  skipAttributions: Boolean
  tag: Tag
  post: Post
  lens: MultiDocument
  summary: MultiDocument
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float
  baseScore: Float
  extendedScore: JSON
  score: Float
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input DeleteRevisionInput {
  selector: RevisionSelectorUniqueInput!
}

input SingleRevisionInput {
  selector: RevisionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiRevisionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: RevisionSelectorInput
  orderBy: RevisionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleRevisionOutput {
  result: Revision
}

type MultiRevisionOutput {
  results: [Revision]
  totalCount: Int
}

type RevisionOutput {
  data: Revision
}

input CreateRevisionInput {
  data: CreateRevisionDataInput!
}

input CreateRevisionDataInput {
  legacyData: JSON
  updateType: String
  commitMessage: String
}

input UpdateRevisionInput {
  selector: RevisionSelectorUniqueInput!
  data: UpdateRevisionDataInput!
}

input UpsertRevisionInput {
  selector: RevisionSelectorUniqueInput!
  data: UpdateRevisionDataInput!
}

input UpdateRevisionDataInput {
  legacyData: JSON
  skipAttributions: Boolean
}

input RevisionSelectorInput {
  AND: [RevisionSelectorInput]
  OR: [RevisionSelectorInput]
}

input RevisionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum RevisionOrderByInput {
  foobar
}

type Sequence {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  lastUpdated: Date
  userId: String
  user: User
  title: String
  bannerImageId: String
  gridImageId: String
  hideFromAuthorPage: Boolean
  draft: Boolean
  isDeleted: Boolean
  curatedOrder: Float
  userProfileOrder: Float
  canonicalCollectionSlug: String
  canonicalCollection: Collection
  hidden: Boolean
  noindex: Boolean
  postsCount: Int!
  readPostsCount: Int!
  chapters: [Chapter]
  af: Boolean
}

input DeleteSequenceInput {
  selector: SequenceSelectorUniqueInput!
}

input SingleSequenceInput {
  selector: SequenceSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSequenceInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SequenceSelectorInput
  orderBy: SequenceOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSequenceOutput {
  result: Sequence
}

type MultiSequenceOutput {
  results: [Sequence]
  totalCount: Int
}

type SequenceOutput {
  data: Sequence
}

input CreateSequenceInput {
  data: CreateSequenceDataInput!
}

input CreateSequenceDataInput {
  legacyData: JSON
  contents: JSON
  lastUpdated: Date
  userId: String
  title: String!
  bannerImageId: String
  gridImageId: String
  hideFromAuthorPage: Boolean
  draft: Boolean
  isDeleted: Boolean
  curatedOrder: Float
  userProfileOrder: Float
  canonicalCollectionSlug: String
  hidden: Boolean
  noindex: Boolean
  af: Boolean
}

input UpdateSequenceInput {
  selector: SequenceSelectorUniqueInput!
  data: UpdateSequenceDataInput!
}

input UpsertSequenceInput {
  selector: SequenceSelectorUniqueInput!
  data: UpdateSequenceDataInput!
}

input UpdateSequenceDataInput {
  legacyData: JSON
  contents: JSON
  lastUpdated: Date
  userId: String
  title: String
  bannerImageId: String
  gridImageId: String
  hideFromAuthorPage: Boolean
  draft: Boolean
  isDeleted: Boolean
  curatedOrder: Float
  userProfileOrder: Float
  canonicalCollectionSlug: String
  hidden: Boolean
  noindex: Boolean
  af: Boolean
}

input SequenceSelectorInput {
  AND: [SequenceSelectorInput]
  OR: [SequenceSelectorInput]
}

input SequenceSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SequenceOrderByInput {
  foobar
}

type Session {
  _id: String
  session: JSON
  expires: Date
  lastModified: Date
}

input DeleteSessionInput {
  selector: SessionSelectorUniqueInput!
}

input SingleSessionInput {
  selector: SessionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSessionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SessionSelectorInput
  orderBy: SessionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSessionOutput {
  result: Session
}

type MultiSessionOutput {
  results: [Session]
  totalCount: Int
}

type SessionOutput {
  data: Session
}

input CreateSessionInput {
  data: CreateSessionDataInput!
}

input CreateSessionDataInput {
  _id: String!
  session: JSON
  expires: Date
  lastModified: Date
}

input UpdateSessionInput {
  selector: SessionSelectorUniqueInput!
  data: UpdateSessionDataInput!
}

input UpsertSessionInput {
  selector: SessionSelectorUniqueInput!
  data: UpdateSessionDataInput!
}

input UpdateSessionDataInput {
  _id: String
  session: JSON
  expires: Date
  lastModified: Date
}

input SessionSelectorInput {
  AND: [SessionSelectorInput]
  OR: [SessionSelectorInput]
}

input SessionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SessionOrderByInput {
  foobar
}

type SideCommentCache {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  postId: String
  annotatedHtml: String
  commentsByBlock: JSON
  version: Float
}

input DeleteSideCommentCacheInput {
  selector: SideCommentCacheSelectorUniqueInput!
}

input SingleSideCommentCacheInput {
  selector: SideCommentCacheSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSideCommentCacheInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SideCommentCacheSelectorInput
  orderBy: SideCommentCacheOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSideCommentCacheOutput {
  result: SideCommentCache
}

type MultiSideCommentCacheOutput {
  results: [SideCommentCache]
  totalCount: Int
}

type SideCommentCacheOutput {
  data: SideCommentCache
}

input CreateSideCommentCacheInput {
  data: CreateSideCommentCacheDataInput!
}

input CreateSideCommentCacheDataInput {
  legacyData: JSON
}

input UpdateSideCommentCacheInput {
  selector: SideCommentCacheSelectorUniqueInput!
  data: UpdateSideCommentCacheDataInput!
}

input UpsertSideCommentCacheInput {
  selector: SideCommentCacheSelectorUniqueInput!
  data: UpdateSideCommentCacheDataInput!
}

input UpdateSideCommentCacheDataInput {
  legacyData: JSON
}

input SideCommentCacheSelectorInput {
  AND: [SideCommentCacheSelectorInput]
  OR: [SideCommentCacheSelectorInput]
}

input SideCommentCacheSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SideCommentCacheOrderByInput {
  foobar
}

type SplashArtCoordinate {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  reviewWinnerArtId: String
  reviewWinnerArt: ReviewWinnerArt
  leftXPct: Float
  leftYPct: Float
  leftHeightPct: Float
  leftWidthPct: Float
  leftFlipped: Boolean
  middleXPct: Float
  middleYPct: Float
  middleHeightPct: Float
  middleWidthPct: Float
  middleFlipped: Boolean
  rightXPct: Float
  rightYPct: Float
  rightHeightPct: Float
  rightWidthPct: Float
  rightFlipped: Boolean
}

input DeleteSplashArtCoordinateInput {
  selector: SplashArtCoordinateSelectorUniqueInput!
}

input SingleSplashArtCoordinateInput {
  selector: SplashArtCoordinateSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSplashArtCoordinateInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SplashArtCoordinateSelectorInput
  orderBy: SplashArtCoordinateOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSplashArtCoordinateOutput {
  result: SplashArtCoordinate
}

type MultiSplashArtCoordinateOutput {
  results: [SplashArtCoordinate]
  totalCount: Int
}

type SplashArtCoordinateOutput {
  data: SplashArtCoordinate
}

input CreateSplashArtCoordinateInput {
  data: CreateSplashArtCoordinateDataInput!
}

input CreateSplashArtCoordinateDataInput {
  legacyData: JSON
  reviewWinnerArtId: String!
  leftXPct: Float!
  leftYPct: Float!
  leftHeightPct: Float!
  leftWidthPct: Float!
  leftFlipped: Boolean
  middleXPct: Float!
  middleYPct: Float!
  middleHeightPct: Float!
  middleWidthPct: Float!
  middleFlipped: Boolean
  rightXPct: Float!
  rightYPct: Float!
  rightHeightPct: Float!
  rightWidthPct: Float!
  rightFlipped: Boolean!
}

input UpdateSplashArtCoordinateInput {
  selector: SplashArtCoordinateSelectorUniqueInput!
  data: UpdateSplashArtCoordinateDataInput!
}

input UpsertSplashArtCoordinateInput {
  selector: SplashArtCoordinateSelectorUniqueInput!
  data: UpdateSplashArtCoordinateDataInput!
}

input UpdateSplashArtCoordinateDataInput {
  legacyData: JSON
  reviewWinnerArtId: String
  leftXPct: Float
  leftYPct: Float
  leftHeightPct: Float
  leftWidthPct: Float
  leftFlipped: Boolean
  middleXPct: Float
  middleYPct: Float
  middleHeightPct: Float
  middleWidthPct: Float
  middleFlipped: Boolean
  rightXPct: Float
  rightYPct: Float
  rightHeightPct: Float
  rightWidthPct: Float
  rightFlipped: Boolean
}

input SplashArtCoordinateSelectorInput {
  AND: [SplashArtCoordinateSelectorInput]
  OR: [SplashArtCoordinateSelectorInput]
}

input SplashArtCoordinateSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SplashArtCoordinateOrderByInput {
  foobar
}

type Spotlight {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  description(version: String): Revision
  description_latest: String
  documentId: String
  document: Post
  post: Post
  sequence: Sequence
  tag: Tag
  documentType: String
  position: Float
  duration: Float
  customTitle: String
  customSubtitle: String
  subtitleUrl: String
  headerTitle: String
  headerTitleLeftColor: String
  headerTitleRightColor: String
  lastPromotedAt: Date
  spotlightSplashImageUrl: String
  draft: Boolean
  deletedDraft: Boolean
  showAuthor: Boolean
  imageFade: Boolean
  imageFadeColor: String
  spotlightImageId: String
  spotlightDarkImageId: String
  sequenceChapters: [Chapter]
}

input DeleteSpotlightInput {
  selector: SpotlightSelectorUniqueInput!
}

input SingleSpotlightInput {
  selector: SpotlightSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSpotlightInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SpotlightSelectorInput
  orderBy: SpotlightOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSpotlightOutput {
  result: Spotlight
}

type MultiSpotlightOutput {
  results: [Spotlight]
  totalCount: Int
}

type SpotlightOutput {
  data: Spotlight
}

input CreateSpotlightInput {
  data: CreateSpotlightDataInput!
}

input CreateSpotlightDataInput {
  legacyData: JSON
  description: JSON
  documentId: String!
  documentType: String!
  position: Float
  duration: Float!
  customTitle: String
  customSubtitle: String
  subtitleUrl: String
  headerTitle: String
  headerTitleLeftColor: String
  headerTitleRightColor: String
  lastPromotedAt: Date!
  spotlightSplashImageUrl: String
  draft: Boolean!
  showAuthor: Boolean
  imageFade: Boolean
  imageFadeColor: String
  spotlightImageId: String
  spotlightDarkImageId: String
}

input UpdateSpotlightInput {
  selector: SpotlightSelectorUniqueInput!
  data: UpdateSpotlightDataInput!
}

input UpsertSpotlightInput {
  selector: SpotlightSelectorUniqueInput!
  data: UpdateSpotlightDataInput!
}

input UpdateSpotlightDataInput {
  legacyData: JSON
  description: JSON
  documentId: String
  documentType: String
  position: Float
  duration: Float
  customTitle: String
  customSubtitle: String
  subtitleUrl: String
  headerTitle: String
  headerTitleLeftColor: String
  headerTitleRightColor: String
  lastPromotedAt: Date
  spotlightSplashImageUrl: String
  draft: Boolean
  deletedDraft: Boolean
  showAuthor: Boolean
  imageFade: Boolean
  imageFadeColor: String
  spotlightImageId: String
  spotlightDarkImageId: String
}

input SpotlightSelectorInput {
  AND: [SpotlightSelectorInput]
  OR: [SpotlightSelectorInput]
}

input SpotlightSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SpotlightOrderByInput {
  foobar
}

type Subscription {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  state: String
  documentId: String
  collectionName: String
  deleted: Boolean
  type: String
}

input DeleteSubscriptionInput {
  selector: SubscriptionSelectorUniqueInput!
}

input SingleSubscriptionInput {
  selector: SubscriptionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSubscriptionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SubscriptionSelectorInput
  orderBy: SubscriptionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSubscriptionOutput {
  result: Subscription
}

type MultiSubscriptionOutput {
  results: [Subscription]
  totalCount: Int
}

type SubscriptionOutput {
  data: Subscription
}

input CreateSubscriptionInput {
  data: CreateSubscriptionDataInput!
}

input CreateSubscriptionDataInput {
  legacyData: JSON
  state: String!
  documentId: String!
  collectionName: String!
  type: String!
}

input UpdateSubscriptionInput {
  selector: SubscriptionSelectorUniqueInput!
  data: UpdateSubscriptionDataInput!
}

input UpsertSubscriptionInput {
  selector: SubscriptionSelectorUniqueInput!
  data: UpdateSubscriptionDataInput!
}

input UpdateSubscriptionDataInput {
  legacyData: JSON
}

input SubscriptionSelectorInput {
  AND: [SubscriptionSelectorInput]
  OR: [SubscriptionSelectorInput]
}

input SubscriptionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SubscriptionOrderByInput {
  foobar
}

type SurveyQuestion {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  surveyId: String
  survey: Survey!
  question: String
  format: String
  order: Float
}

input DeleteSurveyQuestionInput {
  selector: SurveyQuestionSelectorUniqueInput!
}

input SingleSurveyQuestionInput {
  selector: SurveyQuestionSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSurveyQuestionInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SurveyQuestionSelectorInput
  orderBy: SurveyQuestionOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSurveyQuestionOutput {
  result: SurveyQuestion
}

type MultiSurveyQuestionOutput {
  results: [SurveyQuestion]
  totalCount: Int
}

type SurveyQuestionOutput {
  data: SurveyQuestion
}

input CreateSurveyQuestionInput {
  data: CreateSurveyQuestionDataInput!
}

input CreateSurveyQuestionDataInput {
  legacyData: JSON
  surveyId: String!
  question: String!
  format: String!
  order: Float!
}

input UpdateSurveyQuestionInput {
  selector: SurveyQuestionSelectorUniqueInput!
  data: UpdateSurveyQuestionDataInput!
}

input UpsertSurveyQuestionInput {
  selector: SurveyQuestionSelectorUniqueInput!
  data: UpdateSurveyQuestionDataInput!
}

input UpdateSurveyQuestionDataInput {
  legacyData: JSON
  surveyId: String
  question: String
  format: String
  order: Float
}

input SurveyQuestionSelectorInput {
  AND: [SurveyQuestionSelectorInput]
  OR: [SurveyQuestionSelectorInput]
}

input SurveyQuestionSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SurveyQuestionOrderByInput {
  foobar
}

type SurveyResponse {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  surveyId: String
  survey: Survey
  surveyScheduleId: String
  surveySchedule: SurveySchedule
  userId: String
  user: User
  clientId: String
  client: ClientId
  response: JSON
}

input DeleteSurveyResponseInput {
  selector: SurveyResponseSelectorUniqueInput!
}

input SingleSurveyResponseInput {
  selector: SurveyResponseSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSurveyResponseInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SurveyResponseSelectorInput
  orderBy: SurveyResponseOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSurveyResponseOutput {
  result: SurveyResponse
}

type MultiSurveyResponseOutput {
  results: [SurveyResponse]
  totalCount: Int
}

type SurveyResponseOutput {
  data: SurveyResponse
}

input CreateSurveyResponseInput {
  data: CreateSurveyResponseDataInput!
}

input CreateSurveyResponseDataInput {
  legacyData: JSON
  surveyId: String!
  surveyScheduleId: String!
  userId: String!
  clientId: String!
  response: JSON!
}

input UpdateSurveyResponseInput {
  selector: SurveyResponseSelectorUniqueInput!
  data: UpdateSurveyResponseDataInput!
}

input UpsertSurveyResponseInput {
  selector: SurveyResponseSelectorUniqueInput!
  data: UpdateSurveyResponseDataInput!
}

input UpdateSurveyResponseDataInput {
  legacyData: JSON
  surveyId: String
  surveyScheduleId: String
  userId: String
  clientId: String
  response: JSON
}

input SurveyResponseSelectorInput {
  AND: [SurveyResponseSelectorInput]
  OR: [SurveyResponseSelectorInput]
}

input SurveyResponseSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SurveyResponseOrderByInput {
  foobar
}

type SurveySchedule {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  surveyId: String
  survey: Survey!
  name: String
  impressionsLimit: Float
  maxVisitorPercentage: Float
  minKarma: Float
  maxKarma: Float
  target: String
  startDate: Date
  endDate: Date
  deactivated: Boolean
  clientIds: [String]
  clients: [ClientId!]
}

input DeleteSurveyScheduleInput {
  selector: SurveyScheduleSelectorUniqueInput!
}

input SingleSurveyScheduleInput {
  selector: SurveyScheduleSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSurveyScheduleInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SurveyScheduleSelectorInput
  orderBy: SurveyScheduleOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSurveyScheduleOutput {
  result: SurveySchedule
}

type MultiSurveyScheduleOutput {
  results: [SurveySchedule]
  totalCount: Int
}

type SurveyScheduleOutput {
  data: SurveySchedule
}

input CreateSurveyScheduleInput {
  data: CreateSurveyScheduleDataInput!
}

input CreateSurveyScheduleDataInput {
  legacyData: JSON
  surveyId: String!
  name: String!
  impressionsLimit: Float
  maxVisitorPercentage: Float
  minKarma: Float
  maxKarma: Float
  target: String!
  startDate: Date
  endDate: Date
  deactivated: Boolean
  clientIds: [String]!
}

input UpdateSurveyScheduleInput {
  selector: SurveyScheduleSelectorUniqueInput!
  data: UpdateSurveyScheduleDataInput!
}

input UpsertSurveyScheduleInput {
  selector: SurveyScheduleSelectorUniqueInput!
  data: UpdateSurveyScheduleDataInput!
}

input UpdateSurveyScheduleDataInput {
  legacyData: JSON
  surveyId: String
  name: String
  impressionsLimit: Float
  maxVisitorPercentage: Float
  minKarma: Float
  maxKarma: Float
  target: String
  startDate: Date
  endDate: Date
  deactivated: Boolean
  clientIds: [String]
}

input SurveyScheduleSelectorInput {
  AND: [SurveyScheduleSelectorInput]
  OR: [SurveyScheduleSelectorInput]
}

input SurveyScheduleSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SurveyScheduleOrderByInput {
  foobar
}

type Survey {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  name: String
  questions: [SurveyQuestion!]!
}

input DeleteSurveyInput {
  selector: SurveySelectorUniqueInput!
}

input SingleSurveyInput {
  selector: SurveySelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiSurveyInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: SurveySelectorInput
  orderBy: SurveyOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSurveyOutput {
  result: Survey
}

type MultiSurveyOutput {
  results: [Survey]
  totalCount: Int
}

type SurveyOutput {
  data: Survey
}

input CreateSurveyInput {
  data: CreateSurveyDataInput!
}

input CreateSurveyDataInput {
  legacyData: JSON
  name: String!
}

input UpdateSurveyInput {
  selector: SurveySelectorUniqueInput!
  data: UpdateSurveyDataInput!
}

input UpsertSurveyInput {
  selector: SurveySelectorUniqueInput!
  data: UpdateSurveyDataInput!
}

input UpdateSurveyDataInput {
  legacyData: JSON
  name: String
}

input SurveySelectorInput {
  AND: [SurveySelectorInput]
  OR: [SurveySelectorInput]
}

input SurveySelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum SurveyOrderByInput {
  foobar
}

type TagFlag {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  contents(version: String): Revision
  contents_latest: String
  slug: String
  name: String
  deleted: Boolean
  order: Float
}

input DeleteTagFlagInput {
  selector: TagFlagSelectorUniqueInput!
}

input SingleTagFlagInput {
  selector: TagFlagSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiTagFlagInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: TagFlagSelectorInput
  orderBy: TagFlagOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTagFlagOutput {
  result: TagFlag
}

type MultiTagFlagOutput {
  results: [TagFlag]
  totalCount: Int
}

type TagFlagOutput {
  data: TagFlag
}

input CreateTagFlagInput {
  data: CreateTagFlagDataInput!
}

input CreateTagFlagDataInput {
  legacyData: JSON
  contents: JSON
  name: String!
  deleted: Boolean
  order: Float
}

input UpdateTagFlagInput {
  selector: TagFlagSelectorUniqueInput!
  data: UpdateTagFlagDataInput!
}

input UpsertTagFlagInput {
  selector: TagFlagSelectorUniqueInput!
  data: UpdateTagFlagDataInput!
}

input UpdateTagFlagDataInput {
  legacyData: JSON
  contents: JSON
  name: String
  deleted: Boolean
  order: Float
}

input TagFlagSelectorInput {
  AND: [TagFlagSelectorInput]
  OR: [TagFlagSelectorInput]
}

input TagFlagSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum TagFlagOrderByInput {
  foobar
}

type TagRel {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  tagId: String
  tag: Tag
  postId: String
  post: Post
  deleted: Boolean
  userId: String
  user: User
  currentUserCanVote: Boolean!
  autoApplied: Boolean!
  backfilled: Boolean
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float
  baseScore: Float
  extendedScore: JSON
  score: Float
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input DeleteTagRelInput {
  selector: TagRelSelectorUniqueInput!
}

input SingleTagRelInput {
  selector: TagRelSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiTagRelInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: TagRelSelectorInput
  orderBy: TagRelOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTagRelOutput {
  result: TagRel
}

type MultiTagRelOutput {
  results: [TagRel]
  totalCount: Int
}

type TagRelOutput {
  data: TagRel
}

input CreateTagRelInput {
  data: CreateTagRelDataInput!
}

input CreateTagRelDataInput {
  legacyData: JSON
  tagId: String!
  postId: String!
  userId: String!
}

input UpdateTagRelInput {
  selector: TagRelSelectorUniqueInput!
  data: UpdateTagRelDataInput!
}

input UpsertTagRelInput {
  selector: TagRelSelectorUniqueInput!
  data: UpdateTagRelDataInput!
}

input UpdateTagRelDataInput {
  legacyData: JSON
  deleted: Boolean
}

input TagRelSelectorInput {
  AND: [TagRelSelectorInput]
  OR: [TagRelSelectorInput]
}

input TagRelSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum TagRelOrderByInput {
  foobar
}

type Tag {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  description(version: String): Revision
  description_latest: String
  pingbacks: JSON
  subforumWelcomeText(version: String): Revision
  subforumWelcomeText_latest: String
  moderationGuidelines(version: String): Revision
  moderationGuidelines_latest: String
  slug: String
  oldSlugs: [String]
  name: String
  shortName: String
  subtitle: String
  core: Boolean
  isPostType: Boolean
  suggestedAsFilter: Boolean
  defaultOrder: Float
  descriptionTruncationCount: Float
  postCount: Float
  userId: String
  user: User
  adminOnly: Boolean
  canEditUserIds: [String]
  charsAdded: Float
  charsRemoved: Float
  deleted: Boolean
  lastCommentedAt: Date
  lastSubforumCommentAt: Date
  needsReview: Boolean
  reviewedByUserId: String
  reviewedByUser: User
  wikiGrade: Int
  recentComments(tagCommentsLimit: Int, maxAgeHours: Int, af: Boolean, tagCommentType: String): [Comment]
  wikiOnly: Boolean
  bannerImageId: String
  squareImageId: String
  tagFlagsIds: [String]
  tagFlags: [TagFlag!]!
  lesswrongWikiImportRevision: String
  lesswrongWikiImportSlug: String
  lesswrongWikiImportCompleted: Boolean
  lastVisitedAt: Date
  isRead: Boolean
  tableOfContents(version: String): JSON
  htmlWithContributorAnnotations: String
  contributors(limit: Int, version: String): TagContributorsList
  contributionStats: JSON
  introSequenceId: String
  sequence: Sequence
  postsDefaultSortOrder: String
  canVoteOnRels: [String]
  isSubforum: Boolean
  subforumUnreadMessagesCount: Int
  subforumModeratorIds: [String]
  subforumModerators: [User!]!
  subforumIntroPostId: String
  subforumIntroPost: Post
  parentTagId: String
  parentTag: Tag
  subTagIds: [String]
  subTags: [Tag!]!
  autoTagModel: String
  autoTagPrompt: String
  noindex: Boolean
  lenses(lensSlug: String, version: String): [MultiDocument!]!
  lensesIncludingDeleted(lensSlug: String, version: String): [MultiDocument!]!
  isPlaceholderPage: Boolean
  summaries: [MultiDocument!]!
  textLastUpdatedAt: Date
  isArbitalImport: Boolean
  arbitalLinkedPages: ArbitalLinkedPages
  coreTagId: String
  maxScore: Int
  usersWhoLiked: [UserLikingTag!]!
  forceAllowType3Audio: Boolean
  currentUserVote: String
  currentUserExtendedVote: JSON
  voteCount: Float
  baseScore: Float
  extendedScore: JSON
  score: Float
  afBaseScore: Float
  afExtendedScore: JSON
  afVoteCount: Float
}

input DeleteTagInput {
  selector: TagSelectorUniqueInput!
}

input SingleTagInput {
  selector: TagSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiTagInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: TagSelectorInput
  orderBy: TagOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTagOutput {
  result: Tag
}

type MultiTagOutput {
  results: [Tag]
  totalCount: Int
}

type TagOutput {
  data: Tag
}

input CreateTagInput {
  data: CreateTagDataInput!
}

input CreateTagDataInput {
  legacyData: JSON
  description: JSON
  subforumWelcomeText: JSON
  moderationGuidelines: JSON
  slug: String
  name: String!
  shortName: String
  subtitle: String
  core: Boolean
  isPostType: Boolean
  suggestedAsFilter: Boolean
  defaultOrder: Float
  descriptionTruncationCount: Float
  adminOnly: Boolean
  canEditUserIds: [String]
  reviewedByUserId: String
  wikiGrade: Int
  wikiOnly: Boolean
  bannerImageId: String
  squareImageId: String
  tagFlagsIds: [String]
  introSequenceId: String
  postsDefaultSortOrder: String
  canVoteOnRels: [String]
  isSubforum: Boolean
  subforumModeratorIds: [String]
  subforumIntroPostId: String
  parentTagId: String
  subTagIds: [String]
  autoTagModel: String
  autoTagPrompt: String
  coreTagId: String
  forceAllowType3Audio: Boolean
}

input UpdateTagInput {
  selector: TagSelectorUniqueInput!
  data: UpdateTagDataInput!
}

input UpsertTagInput {
  selector: TagSelectorUniqueInput!
  data: UpdateTagDataInput!
}

input UpdateTagDataInput {
  legacyData: JSON
  description: JSON
  subforumWelcomeText: JSON
  moderationGuidelines: JSON
  slug: String
  name: String
  shortName: String
  subtitle: String
  core: Boolean
  isPostType: Boolean
  suggestedAsFilter: Boolean
  defaultOrder: Float
  descriptionTruncationCount: Float
  adminOnly: Boolean
  canEditUserIds: [String]
  deleted: Boolean
  needsReview: Boolean
  reviewedByUserId: String
  wikiGrade: Int
  wikiOnly: Boolean
  bannerImageId: String
  squareImageId: String
  tagFlagsIds: [String]
  introSequenceId: String
  postsDefaultSortOrder: String
  canVoteOnRels: [String]
  isSubforum: Boolean
  subforumModeratorIds: [String]
  subforumIntroPostId: String
  parentTagId: String
  subTagIds: [String]
  autoTagModel: String
  autoTagPrompt: String
  noindex: Boolean
  isPlaceholderPage: Boolean
  coreTagId: String
  forceAllowType3Audio: Boolean
}

input TagSelectorInput {
  AND: [TagSelectorInput]
  OR: [TagSelectorInput]
}

input TagSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum TagOrderByInput {
  foobar
}

type Tweet {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteTweetInput {
  selector: TweetSelectorUniqueInput!
}

input SingleTweetInput {
  selector: TweetSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiTweetInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: TweetSelectorInput
  orderBy: TweetOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTweetOutput {
  result: Tweet
}

type MultiTweetOutput {
  results: [Tweet]
  totalCount: Int
}

type TweetOutput {
  data: Tweet
}

input CreateTweetInput {
  data: CreateTweetDataInput!
}

input CreateTweetDataInput {
  legacyData: JSON
}

input UpdateTweetInput {
  selector: TweetSelectorUniqueInput!
  data: UpdateTweetDataInput!
}

input UpsertTweetInput {
  selector: TweetSelectorUniqueInput!
  data: UpdateTweetDataInput!
}

input UpdateTweetDataInput {
  legacyData: JSON
}

input TweetSelectorInput {
  AND: [TweetSelectorInput]
  OR: [TweetSelectorInput]
}

input TweetSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum TweetOrderByInput {
  foobar
}

type TypingIndicator {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  documentId: String
  lastUpdated: Date
}

input DeleteTypingIndicatorInput {
  selector: TypingIndicatorSelectorUniqueInput!
}

input SingleTypingIndicatorInput {
  selector: TypingIndicatorSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiTypingIndicatorInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: TypingIndicatorSelectorInput
  orderBy: TypingIndicatorOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleTypingIndicatorOutput {
  result: TypingIndicator
}

type MultiTypingIndicatorOutput {
  results: [TypingIndicator]
  totalCount: Int
}

type TypingIndicatorOutput {
  data: TypingIndicator
}

input CreateTypingIndicatorInput {
  data: CreateTypingIndicatorDataInput!
}

input CreateTypingIndicatorDataInput {
  legacyData: JSON
  userId: String!
  documentId: String!
  lastUpdated: Date!
}

input UpdateTypingIndicatorInput {
  selector: TypingIndicatorSelectorUniqueInput!
  data: UpdateTypingIndicatorDataInput!
}

input UpsertTypingIndicatorInput {
  selector: TypingIndicatorSelectorUniqueInput!
  data: UpdateTypingIndicatorDataInput!
}

input UpdateTypingIndicatorDataInput {
  legacyData: JSON
  lastUpdated: Date
}

input TypingIndicatorSelectorInput {
  AND: [TypingIndicatorSelectorInput]
  OR: [TypingIndicatorSelectorInput]
}

input TypingIndicatorSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum TypingIndicatorOrderByInput {
  foobar
}

type UserActivity {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
}

input DeleteUserActivityInput {
  selector: UserActivitySelectorUniqueInput!
}

input SingleUserActivityInput {
  selector: UserActivitySelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiUserActivityInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: UserActivitySelectorInput
  orderBy: UserActivityOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserActivityOutput {
  result: UserActivity
}

type MultiUserActivityOutput {
  results: [UserActivity]
  totalCount: Int
}

type UserActivityOutput {
  data: UserActivity
}

input CreateUserActivityInput {
  data: CreateUserActivityDataInput!
}

input CreateUserActivityDataInput {
  legacyData: JSON
}

input UpdateUserActivityInput {
  selector: UserActivitySelectorUniqueInput!
  data: UpdateUserActivityDataInput!
}

input UpsertUserActivityInput {
  selector: UserActivitySelectorUniqueInput!
  data: UpdateUserActivityDataInput!
}

input UpdateUserActivityDataInput {
  legacyData: JSON
}

input UserActivitySelectorInput {
  AND: [UserActivitySelectorInput]
  OR: [UserActivitySelectorInput]
}

input UserActivitySelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum UserActivityOrderByInput {
  foobar
}

type UserEAGDetail {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  careerStage: [String]
  countryOrRegion: String
  nearestCity: String
  willingnessToRelocate: JSON
  experiencedIn: [String]
  interestedIn: [String]
  lastUpdated: Date
}

input DeleteUserEAGDetailInput {
  selector: UserEAGDetailSelectorUniqueInput!
}

input SingleUserEAGDetailInput {
  selector: UserEAGDetailSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiUserEAGDetailInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: UserEAGDetailSelectorInput
  orderBy: UserEAGDetailOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserEAGDetailOutput {
  result: UserEAGDetail
}

type MultiUserEAGDetailOutput {
  results: [UserEAGDetail]
  totalCount: Int
}

type UserEAGDetailOutput {
  data: UserEAGDetail
}

input CreateUserEAGDetailInput {
  data: CreateUserEAGDetailDataInput!
}

input CreateUserEAGDetailDataInput {
  legacyData: JSON
  lastUpdated: Date
}

input UpdateUserEAGDetailInput {
  selector: UserEAGDetailSelectorUniqueInput!
  data: UpdateUserEAGDetailDataInput!
}

input UpsertUserEAGDetailInput {
  selector: UserEAGDetailSelectorUniqueInput!
  data: UpdateUserEAGDetailDataInput!
}

input UpdateUserEAGDetailDataInput {
  legacyData: JSON
  careerStage: [String]
  countryOrRegion: String
  nearestCity: String
  willingnessToRelocate: JSON
  experiencedIn: [String]
  interestedIn: [String]
  lastUpdated: Date
}

input UserEAGDetailSelectorInput {
  AND: [UserEAGDetailSelectorInput]
  OR: [UserEAGDetailSelectorInput]
}

input UserEAGDetailSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum UserEAGDetailOrderByInput {
  foobar
}

type UserJobAd {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  jobName: String
  adState: String
  reminderSetAt: Date
  lastUpdated: Date
}

input DeleteUserJobAdInput {
  selector: UserJobAdSelectorUniqueInput!
}

input SingleUserJobAdInput {
  selector: UserJobAdSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiUserJobAdInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: UserJobAdSelectorInput
  orderBy: UserJobAdOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserJobAdOutput {
  result: UserJobAd
}

type MultiUserJobAdOutput {
  results: [UserJobAd]
  totalCount: Int
}

type UserJobAdOutput {
  data: UserJobAd
}

input CreateUserJobAdInput {
  data: CreateUserJobAdDataInput!
}

input CreateUserJobAdDataInput {
  legacyData: JSON
  userId: String!
  jobName: String!
  adState: String!
  reminderSetAt: Date
  lastUpdated: Date
}

input UpdateUserJobAdInput {
  selector: UserJobAdSelectorUniqueInput!
  data: UpdateUserJobAdDataInput!
}

input UpsertUserJobAdInput {
  selector: UserJobAdSelectorUniqueInput!
  data: UpdateUserJobAdDataInput!
}

input UpdateUserJobAdDataInput {
  legacyData: JSON
  adState: String
  reminderSetAt: Date
  lastUpdated: Date
}

input UserJobAdSelectorInput {
  AND: [UserJobAdSelectorInput]
  OR: [UserJobAdSelectorInput]
}

input UserJobAdSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum UserJobAdOrderByInput {
  foobar
}

type UserMostValuablePost {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  postId: String
  post: Post
  deleted: Boolean
}

input DeleteUserMostValuablePostInput {
  selector: UserMostValuablePostSelectorUniqueInput!
}

input SingleUserMostValuablePostInput {
  selector: UserMostValuablePostSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiUserMostValuablePostInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: UserMostValuablePostSelectorInput
  orderBy: UserMostValuablePostOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserMostValuablePostOutput {
  result: UserMostValuablePost
}

type MultiUserMostValuablePostOutput {
  results: [UserMostValuablePost]
  totalCount: Int
}

type UserMostValuablePostOutput {
  data: UserMostValuablePost
}

input CreateUserMostValuablePostInput {
  data: CreateUserMostValuablePostDataInput!
}

input CreateUserMostValuablePostDataInput {
  legacyData: JSON
  userId: String!
  postId: String!
  deleted: Boolean
}

input UpdateUserMostValuablePostInput {
  selector: UserMostValuablePostSelectorUniqueInput!
  data: UpdateUserMostValuablePostDataInput!
}

input UpsertUserMostValuablePostInput {
  selector: UserMostValuablePostSelectorUniqueInput!
  data: UpdateUserMostValuablePostDataInput!
}

input UpdateUserMostValuablePostDataInput {
  legacyData: JSON
  userId: String
  postId: String
  deleted: Boolean
}

input UserMostValuablePostSelectorInput {
  AND: [UserMostValuablePostSelectorInput]
  OR: [UserMostValuablePostSelectorInput]
}

input UserMostValuablePostSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum UserMostValuablePostOrderByInput {
  foobar
}

type UserRateLimit {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  userId: String
  user: User
  type: String
  intervalUnit: String
  intervalLength: Float
  actionsPerInterval: Float
  endedAt: Date
}

input DeleteUserRateLimitInput {
  selector: UserRateLimitSelectorUniqueInput!
}

input SingleUserRateLimitInput {
  selector: UserRateLimitSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiUserRateLimitInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: UserRateLimitSelectorInput
  orderBy: UserRateLimitOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserRateLimitOutput {
  result: UserRateLimit
}

type MultiUserRateLimitOutput {
  results: [UserRateLimit]
  totalCount: Int
}

type UserRateLimitOutput {
  data: UserRateLimit
}

input CreateUserRateLimitInput {
  data: CreateUserRateLimitDataInput!
}

input CreateUserRateLimitDataInput {
  legacyData: JSON
  userId: String!
  type: String!
  intervalUnit: String!
  intervalLength: Float!
  actionsPerInterval: Float!
  endedAt: Date
}

input UpdateUserRateLimitInput {
  selector: UserRateLimitSelectorUniqueInput!
  data: UpdateUserRateLimitDataInput!
}

input UpsertUserRateLimitInput {
  selector: UserRateLimitSelectorUniqueInput!
  data: UpdateUserRateLimitDataInput!
}

input UpdateUserRateLimitDataInput {
  legacyData: JSON
  userId: String
  type: String
  intervalUnit: String
  intervalLength: Float
  actionsPerInterval: Float
  endedAt: Date
}

input UserRateLimitSelectorInput {
  AND: [UserRateLimitSelectorInput]
  OR: [UserRateLimitSelectorInput]
}

input UserRateLimitSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum UserRateLimitOrderByInput {
  foobar
}

type UserTagRel {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  tagId: String
  tag: Tag
  userId: String
  user: User
  subforumShowUnreadInSidebar: Boolean
  subforumEmailNotifications: Boolean
  subforumHideIntroPost: Boolean
}

input DeleteUserTagRelInput {
  selector: UserTagRelSelectorUniqueInput!
}

input SingleUserTagRelInput {
  selector: UserTagRelSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiUserTagRelInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: UserTagRelSelectorInput
  orderBy: UserTagRelOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserTagRelOutput {
  result: UserTagRel
}

type MultiUserTagRelOutput {
  results: [UserTagRel]
  totalCount: Int
}

type UserTagRelOutput {
  data: UserTagRel
}

input CreateUserTagRelInput {
  data: CreateUserTagRelDataInput!
}

input CreateUserTagRelDataInput {
  legacyData: JSON
  tagId: String!
  userId: String!
  subforumShowUnreadInSidebar: Boolean
  subforumEmailNotifications: Boolean
  subforumHideIntroPost: Boolean
}

input UpdateUserTagRelInput {
  selector: UserTagRelSelectorUniqueInput!
  data: UpdateUserTagRelDataInput!
}

input UpsertUserTagRelInput {
  selector: UserTagRelSelectorUniqueInput!
  data: UpdateUserTagRelDataInput!
}

input UpdateUserTagRelDataInput {
  legacyData: JSON
  subforumShowUnreadInSidebar: Boolean
  subforumEmailNotifications: Boolean
  subforumHideIntroPost: Boolean
}

input UserTagRelSelectorInput {
  AND: [UserTagRelSelectorInput]
  OR: [UserTagRelSelectorInput]
}

input UserTagRelSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum UserTagRelOrderByInput {
  foobar
}

type User {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  moderationGuidelines(version: String): Revision
  moderationGuidelines_latest: String
  howOthersCanHelpMe(version: String): Revision
  howOthersCanHelpMe_latest: String
  howICanHelpOthers(version: String): Revision
  howICanHelpOthers_latest: String
  slug: String
  oldSlugs: [String]
  biography(version: String): Revision
  biography_latest: String
  username: String
  emails: [JSON]
  isAdmin: Boolean
  services: JSON
  hasAuth0Id: Boolean
  displayName: String
  previousDisplayName: String
  email: String
  noindex: Boolean
  groups: [String]
  pageUrl: String
  pagePath: String
  editUrl: String
  lwWikiImport: Boolean
  theme: JSON
  lastUsedTimezone: String
  whenConfirmationEmailSent: Date
  legacy: Boolean
  commentSorting: String
  sortDraftsBy: String
  reactPaletteStyle: String
  noKibitz: Boolean
  showHideKarmaOption: Boolean
  showPostAuthorCard: Boolean
  hideIntercom: Boolean
  markDownPostEditor: Boolean
  hideElicitPredictions: Boolean
  hideAFNonMemberInitialWarning: Boolean
  noSingleLineComments: Boolean
  noCollapseCommentsPosts: Boolean
  noCollapseCommentsFrontpage: Boolean
  hideCommunitySection: Boolean
  expandedFrontpageSections: JSON
  showCommunityInRecentDiscussion: Boolean
  hidePostsRecommendations: Boolean
  petrovOptOut: Boolean
  optedOutOfSurveys: Boolean
  postGlossariesPinned: Boolean
  generateJargonForDrafts: Boolean
  generateJargonForPublishedPosts: Boolean
  acceptedTos: Boolean
  hideNavigationSidebar: Boolean
  currentFrontpageFilter: String
  frontpageSelectedTab: String
  frontpageFilterSettings: JSON
  hideFrontpageFilterSettingsDesktop: Boolean
  allPostsTimeframe: String
  allPostsFilter: String
  allPostsSorting: String
  allPostsShowLowKarma: Boolean
  allPostsIncludeEvents: Boolean
  allPostsHideCommunity: Boolean
  allPostsOpenSettings: Boolean
  draftsListSorting: String
  draftsListShowArchived: Boolean
  draftsListShowShared: Boolean
  lastNotificationsCheck: Date
  karma: Float
  goodHeartTokens: Float
  moderationStyle: String
  moderatorAssistance: Boolean
  collapseModerationGuidelines: Boolean
  bannedUserIds: [String]
  bannedPersonalUserIds: [String]
  bookmarkedPostsMetadata: [JSON]
  bookmarkedPosts: [Post!]
  hiddenPostsMetadata: [JSON]
  hiddenPosts: [Post!]
  legacyId: String
  deleted: Boolean
  permanentDeletionRequestedAt: Date
  voteBanned: Boolean
  nullifyVotes: Boolean
  deleteContent: Boolean
  banned: Date
  IPs: [String!]
  auto_subscribe_to_my_posts: Boolean
  auto_subscribe_to_my_comments: Boolean
  autoSubscribeAsOrganizer: Boolean
  notificationCommentsOnSubscribedPost: JSON
  notificationShortformContent: JSON
  notificationRepliesToMyComments: JSON
  notificationRepliesToSubscribedComments: JSON
  notificationSubscribedUserPost: JSON
  notificationSubscribedUserComment: JSON
  notificationPostsInGroups: JSON
  notificationSubscribedTagPost: JSON
  notificationSubscribedSequencePost: JSON
  notificationPrivateMessage: JSON
  notificationSharedWithMe: JSON
  notificationAlignmentSubmissionApproved: JSON
  notificationEventInRadius: JSON
  notificationKarmaPowersGained: JSON
  notificationRSVPs: JSON
  notificationGroupAdministration: JSON
  notificationCommentsOnDraft: JSON
  notificationPostsNominatedReview: JSON
  notificationSubforumUnread: JSON
  notificationNewMention: JSON
  notificationDialogueMessages: JSON
  notificationPublishedDialogueMessages: JSON
  notificationAddedAsCoauthor: JSON
  notificationDebateCommentsOnSubscribedPost: JSON
  notificationDebateReplies: JSON
  notificationDialogueMatch: JSON
  notificationNewDialogueChecks: JSON
  notificationYourTurnMatchForm: JSON
  hideDialogueFacilitation: Boolean
  revealChecksToAdmins: Boolean
  optedInToDialogueFacilitation: Boolean
  showDialoguesList: Boolean
  showMyDialogues: Boolean
  showMatches: Boolean
  showRecommendedPartners: Boolean
  hideActiveDialogueUsers: Boolean
  karmaChangeNotifierSettings: JSON
  karmaChangeLastOpened: Date
  karmaChangeBatchStart: Date
  emailSubscribedToCurated: Boolean
  subscribedToDigest: Boolean
  unsubscribeFromAll: Boolean
  hideSubscribePoke: Boolean
  hideMeetupsPoke: Boolean
  hideHomeRHS: Boolean
  frontpagePostCount: Float
  sequenceCount: Float
  sequenceDraftCount: Float
  mongoLocation: JSON
  googleLocation: JSON
  location: String
  mapLocation: JSON
  mapLocationLatLng: LatLng
  mapLocationSet: Boolean
  mapMarkerText: String
  htmlMapMarkerText: String
  nearbyEventsNotifications: Boolean
  nearbyEventsNotificationsLocation: JSON
  nearbyEventsNotificationsMongoLocation: JSON
  nearbyEventsNotificationsRadius: Float
  nearbyPeopleNotificationThreshold: Float
  hideFrontpageMap: Boolean
  hideTaggingProgressBar: Boolean
  hideFrontpageBookAd: Boolean
  hideFrontpageBook2019Ad: Boolean
  hideFrontpageBook2020Ad: Boolean
  sunshineNotes: String
  sunshineFlagged: Boolean
  needsReview: Boolean
  sunshineSnoozed: Boolean
  snoozedUntilContentCount: Float
  reviewedByUserId: String
  reviewedByUser: User
  isReviewed: Boolean
  reviewedAt: Date
  spamRiskScore: Float!
  afKarma: Float
  voteCount: Float
  smallUpvoteCount: Float
  smallDownvoteCount: Float
  bigUpvoteCount: Float
  bigDownvoteCount: Float
  voteReceivedCount: Float
  smallUpvoteReceivedCount: Float
  smallDownvoteReceivedCount: Float
  bigUpvoteReceivedCount: Float
  bigDownvoteReceivedCount: Float
  usersContactedBeforeReview: [String]
  fullName: String
  shortformFeedId: String
  shortformFeed: Post
  viewUnreviewedComments: Boolean
  partiallyReadSequences: [JSON]
  beta: Boolean
  reviewVotesQuadratic: Boolean
  reviewVotesQuadratic2019: Boolean
  reviewVoteCount: Int
  reviewVotesQuadratic2020: Boolean
  petrovPressedButtonDate: Date
  petrovLaunchCodeDate: Date
  defaultToCKEditor: Boolean
  signUpReCaptchaRating: Float
  noExpandUnreadCommentsReview: Boolean
  postCount: Float
  maxPostCount: Float
  posts(limit: Int = 5): [Post]
  commentCount: Float
  maxCommentCount: Float
  tagRevisionCount: Float
  abTestKey: String
  abTestOverrides: JSON
  reenableDraftJs: Boolean
  walledGardenInvite: Boolean
  hideWalledGardenUI: Boolean
  walledGardenPortalOnboarded: Boolean
  taggingDashboardCollapsed: Boolean
  usernameUnset: Boolean
  paymentEmail: String
  paymentInfo: String
  profileUpdatedAt: Date
  profileImageId: String
  jobTitle: String
  organization: String
  careerStage: [String]
  website: String
  bio: String
  htmlBio: String!
  fmCrosspostUserId: String
  linkedinProfileURL: String
  facebookProfileURL: String
  blueskyProfileURL: String
  twitterProfileURL: String
  twitterProfileURLAdmin: String
  githubProfileURL: String
  profileTagIds: [String]
  profileTags: [Tag!]!
  organizerOfGroupIds: [String]
  organizerOfGroups: [Localgroup!]!
  programParticipation: [String]
  postingDisabled: Boolean
  allCommentingDisabled: Boolean
  commentingOnOtherUsersDisabled: Boolean
  conversationsDisabled: Boolean
  associatedClientId: ClientId
  associatedClientIds: [ClientId!]
  altAccountsDetected: Boolean
  acknowledgedNewUserGuidelines: Boolean
  moderatorActions: [ModeratorAction]
  subforumPreferredLayout: String
  hideJobAdUntil: Date
  criticismTipsDismissed: Boolean
  hideFromPeopleDirectory: Boolean
  allowDatadogSessionReplay: Boolean
  afPostCount: Float
  afCommentCount: Float
  afSequenceCount: Float
  afSequenceDraftCount: Float
  reviewForAlignmentForumUserId: String
  afApplicationText: String
  afSubmittedApplication: Boolean
  rateLimitNextAbleToComment(postId: String): JSON
  rateLimitNextAbleToPost(eventForm: Boolean): JSON
  recentKarmaInfo: JSON
  hideSunshineSidebar: Boolean
  inactiveSurveyEmailSentAt: Date
  userSurveyEmailSentAt: Date
  karmaChanges(startDate: Date, endDate: Date): KarmaChanges
  recommendationSettings: JSON
}

input DeleteUserInput {
  selector: UserSelectorUniqueInput!
}

input SingleUserInput {
  selector: UserSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiUserInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: UserSelectorInput
  orderBy: UserOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserOutput {
  result: User
}

type MultiUserOutput {
  results: [User]
  totalCount: Int
}

type UserOutput {
  data: User
}

input CreateUserInput {
  data: CreateUserDataInput!
}

input CreateUserDataInput {
  legacyData: JSON
  moderationGuidelines: JSON
  howOthersCanHelpMe: JSON
  howICanHelpOthers: JSON
  biography: JSON
  username: String
  isAdmin: Boolean
  displayName: String
  previousDisplayName: String
  email: String
  groups: [String]
  theme: JSON
  lastUsedTimezone: String
  whenConfirmationEmailSent: Date
  legacy: Boolean
  commentSorting: String
  noKibitz: Boolean
  showHideKarmaOption: Boolean
  showPostAuthorCard: Boolean
  hideIntercom: Boolean
  noSingleLineComments: Boolean
  noCollapseCommentsPosts: Boolean
  noCollapseCommentsFrontpage: Boolean
  hideCommunitySection: Boolean
  expandedFrontpageSections: JSON
  showCommunityInRecentDiscussion: Boolean
  hidePostsRecommendations: Boolean
  petrovOptOut: Boolean
  optedOutOfSurveys: Boolean
  postGlossariesPinned: Boolean
  acceptedTos: Boolean
  hideNavigationSidebar: Boolean
  currentFrontpageFilter: String
  frontpageSelectedTab: String
  frontpageFilterSettings: JSON
  hideFrontpageFilterSettingsDesktop: Boolean
  allPostsTimeframe: String
  allPostsFilter: String
  allPostsSorting: String
  allPostsShowLowKarma: Boolean
  allPostsIncludeEvents: Boolean
  allPostsHideCommunity: Boolean
  allPostsOpenSettings: Boolean
  draftsListSorting: String
  draftsListShowArchived: Boolean
  draftsListShowShared: Boolean
  lastNotificationsCheck: Date
  moderationStyle: String
  moderatorAssistance: Boolean
  collapseModerationGuidelines: Boolean
  bannedUserIds: [String]
  bannedPersonalUserIds: [String]
  legacyId: String
  voteBanned: Boolean
  nullifyVotes: Boolean
  deleteContent: Boolean
  banned: Date
  auto_subscribe_to_my_posts: Boolean
  auto_subscribe_to_my_comments: Boolean
  autoSubscribeAsOrganizer: Boolean
  notificationCommentsOnSubscribedPost: JSON
  notificationShortformContent: JSON
  notificationRepliesToMyComments: JSON
  notificationRepliesToSubscribedComments: JSON
  notificationSubscribedUserPost: JSON
  notificationSubscribedUserComment: JSON
  notificationPostsInGroups: JSON
  notificationSubscribedTagPost: JSON
  notificationSubscribedSequencePost: JSON
  notificationPrivateMessage: JSON
  notificationSharedWithMe: JSON
  notificationAlignmentSubmissionApproved: JSON
  notificationEventInRadius: JSON
  notificationKarmaPowersGained: JSON
  notificationRSVPs: JSON
  notificationGroupAdministration: JSON
  notificationCommentsOnDraft: JSON
  notificationPostsNominatedReview: JSON
  notificationSubforumUnread: JSON
  notificationNewMention: JSON
  notificationDialogueMessages: JSON
  notificationPublishedDialogueMessages: JSON
  notificationAddedAsCoauthor: JSON
  notificationDebateCommentsOnSubscribedPost: JSON
  notificationDebateReplies: JSON
  notificationDialogueMatch: JSON
  notificationNewDialogueChecks: JSON
  notificationYourTurnMatchForm: JSON
  hideDialogueFacilitation: Boolean
  revealChecksToAdmins: Boolean
  optedInToDialogueFacilitation: Boolean
  showDialoguesList: Boolean!
  showMyDialogues: Boolean!
  showMatches: Boolean!
  showRecommendedPartners: Boolean!
  hideActiveDialogueUsers: Boolean
  karmaChangeNotifierSettings: JSON
  karmaChangeLastOpened: Date
  karmaChangeBatchStart: Date
  emailSubscribedToCurated: Boolean
  subscribedToDigest: Boolean
  unsubscribeFromAll: Boolean
  hideSubscribePoke: Boolean
  hideMeetupsPoke: Boolean
  hideHomeRHS: Boolean
  googleLocation: JSON
  location: String
  mapLocation: JSON
  mapMarkerText: String
  nearbyEventsNotifications: Boolean
  nearbyEventsNotificationsLocation: JSON
  nearbyEventsNotificationsRadius: Float
  nearbyPeopleNotificationThreshold: Float
  hideFrontpageMap: Boolean
  hideTaggingProgressBar: Boolean
  hideFrontpageBookAd: Boolean
  hideFrontpageBook2019Ad: Boolean
  hideFrontpageBook2020Ad: Boolean
  reviewedByUserId: String
  shortformFeedId: String
  viewUnreviewedComments: Boolean
  noExpandUnreadCommentsReview: Boolean
  profileUpdatedAt: Date!
  jobTitle: String
  organization: String
  careerStage: [String]
  website: String
  fmCrosspostUserId: String
  linkedinProfileURL: String
  facebookProfileURL: String
  blueskyProfileURL: String
  twitterProfileURL: String
  twitterProfileURLAdmin: String
  githubProfileURL: String
  profileTagIds: [String]
  organizerOfGroupIds: [String]
  programParticipation: [String]
  postingDisabled: Boolean
  allCommentingDisabled: Boolean
  commentingOnOtherUsersDisabled: Boolean
  conversationsDisabled: Boolean
  acknowledgedNewUserGuidelines: Boolean
  subforumPreferredLayout: String
  hideJobAdUntil: Date
  criticismTipsDismissed: Boolean
  hideFromPeopleDirectory: Boolean
  allowDatadogSessionReplay: Boolean
  reviewForAlignmentForumUserId: String
  afSubmittedApplication: Boolean
  hideSunshineSidebar: Boolean
  inactiveSurveyEmailSentAt: Date
  userSurveyEmailSentAt: Date
}

input UpdateUserInput {
  selector: UserSelectorUniqueInput!
  data: UpdateUserDataInput!
}

input UpsertUserInput {
  selector: UserSelectorUniqueInput!
  data: UpdateUserDataInput!
}

input UpdateUserDataInput {
  legacyData: JSON
  moderationGuidelines: JSON
  howOthersCanHelpMe: JSON
  howICanHelpOthers: JSON
  slug: String
  biography: JSON
  username: String
  isAdmin: Boolean
  displayName: String
  previousDisplayName: String
  email: String
  noindex: Boolean
  groups: [String]
  theme: JSON
  lastUsedTimezone: String
  whenConfirmationEmailSent: Date
  legacy: Boolean
  commentSorting: String
  sortDraftsBy: String
  reactPaletteStyle: String
  noKibitz: Boolean
  showHideKarmaOption: Boolean
  showPostAuthorCard: Boolean
  hideIntercom: Boolean
  markDownPostEditor: Boolean
  hideElicitPredictions: Boolean
  hideAFNonMemberInitialWarning: Boolean
  noSingleLineComments: Boolean
  noCollapseCommentsPosts: Boolean
  noCollapseCommentsFrontpage: Boolean
  hideCommunitySection: Boolean
  expandedFrontpageSections: JSON
  showCommunityInRecentDiscussion: Boolean
  hidePostsRecommendations: Boolean
  petrovOptOut: Boolean
  optedOutOfSurveys: Boolean
  postGlossariesPinned: Boolean
  generateJargonForDrafts: Boolean
  generateJargonForPublishedPosts: Boolean
  acceptedTos: Boolean
  hideNavigationSidebar: Boolean
  currentFrontpageFilter: String
  frontpageSelectedTab: String
  frontpageFilterSettings: JSON
  hideFrontpageFilterSettingsDesktop: Boolean
  allPostsTimeframe: String
  allPostsFilter: String
  allPostsSorting: String
  allPostsShowLowKarma: Boolean
  allPostsIncludeEvents: Boolean
  allPostsHideCommunity: Boolean
  allPostsOpenSettings: Boolean
  draftsListSorting: String
  draftsListShowArchived: Boolean
  draftsListShowShared: Boolean
  lastNotificationsCheck: Date
  moderationStyle: String
  moderatorAssistance: Boolean
  collapseModerationGuidelines: Boolean
  bannedUserIds: [String]
  bannedPersonalUserIds: [String]
  bookmarkedPostsMetadata: [JSON]
  hiddenPostsMetadata: [JSON]
  legacyId: String
  deleted: Boolean
  permanentDeletionRequestedAt: Date
  voteBanned: Boolean
  nullifyVotes: Boolean
  deleteContent: Boolean
  banned: Date
  auto_subscribe_to_my_posts: Boolean
  auto_subscribe_to_my_comments: Boolean
  autoSubscribeAsOrganizer: Boolean
  notificationCommentsOnSubscribedPost: JSON
  notificationShortformContent: JSON
  notificationRepliesToMyComments: JSON
  notificationRepliesToSubscribedComments: JSON
  notificationSubscribedUserPost: JSON
  notificationSubscribedUserComment: JSON
  notificationPostsInGroups: JSON
  notificationSubscribedTagPost: JSON
  notificationSubscribedSequencePost: JSON
  notificationPrivateMessage: JSON
  notificationSharedWithMe: JSON
  notificationAlignmentSubmissionApproved: JSON
  notificationEventInRadius: JSON
  notificationKarmaPowersGained: JSON
  notificationRSVPs: JSON
  notificationGroupAdministration: JSON
  notificationCommentsOnDraft: JSON
  notificationPostsNominatedReview: JSON
  notificationSubforumUnread: JSON
  notificationNewMention: JSON
  notificationDialogueMessages: JSON
  notificationPublishedDialogueMessages: JSON
  notificationAddedAsCoauthor: JSON
  notificationDebateCommentsOnSubscribedPost: JSON
  notificationDebateReplies: JSON
  notificationDialogueMatch: JSON
  notificationNewDialogueChecks: JSON
  notificationYourTurnMatchForm: JSON
  hideDialogueFacilitation: Boolean
  revealChecksToAdmins: Boolean
  optedInToDialogueFacilitation: Boolean
  showDialoguesList: Boolean
  showMyDialogues: Boolean
  showMatches: Boolean
  showRecommendedPartners: Boolean
  hideActiveDialogueUsers: Boolean
  karmaChangeNotifierSettings: JSON
  karmaChangeLastOpened: Date
  karmaChangeBatchStart: Date
  emailSubscribedToCurated: Boolean
  subscribedToDigest: Boolean
  unsubscribeFromAll: Boolean
  hideSubscribePoke: Boolean
  hideMeetupsPoke: Boolean
  hideHomeRHS: Boolean
  googleLocation: JSON
  location: String
  mapLocation: JSON
  mapMarkerText: String
  nearbyEventsNotifications: Boolean
  nearbyEventsNotificationsLocation: JSON
  nearbyEventsNotificationsRadius: Float
  nearbyPeopleNotificationThreshold: Float
  hideFrontpageMap: Boolean
  hideTaggingProgressBar: Boolean
  hideFrontpageBook2019Ad: Boolean
  hideFrontpageBook2020Ad: Boolean
  sunshineNotes: String
  sunshineFlagged: Boolean
  needsReview: Boolean
  sunshineSnoozed: Boolean
  snoozedUntilContentCount: Float
  reviewedByUserId: String
  reviewedAt: Date
  fullName: String
  shortformFeedId: String
  viewUnreviewedComments: Boolean
  partiallyReadSequences: [JSON]
  beta: Boolean
  reviewVotesQuadratic: Boolean
  reviewVotesQuadratic2019: Boolean
  reviewVotesQuadratic2020: Boolean
  petrovPressedButtonDate: Date
  petrovLaunchCodeDate: Date
  defaultToCKEditor: Boolean
  signUpReCaptchaRating: Float
  noExpandUnreadCommentsReview: Boolean
  abTestKey: String
  abTestOverrides: JSON
  walledGardenInvite: Boolean
  walledGardenPortalOnboarded: Boolean
  taggingDashboardCollapsed: Boolean
  usernameUnset: Boolean
  paymentEmail: String
  paymentInfo: String
  profileUpdatedAt: Date
  profileImageId: String
  jobTitle: String
  organization: String
  careerStage: [String]
  website: String
  fmCrosspostUserId: String
  linkedinProfileURL: String
  facebookProfileURL: String
  blueskyProfileURL: String
  twitterProfileURL: String
  twitterProfileURLAdmin: String
  githubProfileURL: String
  profileTagIds: [String]
  organizerOfGroupIds: [String]
  programParticipation: [String]
  postingDisabled: Boolean
  allCommentingDisabled: Boolean
  commentingOnOtherUsersDisabled: Boolean
  conversationsDisabled: Boolean
  acknowledgedNewUserGuidelines: Boolean
  subforumPreferredLayout: String
  hideJobAdUntil: Date
  criticismTipsDismissed: Boolean
  hideFromPeopleDirectory: Boolean
  allowDatadogSessionReplay: Boolean
  reviewForAlignmentForumUserId: String
  afApplicationText: String
  afSubmittedApplication: Boolean
  hideSunshineSidebar: Boolean
  inactiveSurveyEmailSentAt: Date
  userSurveyEmailSentAt: Date
  recommendationSettings: JSON
}

input UserSelectorInput {
  AND: [UserSelectorInput]
  OR: [UserSelectorInput]
}

input UserSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum UserOrderByInput {
  foobar
}

type Vote {
  _id: String
  schemaVersion: Float
  createdAt: Date
  legacyData: JSON
  documentId: String
  collectionName: String
  userId: String
  authorIds: [String]
  authorId: String
  voteType: String
  extendedVoteType: JSON
  power: Float
  afPower: Float
  cancelled: Boolean
  isUnvote: Boolean
  votedAt: Date
  tagRel: TagRel
  comment: Comment
  post: Post
  documentIsAf: Boolean
  silenceNotification: Boolean
}

input DeleteVoteInput {
  selector: VoteSelectorUniqueInput!
}

input SingleVoteInput {
  selector: VoteSelectorUniqueInput
  resolverArgs: JSON
  enableCache: Boolean
  allowNull: Boolean
}

input MultiVoteInput {
  terms: JSON
  resolverArgs: JSON
  offset: Int
  limit: Int
  enableCache: Boolean
  enableTotal: Boolean
  createIfMissing: JSON
  where: VoteSelectorInput
  orderBy: VoteOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleVoteOutput {
  result: Vote
}

type MultiVoteOutput {
  results: [Vote]
  totalCount: Int
}

type VoteOutput {
  data: Vote
}

input CreateVoteInput {
  data: CreateVoteDataInput!
}

input CreateVoteDataInput {
  legacyData: JSON
}

input UpdateVoteInput {
  selector: VoteSelectorUniqueInput!
  data: UpdateVoteDataInput!
}

input UpsertVoteInput {
  selector: VoteSelectorUniqueInput!
  data: UpdateVoteDataInput!
}

input UpdateVoteDataInput {
  legacyData: JSON
}

input VoteSelectorInput {
  AND: [VoteSelectorInput]
  OR: [VoteSelectorInput]
}

input VoteSelectorUniqueInput {
  _id: String
  documentId: String
  slug: String
}

enum VoteOrderByInput {
  foobar
}

type Query {
  advisorRequest(input: SingleAdvisorRequestInput): SingleAdvisorRequestOutput
  advisorRequests(input: MultiAdvisorRequestInput): MultiAdvisorRequestOutput
  arbitalTagContentRel(input: SingleArbitalTagContentRelInput): SingleArbitalTagContentRelOutput
  arbitalTagContentRels(input: MultiArbitalTagContentRelInput): MultiArbitalTagContentRelOutput
  ban(input: SingleBanInput): SingleBanOutput
  bans(input: MultiBanInput): MultiBanOutput
  book(input: SingleBookInput): SingleBookOutput
  books(input: MultiBookInput): MultiBookOutput
  chapter(input: SingleChapterInput): SingleChapterOutput
  chapters(input: MultiChapterInput): MultiChapterOutput
  ckEditorUserSession(input: SingleCkEditorUserSessionInput): SingleCkEditorUserSessionOutput
  ckEditorUserSessions(input: MultiCkEditorUserSessionInput): MultiCkEditorUserSessionOutput
  clientId(input: SingleClientIdInput): SingleClientIdOutput
  clientIds(input: MultiClientIdInput): MultiClientIdOutput
  collection(input: SingleCollectionInput): SingleCollectionOutput
  collections(input: MultiCollectionInput): MultiCollectionOutput
  commentModeratorAction(input: SingleCommentModeratorActionInput): SingleCommentModeratorActionOutput
  commentModeratorActions(input: MultiCommentModeratorActionInput): MultiCommentModeratorActionOutput
  comment(input: SingleCommentInput): SingleCommentOutput
  comments(input: MultiCommentInput): MultiCommentOutput
  conversation(input: SingleConversationInput): SingleConversationOutput
  conversations(input: MultiConversationInput): MultiConversationOutput
  curationNotice(input: SingleCurationNoticeInput): SingleCurationNoticeOutput
  curationNotices(input: MultiCurationNoticeInput): MultiCurationNoticeOutput
  dialogueCheck(input: SingleDialogueCheckInput): SingleDialogueCheckOutput
  dialogueChecks(input: MultiDialogueCheckInput): MultiDialogueCheckOutput
  dialogueMatchPreference(input: SingleDialogueMatchPreferenceInput): SingleDialogueMatchPreferenceOutput
  dialogueMatchPreferences(input: MultiDialogueMatchPreferenceInput): MultiDialogueMatchPreferenceOutput
  digestPost(input: SingleDigestPostInput): SingleDigestPostOutput
  digestPosts(input: MultiDigestPostInput): MultiDigestPostOutput
  digest(input: SingleDigestInput): SingleDigestOutput
  digests(input: MultiDigestInput): MultiDigestOutput
  electionCandidate(input: SingleElectionCandidateInput): SingleElectionCandidateOutput
  electionCandidates(input: MultiElectionCandidateInput): MultiElectionCandidateOutput
  electionVote(input: SingleElectionVoteInput): SingleElectionVoteOutput
  electionVotes(input: MultiElectionVoteInput): MultiElectionVoteOutput
  elicitQuestionPrediction(input: SingleElicitQuestionPredictionInput): SingleElicitQuestionPredictionOutput
  elicitQuestionPredictions(input: MultiElicitQuestionPredictionInput): MultiElicitQuestionPredictionOutput
  elicitQuestion(input: SingleElicitQuestionInput): SingleElicitQuestionOutput
  elicitQuestions(input: MultiElicitQuestionInput): MultiElicitQuestionOutput
  featuredResource(input: SingleFeaturedResourceInput): SingleFeaturedResourceOutput
  featuredResources(input: MultiFeaturedResourceInput): MultiFeaturedResourceOutput
  forumEvent(input: SingleForumEventInput): SingleForumEventOutput
  forumEvents(input: MultiForumEventInput): MultiForumEventOutput
  gardenCode(input: SingleGardenCodeInput): SingleGardenCodeOutput
  gardenCodes(input: MultiGardenCodeInput): MultiGardenCodeOutput
  googleServiceAccountSession(input: SingleGoogleServiceAccountSessionInput): SingleGoogleServiceAccountSessionOutput
  googleServiceAccountSessions(input: MultiGoogleServiceAccountSessionInput): MultiGoogleServiceAccountSessionOutput
  jargonTerm(input: SingleJargonTermInput): SingleJargonTermOutput
  jargonTerms(input: MultiJargonTermInput): MultiJargonTermOutput
  lWEvent(input: SingleLWEventInput): SingleLWEventOutput
  lWEvents(input: MultiLWEventInput): MultiLWEventOutput
  llmConversation(input: SingleLlmConversationInput): SingleLlmConversationOutput
  llmConversations(input: MultiLlmConversationInput): MultiLlmConversationOutput
  localgroup(input: SingleLocalgroupInput): SingleLocalgroupOutput
  localgroups(input: MultiLocalgroupInput): MultiLocalgroupOutput
  message(input: SingleMessageInput): SingleMessageOutput
  messages(input: MultiMessageInput): MultiMessageOutput
  moderationTemplate(input: SingleModerationTemplateInput): SingleModerationTemplateOutput
  moderationTemplates(input: MultiModerationTemplateInput): MultiModerationTemplateOutput
  moderatorAction(input: SingleModeratorActionInput): SingleModeratorActionOutput
  moderatorActions(input: MultiModeratorActionInput): MultiModeratorActionOutput
  multiDocument(input: SingleMultiDocumentInput): SingleMultiDocumentOutput
  multiDocuments(input: MultiMultiDocumentInput): MultiMultiDocumentOutput
  notification(input: SingleNotificationInput): SingleNotificationOutput
  notifications(input: MultiNotificationInput): MultiNotificationOutput
  petrovDayAction(input: SinglePetrovDayActionInput): SinglePetrovDayActionOutput
  petrovDayActions(input: MultiPetrovDayActionInput): MultiPetrovDayActionOutput
  podcastEpisode(input: SinglePodcastEpisodeInput): SinglePodcastEpisodeOutput
  podcastEpisodes(input: MultiPodcastEpisodeInput): MultiPodcastEpisodeOutput
  podcast(input: SinglePodcastInput): SinglePodcastOutput
  podcasts(input: MultiPodcastInput): MultiPodcastOutput
  postEmbedding(input: SinglePostEmbeddingInput): SinglePostEmbeddingOutput
  postEmbeddings(input: MultiPostEmbeddingInput): MultiPostEmbeddingOutput
  postRelation(input: SinglePostRelationInput): SinglePostRelationOutput
  postRelations(input: MultiPostRelationInput): MultiPostRelationOutput
  postViewTime(input: SinglePostViewTimeInput): SinglePostViewTimeOutput
  postViewTimes(input: MultiPostViewTimeInput): MultiPostViewTimeOutput
  postViews(input: SinglePostViewsInput): SinglePostViewsOutput
  postViewses(input: MultiPostViewsInput): MultiPostViewsOutput
  post(input: SinglePostInput): SinglePostOutput
  posts(input: MultiPostInput): MultiPostOutput
  rSSFeed(input: SingleRSSFeedInput): SingleRSSFeedOutput
  rSSFeeds(input: MultiRSSFeedInput): MultiRSSFeedOutput
  report(input: SingleReportInput): SingleReportOutput
  reports(input: MultiReportInput): MultiReportOutput
  reviewVote(input: SingleReviewVoteInput): SingleReviewVoteOutput
  reviewVotes(input: MultiReviewVoteInput): MultiReviewVoteOutput
  reviewWinnerArt(input: SingleReviewWinnerArtInput): SingleReviewWinnerArtOutput
  reviewWinnerArts(input: MultiReviewWinnerArtInput): MultiReviewWinnerArtOutput
  reviewWinner(input: SingleReviewWinnerInput): SingleReviewWinnerOutput
  reviewWinners(input: MultiReviewWinnerInput): MultiReviewWinnerOutput
  revision(input: SingleRevisionInput): SingleRevisionOutput
  revisions(input: MultiRevisionInput): MultiRevisionOutput
  sequence(input: SingleSequenceInput): SingleSequenceOutput
  sequences(input: MultiSequenceInput): MultiSequenceOutput
  splashArtCoordinate(input: SingleSplashArtCoordinateInput): SingleSplashArtCoordinateOutput
  splashArtCoordinates(input: MultiSplashArtCoordinateInput): MultiSplashArtCoordinateOutput
  spotlight(input: SingleSpotlightInput): SingleSpotlightOutput
  spotlights(input: MultiSpotlightInput): MultiSpotlightOutput
  subscription(input: SingleSubscriptionInput): SingleSubscriptionOutput
  subscriptions(input: MultiSubscriptionInput): MultiSubscriptionOutput
  surveyQuestion(input: SingleSurveyQuestionInput): SingleSurveyQuestionOutput
  surveyQuestions(input: MultiSurveyQuestionInput): MultiSurveyQuestionOutput
  surveyResponse(input: SingleSurveyResponseInput): SingleSurveyResponseOutput
  surveyResponses(input: MultiSurveyResponseInput): MultiSurveyResponseOutput
  surveySchedule(input: SingleSurveyScheduleInput): SingleSurveyScheduleOutput
  surveySchedules(input: MultiSurveyScheduleInput): MultiSurveyScheduleOutput
  survey(input: SingleSurveyInput): SingleSurveyOutput
  surveys(input: MultiSurveyInput): MultiSurveyOutput
  tagFlag(input: SingleTagFlagInput): SingleTagFlagOutput
  tagFlags(input: MultiTagFlagInput): MultiTagFlagOutput
  tagRel(input: SingleTagRelInput): SingleTagRelOutput
  tagRels(input: MultiTagRelInput): MultiTagRelOutput
  tag(input: SingleTagInput): SingleTagOutput
  tags(input: MultiTagInput): MultiTagOutput
  typingIndicator(input: SingleTypingIndicatorInput): SingleTypingIndicatorOutput
  typingIndicators(input: MultiTypingIndicatorInput): MultiTypingIndicatorOutput
  userEAGDetail(input: SingleUserEAGDetailInput): SingleUserEAGDetailOutput
  userEAGDetails(input: MultiUserEAGDetailInput): MultiUserEAGDetailOutput
  userJobAd(input: SingleUserJobAdInput): SingleUserJobAdOutput
  userJobAds(input: MultiUserJobAdInput): MultiUserJobAdOutput
  userMostValuablePost(input: SingleUserMostValuablePostInput): SingleUserMostValuablePostOutput
  userMostValuablePosts(input: MultiUserMostValuablePostInput): MultiUserMostValuablePostOutput
  userRateLimit(input: SingleUserRateLimitInput): SingleUserRateLimitOutput
  userRateLimits(input: MultiUserRateLimitInput): MultiUserRateLimitOutput
  userTagRel(input: SingleUserTagRelInput): SingleUserTagRelOutput
  userTagRels(input: MultiUserTagRelInput): MultiUserTagRelOutput
  user(input: SingleUserInput): SingleUserOutput
  users(input: MultiUserInput): MultiUserOutput
  vote(input: SingleVoteInput): SingleVoteOutput
  votes(input: MultiVoteInput): MultiVoteOutput
}

type Mutation {
  createAdvisorRequest(data: CreateAdvisorRequestDataInput!): AdvisorRequestOutput
  updateAdvisorRequest(selector: AdvisorRequestSelectorUniqueInput!, data: UpdateAdvisorRequestDataInput!): AdvisorRequestOutput
  createArbitalTagContentRel(data: CreateArbitalTagContentRelDataInput!): ArbitalTagContentRelOutput
  updateArbitalTagContentRel(selector: ArbitalTagContentRelSelectorUniqueInput!, data: UpdateArbitalTagContentRelDataInput!): ArbitalTagContentRelOutput
  createBan(data: CreateBanDataInput!): BanOutput
  updateBan(selector: BanSelectorUniqueInput!, data: UpdateBanDataInput!): BanOutput
  createBook(data: CreateBookDataInput!): BookOutput
  updateBook(selector: BookSelectorUniqueInput!, data: UpdateBookDataInput!): BookOutput
  createChapter(data: CreateChapterDataInput!): ChapterOutput
  updateChapter(selector: ChapterSelectorUniqueInput!, data: UpdateChapterDataInput!): ChapterOutput
  createCollection(data: CreateCollectionDataInput!): CollectionOutput
  updateCollection(selector: CollectionSelectorUniqueInput!, data: UpdateCollectionDataInput!): CollectionOutput
  createCommentModeratorAction(data: CreateCommentModeratorActionDataInput!): CommentModeratorActionOutput
  updateCommentModeratorAction(selector: CommentModeratorActionSelectorUniqueInput!, data: UpdateCommentModeratorActionDataInput!): CommentModeratorActionOutput
  createComment(data: CreateCommentDataInput!): CommentOutput
  updateComment(selector: CommentSelectorUniqueInput!, data: UpdateCommentDataInput!): CommentOutput
  createConversation(data: CreateConversationDataInput!): ConversationOutput
  updateConversation(selector: ConversationSelectorUniqueInput!, data: UpdateConversationDataInput!): ConversationOutput
  createCurationNotice(data: CreateCurationNoticeDataInput!): CurationNoticeOutput
  updateCurationNotice(selector: CurationNoticeSelectorUniqueInput!, data: UpdateCurationNoticeDataInput!): CurationNoticeOutput
  createDialogueMatchPreference(data: CreateDialogueMatchPreferenceDataInput!): DialogueMatchPreferenceOutput
  updateDialogueMatchPreference(selector: DialogueMatchPreferenceSelectorUniqueInput!, data: UpdateDialogueMatchPreferenceDataInput!): DialogueMatchPreferenceOutput
  createDigestPost(data: CreateDigestPostDataInput!): DigestPostOutput
  updateDigestPost(selector: DigestPostSelectorUniqueInput!, data: UpdateDigestPostDataInput!): DigestPostOutput
  createDigest(data: CreateDigestDataInput!): DigestOutput
  updateDigest(selector: DigestSelectorUniqueInput!, data: UpdateDigestDataInput!): DigestOutput
  createElectionCandidate(data: CreateElectionCandidateDataInput!): ElectionCandidateOutput
  updateElectionCandidate(selector: ElectionCandidateSelectorUniqueInput!, data: UpdateElectionCandidateDataInput!): ElectionCandidateOutput
  createElectionVote(data: CreateElectionVoteDataInput!): ElectionVoteOutput
  updateElectionVote(selector: ElectionVoteSelectorUniqueInput!, data: UpdateElectionVoteDataInput!): ElectionVoteOutput
  createElicitQuestion(data: CreateElicitQuestionDataInput!): ElicitQuestionOutput
  updateElicitQuestion(selector: ElicitQuestionSelectorUniqueInput!, data: UpdateElicitQuestionDataInput!): ElicitQuestionOutput
  createForumEvent(data: CreateForumEventDataInput!): ForumEventOutput
  updateForumEvent(selector: ForumEventSelectorUniqueInput!, data: UpdateForumEventDataInput!): ForumEventOutput
  createGardenCode(data: CreateGardenCodeDataInput!): GardenCodeOutput
  updateGardenCode(selector: GardenCodeSelectorUniqueInput!, data: UpdateGardenCodeDataInput!): GardenCodeOutput
  createGoogleServiceAccountSession(data: CreateGoogleServiceAccountSessionDataInput!): GoogleServiceAccountSessionOutput
  updateGoogleServiceAccountSession(selector: GoogleServiceAccountSessionSelectorUniqueInput!, data: UpdateGoogleServiceAccountSessionDataInput!): GoogleServiceAccountSessionOutput
  createJargonTerm(data: CreateJargonTermDataInput!): JargonTermOutput
  updateJargonTerm(selector: JargonTermSelectorUniqueInput!, data: UpdateJargonTermDataInput!): JargonTermOutput
  createLWEvent(data: CreateLWEventDataInput!): LWEventOutput
  updateLWEvent(selector: LWEventSelectorUniqueInput!, data: UpdateLWEventDataInput!): LWEventOutput
  createLlmConversation(data: CreateLlmConversationDataInput!): LlmConversationOutput
  updateLlmConversation(selector: LlmConversationSelectorUniqueInput!, data: UpdateLlmConversationDataInput!): LlmConversationOutput
  createLocalgroup(data: CreateLocalgroupDataInput!): LocalgroupOutput
  updateLocalgroup(selector: LocalgroupSelectorUniqueInput!, data: UpdateLocalgroupDataInput!): LocalgroupOutput
  createMessage(data: CreateMessageDataInput!): MessageOutput
  updateMessage(selector: MessageSelectorUniqueInput!, data: UpdateMessageDataInput!): MessageOutput
  createModerationTemplate(data: CreateModerationTemplateDataInput!): ModerationTemplateOutput
  updateModerationTemplate(selector: ModerationTemplateSelectorUniqueInput!, data: UpdateModerationTemplateDataInput!): ModerationTemplateOutput
  createModeratorAction(data: CreateModeratorActionDataInput!): ModeratorActionOutput
  updateModeratorAction(selector: ModeratorActionSelectorUniqueInput!, data: UpdateModeratorActionDataInput!): ModeratorActionOutput
  createMultiDocument(data: CreateMultiDocumentDataInput!): MultiDocumentOutput
  updateMultiDocument(selector: MultiDocumentSelectorUniqueInput!, data: UpdateMultiDocumentDataInput!): MultiDocumentOutput
  createNotification(data: CreateNotificationDataInput!): NotificationOutput
  updateNotification(selector: NotificationSelectorUniqueInput!, data: UpdateNotificationDataInput!): NotificationOutput
  createPetrovDayAction(data: CreatePetrovDayActionDataInput!): PetrovDayActionOutput
  updatePetrovDayAction(selector: PetrovDayActionSelectorUniqueInput!, data: UpdatePetrovDayActionDataInput!): PetrovDayActionOutput
  createPodcastEpisode(data: CreatePodcastEpisodeDataInput!): PodcastEpisodeOutput
  updatePodcastEpisode(selector: PodcastEpisodeSelectorUniqueInput!, data: UpdatePodcastEpisodeDataInput!): PodcastEpisodeOutput
  createPostEmbedding(data: CreatePostEmbeddingDataInput!): PostEmbeddingOutput
  updatePostEmbedding(selector: PostEmbeddingSelectorUniqueInput!, data: UpdatePostEmbeddingDataInput!): PostEmbeddingOutput
  createPostViewTime(data: CreatePostViewTimeDataInput!): PostViewTimeOutput
  updatePostViewTime(selector: PostViewTimeSelectorUniqueInput!, data: UpdatePostViewTimeDataInput!): PostViewTimeOutput
  createPostViews(data: CreatePostViewsDataInput!): PostViewsOutput
  updatePostViews(selector: PostViewsSelectorUniqueInput!, data: UpdatePostViewsDataInput!): PostViewsOutput
  createPost(data: CreatePostDataInput!): PostOutput
  updatePost(selector: PostSelectorUniqueInput!, data: UpdatePostDataInput!): PostOutput
  createRSSFeed(data: CreateRSSFeedDataInput!): RSSFeedOutput
  updateRSSFeed(selector: RSSFeedSelectorUniqueInput!, data: UpdateRSSFeedDataInput!): RSSFeedOutput
  createReport(data: CreateReportDataInput!): ReportOutput
  updateReport(selector: ReportSelectorUniqueInput!, data: UpdateReportDataInput!): ReportOutput
  createReviewWinnerArt(data: CreateReviewWinnerArtDataInput!): ReviewWinnerArtOutput
  updateReviewWinnerArt(selector: ReviewWinnerArtSelectorUniqueInput!, data: UpdateReviewWinnerArtDataInput!): ReviewWinnerArtOutput
  createReviewWinner(data: CreateReviewWinnerDataInput!): ReviewWinnerOutput
  updateReviewWinner(selector: ReviewWinnerSelectorUniqueInput!, data: UpdateReviewWinnerDataInput!): ReviewWinnerOutput
  updateRevision(selector: RevisionSelectorUniqueInput!, data: UpdateRevisionDataInput!): RevisionOutput
  createSequence(data: CreateSequenceDataInput!): SequenceOutput
  updateSequence(selector: SequenceSelectorUniqueInput!, data: UpdateSequenceDataInput!): SequenceOutput
  createSplashArtCoordinate(data: CreateSplashArtCoordinateDataInput!): SplashArtCoordinateOutput
  updateSplashArtCoordinate(selector: SplashArtCoordinateSelectorUniqueInput!, data: UpdateSplashArtCoordinateDataInput!): SplashArtCoordinateOutput
  createSpotlight(data: CreateSpotlightDataInput!): SpotlightOutput
  updateSpotlight(selector: SpotlightSelectorUniqueInput!, data: UpdateSpotlightDataInput!): SpotlightOutput
  createSubscription(data: CreateSubscriptionDataInput!): SubscriptionOutput
  createSurveyQuestion(data: CreateSurveyQuestionDataInput!): SurveyQuestionOutput
  updateSurveyQuestion(selector: SurveyQuestionSelectorUniqueInput!, data: UpdateSurveyQuestionDataInput!): SurveyQuestionOutput
  createSurveyResponse(data: CreateSurveyResponseDataInput!): SurveyResponseOutput
  updateSurveyResponse(selector: SurveyResponseSelectorUniqueInput!, data: UpdateSurveyResponseDataInput!): SurveyResponseOutput
  createSurveySchedule(data: CreateSurveyScheduleDataInput!): SurveyScheduleOutput
  updateSurveySchedule(selector: SurveyScheduleSelectorUniqueInput!, data: UpdateSurveyScheduleDataInput!): SurveyScheduleOutput
  createSurvey(data: CreateSurveyDataInput!): SurveyOutput
  updateSurvey(selector: SurveySelectorUniqueInput!, data: UpdateSurveyDataInput!): SurveyOutput
  createTagFlag(data: CreateTagFlagDataInput!): TagFlagOutput
  updateTagFlag(selector: TagFlagSelectorUniqueInput!, data: UpdateTagFlagDataInput!): TagFlagOutput
  createTagRel(data: CreateTagRelDataInput!): TagRelOutput
  updateTagRel(selector: TagRelSelectorUniqueInput!, data: UpdateTagRelDataInput!): TagRelOutput
  createTag(data: CreateTagDataInput!): TagOutput
  updateTag(selector: TagSelectorUniqueInput!, data: UpdateTagDataInput!): TagOutput
  createUserEAGDetail(data: CreateUserEAGDetailDataInput!): UserEAGDetailOutput
  updateUserEAGDetail(selector: UserEAGDetailSelectorUniqueInput!, data: UpdateUserEAGDetailDataInput!): UserEAGDetailOutput
  createUserJobAd(data: CreateUserJobAdDataInput!): UserJobAdOutput
  updateUserJobAd(selector: UserJobAdSelectorUniqueInput!, data: UpdateUserJobAdDataInput!): UserJobAdOutput
  createUserMostValuablePost(data: CreateUserMostValuablePostDataInput!): UserMostValuablePostOutput
  updateUserMostValuablePost(selector: UserMostValuablePostSelectorUniqueInput!, data: UpdateUserMostValuablePostDataInput!): UserMostValuablePostOutput
  createUserRateLimit(data: CreateUserRateLimitDataInput!): UserRateLimitOutput
  updateUserRateLimit(selector: UserRateLimitSelectorUniqueInput!, data: UpdateUserRateLimitDataInput!): UserRateLimitOutput
  createUserTagRel(data: CreateUserTagRelDataInput!): UserTagRelOutput
  updateUserTagRel(selector: UserTagRelSelectorUniqueInput!, data: UpdateUserTagRelDataInput!): UserTagRelOutput
  createUser(data: CreateUserDataInput!): UserOutput
  updateUser(selector: UserSelectorUniqueInput!, data: UpdateUserDataInput!): UserOutput
}

type EmailPreview {
  to: String
  subject: String
  html: String
  text: String
}

extend type Query {
  EmailPreview(notificationIds: [String], postId: String): [EmailPreview]
}

type ArbitalLinkedPage {
  _id: String!
  name: String!
  slug: String!
}

type ArbitalLinkedPages {
  faster: [ArbitalLinkedPage]
  slower: [ArbitalLinkedPage]
  moreTechnical: [ArbitalLinkedPage]
  lessTechnical: [ArbitalLinkedPage]
  requirements: [ArbitalLinkedPage]
  teaches: [ArbitalLinkedPage]
  parents: [ArbitalLinkedPage]
  children: [ArbitalLinkedPage]
}

type SocialPreviewType {
  _id: String
  imageId: String
  imageUrl: String
  text: String
}

scalar ContentTypeData

type ContentType {
  type: String
  data: ContentTypeData
}

type TagContributor {
  user: User
  contributionScore: Int!
  currentAttributionCharCount: Int
  numCommits: Int!
  voteCount: Int!
}

type TagContributorsList {
  contributors: [TagContributor!]
  totalCount: Int!
}

type UserLikingTag {
  _id: String!
  displayName: String!
}

type LatLng {
  lat: Float!
  lng: Float!
}

type RecommendResumeSequence {
  sequence: Sequence
  collection: Collection
  nextPost: Post!
  numRead: Int
  numTotal: Int
  lastReadTime: Date
}

extend type Query {
  ContinueReading: [RecommendResumeSequence!]
  Recommendations(count: Int, algorithm: JSON): [Post!]
}

extend type Mutation {
  dismissRecommendation(postId: String): Boolean
}

type CommentCountTag {
  name: String!
  comment_count: Int!
}

type TopCommentedTagUser {
  _id: ID!
  username: String!
  displayName: String!
  total_power: Float!
  tag_comment_counts: [CommentCountTag!]!
}

type UpvotedUser {
  _id: ID!
  username: String!
  displayName: String!
  total_power: Float!
  power_values: String!
  vote_counts: Int!
  total_agreement: Float!
  agreement_values: String!
  recently_active_matchmaking: Boolean!
}

type UserDialogueUsefulData {
  dialogueUsers: [User]
  topUsers: [UpvotedUser]
  activeDialogueMatchSeekers: [User]
}

type NewUserCompletedProfile {
  username: String
  slug: String
  displayName: String
  subscribedToDigest: Boolean
  usernameUnset: Boolean
}

type UserCoreTagReads {
  tagId: String
  userReadCount: Int
}

extend type Mutation {
  NewUserCompleteProfile(username: String!, subscribeToDigest: Boolean!, email: String, acceptedTos: Boolean): NewUserCompletedProfile
  UserExpandFrontpageSection(section: String!, expanded: Boolean!): Boolean
  UserUpdateSubforumMembership(tagId: String!, member: Boolean!): User
}

extend type Query {
  UserReadsPerCoreTag(userId: String!): [UserCoreTagReads]
  GetRandomUser(userIsAuthor: String!): User
  IsDisplayNameTaken(displayName: String!): Boolean!
}

type SuggestedFeedSubscriptionUsersResult {
  results: [User!]!
}

extend type Query {
  SuggestedFeedSubscriptionUsers(limit: Int): SuggestedFeedSubscriptionUsersResult
}

type VoteResultPost {
  document: Post!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVotePost(documentId: String, voteType: String, extendedVote: JSON): Post
  performVotePost(documentId: String, voteType: String, extendedVote: JSON): VoteResultPost
}

type VoteResultComment {
  document: Comment!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteComment(documentId: String, voteType: String, extendedVote: JSON): Comment
  performVoteComment(documentId: String, voteType: String, extendedVote: JSON): VoteResultComment
}

type VoteResultTagRel {
  document: TagRel!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteTagRel(documentId: String, voteType: String, extendedVote: JSON): TagRel
  performVoteTagRel(documentId: String, voteType: String, extendedVote: JSON): VoteResultTagRel
}

type VoteResultRevision {
  document: Revision!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteRevision(documentId: String, voteType: String, extendedVote: JSON): Revision
  performVoteRevision(documentId: String, voteType: String, extendedVote: JSON): VoteResultRevision
}

type VoteResultElectionCandidate {
  document: ElectionCandidate!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteElectionCandidate(documentId: String, voteType: String, extendedVote: JSON): ElectionCandidate
  performVoteElectionCandidate(documentId: String, voteType: String, extendedVote: JSON): VoteResultElectionCandidate
}

type VoteResultTag {
  document: Tag!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteTag(documentId: String, voteType: String, extendedVote: JSON): Tag
  performVoteTag(documentId: String, voteType: String, extendedVote: JSON): VoteResultTag
}

type VoteResultMultiDocument {
  document: MultiDocument!
  showVotingPatternWarning: Boolean!
}

extend type Mutation {
  setVoteMultiDocument(documentId: String, voteType: String, extendedVote: JSON): MultiDocument
  performVoteMultiDocument(documentId: String, voteType: String, extendedVote: JSON): VoteResultMultiDocument
}

extend type Mutation {
  moderateComment(commentId: String, deleted: Boolean, deletedPublic: Boolean, deletedReason: String): Comment
}

type CommentsWithReactsResult {
  results: [Comment!]!
}

extend type Query {
  CommentsWithReacts(limit: Int): CommentsWithReactsResult
}

type PopularCommentsResult {
  results: [Comment!]!
}

extend type Query {
  PopularComments(limit: Int): PopularCommentsResult
}

type PostKarmaChange {
  _id: String
  scoreChange: Int
  postId: String
  title: String
  slug: String
  addedReacts: [ReactionChange!]
  eaAddedReacts: JSON
}

type CommentKarmaChange {
  _id: String
  scoreChange: Int
  commentId: String
  description: String
  postId: String
  postTitle: String
  postSlug: String
  tagSlug: String
  tagName: String
  tagCommentType: String
  addedReacts: [ReactionChange!]
  eaAddedReacts: JSON
}

type RevisionsKarmaChange {
  _id: String
  scoreChange: Int
  tagId: String
  tagSlug: String
  tagName: String
  addedReacts: [ReactionChange!]
  eaAddedReacts: JSON
}

type ReactionChange {
  reactionType: String!
  userId: String
}

type KarmaChangesSimple {
  posts: [PostKarmaChange]
  comments: [CommentKarmaChange]
  tagRevisions: [RevisionsKarmaChange]
}

type KarmaChanges {
  totalChange: Int
  startDate: Date
  endDate: Date
  nextBatchDate: Date
  updateFrequency: String
  posts: [PostKarmaChange]
  comments: [CommentKarmaChange]
  tagRevisions: [RevisionsKarmaChange]
  todaysKarmaChanges: KarmaChangesSimple
  thisWeeksKarmaChanges: KarmaChangesSimple
}

type UniqueClientViewsSeries {
  uniqueClientViews: Int
  date: Date
}

type PostAnalyticsResult {
  allViews: Int
  uniqueClientViews: Int
  uniqueClientViews10Sec: Int
  medianReadingTime: Int
  uniqueClientViews5Min: Int
  uniqueClientViewsSeries: [UniqueClientViewsSeries]
}

type PostAnalytics2Result {
  _id: String
  title: String
  slug: String
  postedAt: Date
  views: Int
  uniqueViews: Int
  reads: Int
  meanReadingTime: Float
  karma: Int
  comments: Int
}

type MultiPostAnalyticsResult {
  posts: [PostAnalytics2Result]
  totalCount: Int!
}

type AnalyticsSeriesValue {
  date: Date
  views: Int
  reads: Int
  karma: Int
  comments: Int
}

extend type Query {
  PostAnalytics(postId: String!): PostAnalyticsResult!
  MultiPostAnalytics(userId: String, postIds: [String], sortBy: String, desc: Boolean, limit: Int): MultiPostAnalyticsResult!
  AnalyticsSeries(userId: String, postIds: [String], startDate: Date, endDate: Date): [AnalyticsSeriesValue]
}

type ArbitalPageData {
  html: String
  title: String
}

extend type Query {
  ArbitalPageData(pageAlias: String): ArbitalPageData
}

type CoronaVirusDataRow {
  accepted: String
  imp: String
  link: String
  shortDescription: String
  url: String
  description: String
  domain: String
  type: String
  reviewerThoughts: String
  foundVia: String
  sourceLink: String
  sourceLinkDomain: String
  lastUpdated: String
  title: String
  dateAdded: String
  category: String
}

type CoronaVirusDataSchema {
  range: String
  majorDimension: String
  values: [CoronaVirusDataRow!]
}

extend type Query {
  CoronaVirusData: CoronaVirusDataSchema
}

type ElicitUser {
  isQuestionCreator: Boolean
  displayName: String
  _id: String
  sourceUserId: String
  lwUser: User
}

type ElicitPrediction {
  _id: String
  predictionId: String
  prediction: Float
  createdAt: Date
  notes: String
  creator: ElicitUser
  sourceUrl: String
  sourceId: String
  binaryQuestionId: String
}

type ElicitBlockData {
  _id: String
  title: String
  notes: String
  resolvesBy: Date
  resolution: Boolean
  predictions: [ElicitPrediction]
}

extend type Query {
  ElicitBlockData(questionId: String): ElicitBlockData
}

extend type Mutation {
  MakeElicitPrediction(questionId: String, prediction: Int): ElicitBlockData
}

type NotificationCounts {
  checkedAt: Date!
  unreadNotifications: Int!
  unreadPrivateMessages: Int!
  faviconBadgeNumber: Int!
}

extend type Query {
  unreadNotificationCounts: NotificationCounts!
}

extend type Mutation {
  MarkAllNotificationsAsRead: Boolean
  sendNewDialogueMessageNotification(postId: String!, dialogueHtml: String!): Boolean!
}

type NotificationDisplaysResult {
  results: [JSON!]!
}

extend type Query {
  NotificationDisplays(type: String, limit: Int): NotificationDisplaysResult
}

extend type Query {
  Lightcone2024FundraiserStripeAmounts: [Int!]
}

type PetrovDay2024CheckNumberOfIncomingData {
  count: Int
}

extend type Query {
  PetrovDay2024CheckNumberOfIncoming: PetrovDay2024CheckNumberOfIncomingData
  petrov2024checkIfNuked: Boolean
}

type PetrovDayCheckIfIncomingData {
  launched: Boolean
  createdAt: Date
}

type PetrovDayLaunchMissileData {
  launchCode: String
  createdAt: Date
}

extend type Query {
  PetrovDayCheckIfIncoming: PetrovDayCheckIfIncomingData
}

extend type Mutation {
  PetrovDayLaunchMissile(launchCode: String): PetrovDayLaunchMissileData
}

type GivingSeasonHeart {
  userId: String!
  displayName: String!
  x: Float!
  y: Float!
  theta: Float!
}

extend type Mutation {
  submitReviewVote(postId: String, qualitativeScore: Int, quadraticChange: Int, newQuadraticScore: Int, comment: String, year: String, dummy: Boolean, reactions: [String]): Post
  AddGivingSeasonHeart(electionName: String!, x: Float!, y: Float!, theta: Float!): [GivingSeasonHeart!]!
  RemoveGivingSeasonHeart(electionName: String!): [GivingSeasonHeart!]!
}

extend type Query {
  GivingSeasonHearts(electionName: String!): [GivingSeasonHeart!]!
}

extend type Query {
  UsersReadPostsOfTargetUser(userId: String!, targetUserId: String!, limit: Int): [Post!]
  UserReadHistory(limit: Int, filter: PostReviewFilter, sort: PostReviewSort): UserReadHistoryResult
  PostsUserCommentedOn(limit: Int, filter: PostReviewFilter, sort: PostReviewSort): UserReadHistoryResult
  PostIsCriticism(args: JSON): Boolean
  DigestPlannerData(digestId: String, startDate: Date, endDate: Date): [DigestPlannerPost]
  DigestPosts(num: Int): [Post]
  CanAccessGoogleDoc(fileUrl: String!): Boolean
}

extend type Mutation {
  ImportGoogleDoc(fileUrl: String!, postId: String): Post
}

type UserReadHistoryResult {
  posts: [Post!]
}

type PostsUserCommentedOnResult {
  posts: [Post!]
}

input PostReviewFilter {
  startDate: Date
  endDate: Date
  minKarma: Int
  showEvents: Boolean
}

input PostReviewSort {
  karma: Boolean
}

type DigestPlannerPost {
  post: Post
  digestPost: DigestPost
  rating: Int
}

type RecombeeRecommendedPost {
  post: Post!
  scenario: String
  recommId: String
  generatedAt: Date
  curated: Boolean
  stickied: Boolean
}

type VertexRecommendedPost {
  post: Post!
  attributionId: String
}

type PostWithApprovedJargon {
  post: Post!
  jargonTerms: [JargonTerm!]
}

type DigestHighlightsResult {
  results: [Post!]!
}

extend type Query {
  DigestHighlights(limit: Int): DigestHighlightsResult
}

type DigestPostsThisWeekResult {
  results: [Post!]!
}

extend type Query {
  DigestPostsThisWeek(limit: Int): DigestPostsThisWeekResult
}

type CuratedAndPopularThisWeekResult {
  results: [Post!]!
}

extend type Query {
  CuratedAndPopularThisWeek(limit: Int): CuratedAndPopularThisWeekResult
}

type RecentlyActiveDialoguesResult {
  results: [Post!]!
}

extend type Query {
  RecentlyActiveDialogues(limit: Int): RecentlyActiveDialoguesResult
}

type MyDialoguesResult {
  results: [Post!]!
}

extend type Query {
  MyDialogues(limit: Int): MyDialoguesResult
}

type GoogleVertexPostsResult {
  results: [VertexRecommendedPost!]!
}

extend type Query {
  GoogleVertexPosts(settings: JSON, limit: Int): GoogleVertexPostsResult
}

type CrossedKarmaThresholdResult {
  results: [Post!]!
}

extend type Query {
  CrossedKarmaThreshold(limit: Int): CrossedKarmaThresholdResult
}

type RecombeeLatestPostsResult {
  results: [RecombeeRecommendedPost!]!
}

extend type Query {
  RecombeeLatestPosts(settings: JSON, limit: Int): RecombeeLatestPostsResult
}

type RecombeeHybridPostsResult {
  results: [RecombeeRecommendedPost!]!
}

extend type Query {
  RecombeeHybridPosts(settings: JSON, limit: Int): RecombeeHybridPostsResult
}

type PostsWithActiveDiscussionResult {
  results: [Post!]!
}

extend type Query {
  PostsWithActiveDiscussion(limit: Int): PostsWithActiveDiscussionResult
}

type PostsBySubscribedAuthorsResult {
  results: [Post!]!
}

extend type Query {
  PostsBySubscribedAuthors(limit: Int): PostsBySubscribedAuthorsResult
}

type PostsWithApprovedJargonResult {
  results: [PostWithApprovedJargon!]!
}

extend type Query {
  PostsWithApprovedJargon(limit: Int): PostsWithApprovedJargonResult
}

extend type Mutation {
  revokeGoogleServiceAccountTokens: Boolean!
}

extend type Mutation {
  alignmentComment(commentId: String, af: Boolean): Comment
  alignmentPost(postId: String, af: Boolean): Post
}

type AllTagsActivityFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [AllTagsActivityFeedEntryType!]
}

type AllTagsActivityFeedEntryType {
  type: String!
  tagCreated: Tag
  tagRevision: Revision
  tagDiscussionComment: Comment
}

extend type Query {
  AllTagsActivityFeed(limit: Int, cutoff: Date, offset: Int): AllTagsActivityFeedQueryResults!
}

type RecentDiscussionFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [RecentDiscussionFeedEntryType!]
}

type RecentDiscussionFeedEntryType {
  type: String!
  postCommented: Post
  shortformCommented: Post
  tagDiscussed: Tag
  tagRevised: Revision
}

extend type Query {
  RecentDiscussionFeed(limit: Int, cutoff: Date, offset: Int, af: Boolean): RecentDiscussionFeedQueryResults!
}

type SubscribedPostAndComments {
  _id: String!
  post: Post!
  comments: [Comment!]
  expandCommentIds: [String!]
  postIsFromSubscribedUser: Boolean!
}

type SubscribedFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubscribedFeedEntryType!]
}

type SubscribedFeedEntryType {
  type: String!
  postCommented: SubscribedPostAndComments
}

extend type Query {
  SubscribedFeed(limit: Int, cutoff: Date, offset: Int, af: Boolean): SubscribedFeedQueryResults!
}

type TagHistoryFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [TagHistoryFeedEntryType!]
}

type TagHistoryFeedEntryType {
  type: String!
  tagCreated: Tag
  tagApplied: TagRel
  tagRevision: Revision
  tagDiscussionComment: Comment
  lensRevision: Revision
  summaryRevision: Revision
  wikiMetadataChanged: FieldChange
  lensOrSummaryMetadataChanged: FieldChange
}

extend type Query {
  TagHistoryFeed(limit: Int, cutoff: Date, offset: Int, tagId: String!, options: JSON): TagHistoryFeedQueryResults!
}

type SubforumMagicFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumMagicFeedEntryType!]
}

type SubforumMagicFeedEntryType {
  type: String!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumMagicFeed(limit: Int, cutoff: Float, offset: Int, tagId: String!, af: Boolean): SubforumMagicFeedQueryResults!
}

type SubforumTopFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumTopFeedEntryType!]
}

type SubforumTopFeedEntryType {
  type: String!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumTopFeed(limit: Int, cutoff: Int, offset: Int, tagId: String!, af: Boolean): SubforumTopFeedQueryResults!
}

type SubforumRecentCommentsFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumRecentCommentsFeedEntryType!]
}

type SubforumRecentCommentsFeedEntryType {
  type: String!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumRecentCommentsFeed(limit: Int, cutoff: Date, offset: Int, tagId: String!, af: Boolean): SubforumRecentCommentsFeedQueryResults!
}

type SubforumNewFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumNewFeedEntryType!]
}

type SubforumNewFeedEntryType {
  type: String!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumNewFeed(limit: Int, cutoff: Date, offset: Int, tagId: String!, af: Boolean): SubforumNewFeedQueryResults!
}

type SubforumOldFeedQueryResults {
  cutoff: Date
  endOffset: Int!
  results: [SubforumOldFeedEntryType!]
}

type SubforumOldFeedEntryType {
  type: String!
  tagSubforumPosts: Post
  tagSubforumComments: Comment
  tagSubforumStickyComments: Comment
}

extend type Query {
  SubforumOldFeed(limit: Int, cutoff: Date, offset: Int, tagId: String!, af: Boolean): SubforumOldFeedQueryResults!
}

extend type Mutation {
  markConversationRead(conversationId: String!): Boolean!
  sendEventTriggeredDM(eventType: String!): Boolean!
}

input SurveyQuestionInfo {
  _id: String
  question: String!
  format: String!
}

extend type Query {
  CurrentFrontpageSurvey: SurveySchedule
}

extend type Mutation {
  editSurvey(surveyId: String!, name: String!, questions: [SurveyQuestionInfo!]!): Survey
}

type DocumentDeletion {
  userId: String
  documentId: String!
  netChange: String!
  type: String
  docFields: MultiDocument
  createdAt: Date!
}

type TagUpdates {
  tag: Tag!
  revisionIds: [String!]
  commentCount: Int
  commentIds: [String!]
  lastRevisedAt: Date
  lastCommentedAt: Date
  added: Int
  removed: Int
  users: [User!]
  documentDeletions: [DocumentDeletion!]
}

type TagPreviewWithSummaries {
  tag: Tag!
  lens: MultiDocument
  summaries: [MultiDocument!]!
}

type TagWithTotalCount {
  tags: [Tag!]!
  totalCount: Int!
}

extend type Mutation {
  mergeTags(sourceTagId: String!, targetTagId: String!, transferSubtags: Boolean!, redirectSource: Boolean!): Boolean
  promoteLensToMain(lensId: String!): Boolean
}

extend type Query {
  TagUpdatesInTimeBlock(before: Date!, after: Date!): [TagUpdates!]
  TagUpdatesByUser(userId: String!, limit: Int!, skip: Int!): [TagUpdates!]
  RandomTag: Tag!
  ActiveTagCount: Int!
  TagPreview(slug: String!, hash: String): TagPreviewWithSummaries
  TagsByCoreTagId(coreTagId: String, limit: Int, searchTagIds: [String]): TagWithTotalCount!
}

type MostReadTopic {
  slug: String
  name: String
  shortName: String
  count: Int
}

type TagReadLikelihoodRatio {
  tagId: String
  tagName: String
  tagShortName: String
  userReadCount: Int
  readLikelihoodRatio: Float
}

type MostReadAuthor {
  _id: String
  slug: String
  displayName: String
  profileImageId: String
  count: Int
  engagementPercentile: Float
}

type TopCommentContents {
  html: String
}

type TopComment {
  _id: String
  postedAt: Date
  postId: String
  postTitle: String
  postSlug: String
  baseScore: Int
  extendedScore: JSON
  contents: TopCommentContents
}

type MostReceivedReact {
  name: String
  count: Int
}

type CombinedKarmaVals {
  date: Date!
  postKarma: Int!
  commentKarma: Int!
}

type WrappedDataByYear {
  engagementPercentile: Float
  postsReadCount: Int
  totalSeconds: Int
  daysVisited: [String]
  mostReadTopics: [MostReadTopic]
  relativeMostReadCoreTopics: [TagReadLikelihoodRatio]
  mostReadAuthors: [MostReadAuthor]
  topPosts: [Post]
  postCount: Int
  authorPercentile: Float
  topComment: TopComment
  commentCount: Int
  commenterPercentile: Float
  topShortform: Comment
  shortformCount: Int
  shortformPercentile: Float
  karmaChange: Int
  combinedKarmaVals: [CombinedKarmaVals]
  mostReceivedReacts: [MostReceivedReact]
  personality: String!
}

extend type Query {
  UserWrappedDataByYear(userId: String!, year: Int!): WrappedDataByYear
}

extend type Mutation {
  RefreshDbSettings: Boolean
}

type Site {
  title: String
  url: String
  logoUrl: String
}

extend type Query {
  SiteData: Site
}

type LoginReturnData {
  token: String
}

extend type Mutation {
  login(username: String, password: String): LoginReturnData
  signup(username: String, email: String, password: String, subscribeToCurated: Boolean, reCaptchaToken: String, abTestKey: String): LoginReturnData
  logout: LoginReturnData
  resetPassword(email: String): String
}

extend type Query {
  latestDialogueMessages(dialogueId: String!, numMessages: Int!): [String!]
}

extend type Mutation {
  AddForumEventVote(forumEventId: String!, x: Float!, delta: Float, postIds: [String]): Boolean
  RemoveForumEventVote(forumEventId: String!): Boolean
  RemoveForumEventSticker(forumEventId: String!, stickerId: String!): Boolean
}

extend type Query {
  getLinkSharedPost(postId: String!, linkSharingKey: String!): Post
}

extend type Mutation {
  unlockPost(postId: String!, linkSharingKey: String!): Post
  revertPostToRevision(postId: String!, revisionId: String!): Post
}

type MigrationsDashboardData {
  migrations: [MigrationStatus!]
}

type MigrationStatus {
  name: String!
  dateWritten: String
  runs: [MigrationRun!]
  lastRun: String
}

type MigrationRun {
  name: String!
  started: Date!
  finished: Date
  succeeded: Boolean
}

extend type Query {
  MigrationsDashboard: MigrationsDashboardData
}

extend type Query {
  GetAllReviewWinners: [Post!]!
}

extend type Mutation {
  sendVertexViewItemEvent(postId: String!, attributionId: String): Boolean!
  sendVertexMediaCompleteEvent(postId: String!, attributionId: String): Boolean!
  sendVertexViewHomePageEvent: Boolean!
}

type CoauthorStatus {
  userId: String
  confirmed: Boolean
  requested: Boolean
}

type ExternalPost {
  _id: String!
  slug: String
  title: String
  url: String
  postedAt: Date
  createdAt: Date
  userId: String
  modifiedAt: Date
  draft: Boolean
  content: String
  coauthorStatuses: [CoauthorStatus]
}

type ExternalPostImportData {
  alreadyExists: Boolean
  post: ExternalPost
}

extend type Mutation {
  importUrlAsDraftPost(url: String!): ExternalPostImportData!
}

input AutosaveContentType {
  type: String
  value: ContentTypeData
}

extend type Query {
  convertDocument(document: JSON, targetFormat: String): JSON
  latestGoogleDocMetadata(postId: String!, version: String): JSON
}

extend type Mutation {
  revertTagToRevision(tagId: String!, revertToRevisionId: String!): Tag
  autosaveRevision(postId: String!, contents: AutosaveContentType!): Revision
}

type ModeratorIPAddressInfo {
  ip: String!
  userIds: [String!]!
}

extend type Query {
  moderatorViewIPAddress(ipAddress: String!): ModeratorIPAddressInfo
}

extend type Mutation {
  lockThread(commentId: String!, until: String): Boolean!
  unlockThread(commentId: String!): Boolean!
}

extend type Mutation {
  reorderSummaries(parentDocumentId: String!, parentDocumentCollectionName: String!, summaryIds: [String!]!): Boolean
}

extend type Mutation {
  publishAndDeDuplicateSpotlight(spotlightId: String): Spotlight
}

extend type Mutation {
  upsertUserTypingIndicator(documentId: String!): TypingIndicator
}

extend type Mutation {
  acceptCoauthorRequest(postId: String, userId: String, accept: Boolean): Post
}

extend type Mutation {
  setIsBookmarked(postId: String!, isBookmarked: Boolean!): User!
}

extend type Mutation {
  setIsHidden(postId: String!, isHidden: Boolean!): User!
}

extend type Mutation {
  markAsReadOrUnread(postId: String, isRead: Boolean): Boolean
  markPostCommentsRead(postId: String!): Boolean
}

type RssPostChangeInfo {
  isChanged: Boolean!
  newHtml: String!
  htmlDiff: String!
}

extend type Mutation {
  resyncRssFeed(feedId: String!): Boolean!
}

extend type Query {
  RssPostChanges(postId: String!): RssPostChangeInfo!
}

extend type Mutation {
  updateContinueReading(sequenceId: String!, postId: String!): Boolean
}

extend type Mutation {
  getNewJargonTerms(postId: String!, glossaryPrompt: String, examplePost: String, exampleTerm: String, exampleAltTerm: String, exampleDefinition: String): [JargonTerm]
}

extend type Mutation {
  RSVPToEvent(postId: String, name: String, email: String, private: Boolean, response: String): Post
  CancelRSVPToEvent(postId: String, name: String, userId: String): Post
}

extend type Query {
  AdminMetadata: String
}

extend type Mutation {
  addOrUpvoteTag(tagId: String, postId: String): TagRel
  addTags(postId: String, tagIds: [String]): Boolean
}

extend type Mutation {
  analyticsEvent(events: [JSON!], now: Date): Boolean
}

extend type Query {
  currentUser: User
}

extend type Query {
  SearchSynonyms: [String!]!
}

extend type Mutation {
  UpdateSearchSynonyms(synonyms: [String!]!): [String!]!
}

extend type Mutation {
  useEmailToken(token: String, args: JSON): JSON
}

extend type Mutation {
  connectCrossposter(token: String): String
  unlinkCrossposter: String
}

extend type Query {
  getCrosspost(args: JSON): JSON
}

extend type Query {
  RevisionsDiff(collectionName: String!, fieldName: String!, id: String, beforeRev: String, afterRev: String!, trim: Boolean): String
}

extend type Mutation {
  observeRecommendation(postId: String!): Boolean
  clickRecommendation(postId: String!): Boolean
}

extend type Mutation {
  increasePostViewCount(postId: String): Float
}

extend type Mutation {
  generateCoverImagesForPost(postId: String!, prompt: String): [ReviewWinnerArt]
}

extend type Mutation {
  flipSplashArtImage(reviewWinnerArtId: String!): Boolean
}
fragment AdvisorRequestsDefaultFragment on AdvisorRequest {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  interestedInMetaculus
  jobAds
}

fragment AdvisorRequestsMinimumInfo on AdvisorRequest {
  _id
  userId
  createdAt
  interestedInMetaculus
  jobAds
}

fragment AllTagsPageFragment on Tag {
  ...TagWithFlagsFragment
  tableOfContents
}

fragment ArbitalCachesDefaultFragment on ArbitalCaches {
  _id
  schemaVersion
  createdAt
  legacyData
}

fragment ArbitalLinkedPagesFragment on ArbitalLinkedPages {
  faster {
    _id
    name
    slug
  }
  slower {
    _id
    name
    slug
  }
  moreTechnical {
    _id
    name
    slug
  }
  lessTechnical {
    _id
    name
    slug
  }
  requirements {
    _id
    name
    slug
  }
  teaches {
    _id
    name
    slug
  }
  parents {
    _id
    name
    slug
  }
  children {
    _id
    name
    slug
  }
}

fragment ArbitalTagContentRelsDefaultFragment on ArbitalTagContentRel {
  _id
  schemaVersion
  createdAt
  legacyData
  parentDocumentId
  childDocumentId
  parentCollectionName
  childCollectionName
  type
  level
  isStrong
}

fragment BansAdminPageFragment on Ban {
  _id
  createdAt
  expirationDate
  userId
  user {
    ...UsersMinimumInfo
  }
  reason
  comment
  ip
  properties
}

fragment BansDefaultFragment on Ban {
  _id
  schemaVersion
  createdAt
  legacyData
  expirationDate
  userId
  ip
  reason
  comment
  properties
}

fragment BookEdit on Book {
  ...BookPageFragment
  contents {
    ...RevisionEdit
  }
}

fragment BookPageFragment on Book {
  _id
  createdAt
  title
  number
  subtitle
  tocTitle
  contents {
    ...RevisionDisplay
  }
  sequenceIds
  sequences {
    ...SequencesPageWithChaptersFragment
  }
  postIds
  posts {
    ...PostsListWithVotes
  }
  collectionId
  displaySequencesAsGrid
  hideProgressBar
  showChapters
}

fragment BooksDefaultFragment on Book {
  _id
  schemaVersion
  createdAt
  legacyData
  contents_latest
  postedAt
  title
  subtitle
  tocTitle
  collectionId
  number
  postIds
  sequenceIds
  displaySequencesAsGrid
  hideProgressBar
  showChapters
}

fragment ChaptersDefaultFragment on Chapter {
  _id
  schemaVersion
  createdAt
  legacyData
  contents_latest
  title
  subtitle
  number
  sequenceId
  postIds
}

fragment ChaptersEdit on Chapter {
  ...ChaptersFragment
  contents {
    ...RevisionEdit
  }
}

fragment ChaptersFragment on Chapter {
  _id
  createdAt
  title
  subtitle
  contents {
    ...RevisionDisplay
  }
  number
  sequenceId
  postIds
  posts {
    ...PostsListWithVotes
  }
}

fragment CkEditorUserSessionInfo on CkEditorUserSession {
  _id
  userId
  documentId
  endedAt
  endedBy
}

fragment CkEditorUserSessionsDefaultFragment on CkEditorUserSession {
  _id
  schemaVersion
  createdAt
  legacyData
  documentId
  userId
  endedAt
  endedBy
}

fragment ClientIdsDefaultFragment on ClientId {
  _id
  schemaVersion
  createdAt
  legacyData
  clientId
  firstSeenReferrer
  firstSeenLandingPage
  userIds
  invalidated
  lastSeenAt
  timesSeen
}

fragment CollectionContinueReadingFragment on Collection {
  _id
  title
  slug
  gridImageId
}

fragment CollectionsBestOfFragment on Collection {
  _id
  createdAt
  slug
  userId
  user {
    ...UsersMinimumInfo
  }
  title
  gridImageId
  noindex
  postsCount
  readPostsCount
  contents {
    ...RevisionDisplay
  }
}

fragment CollectionsDefaultFragment on Collection {
  _id
  schemaVersion
  createdAt
  legacyData
  contents_latest
  userId
  title
  slug
  gridImageId
  firstPageLink
  hideStartReadingButton
  noindex
}

fragment CollectionsEditFragment on Collection {
  ...CollectionsPageFragment
  contents {
    ...RevisionEdit
  }
}

fragment CollectionsPageFragment on Collection {
  _id
  createdAt
  slug
  userId
  user {
    ...UsersMinimumInfo
  }
  title
  contents {
    ...RevisionDisplay
  }
  firstPageLink
  gridImageId
  books {
    ...BookPageFragment
  }
  hideStartReadingButton
  noindex
}

fragment CommentEdit on Comment {
  ...CommentsList
  relevantTagIds
  contents {
    ...RevisionEdit
  }
}

fragment CommentModeratorActionDisplay on CommentModeratorAction {
  _id
  comment {
    ...CommentsListWithModerationMetadata
  }
  commentId
  type
  active
  createdAt
  endedAt
}

fragment CommentModeratorActionsDefaultFragment on CommentModeratorAction {
  _id
  schemaVersion
  createdAt
  legacyData
  commentId
  type
  endedAt
}

fragment CommentWithRepliesFragment on Comment {
  ...CommentsList
  lastSubthreadActivity
  latestChildren {
    ...CommentsList
  }
  tag {
    ...TagBasicInfo
  }
  post {
    ...PostsBase
  }
}

fragment CommentsDefaultFragment on Comment {
  _id
  schemaVersion
  createdAt
  legacyData
  contents_latest
  pingbacks
  parentCommentId
  topLevelCommentId
  postedAt
  lastEditedAt
  author
  postId
  tagId
  forumEventId
  forumEventMetadata
  tagCommentType
  subforumStickyPriority
  userId
  userIP
  userAgent
  referrer
  authorIsUnreviewed
  answer
  parentAnswerId
  directChildrenCount
  descendentCount
  shortform
  shortformFrontpage
  nominatedForReview
  reviewingForReview
  lastSubthreadActivity
  postVersion
  promoted
  promotedByUserId
  promotedAt
  hideKarma
  legacy
  legacyId
  legacyPoll
  legacyParentId
  retracted
  deleted
  deletedPublic
  deletedReason
  deletedDate
  deletedByUserId
  spam
  repliesBlockedUntil
  needsReview
  reviewedByUserId
  hideAuthor
  moderatorHat
  hideModeratorHat
  isPinnedOnProfile
  title
  relevantTagIds
  debateResponse
  rejected
  modGPTAnalysis
  modGPTRecommendation
  rejectedReason
  rejectedByUserId
  af
  suggestForAlignmentUserIds
  reviewForAlignmentUserId
  afDate
  moveToAlignmentUserId
  agentFoundationsId
  originalDialogueId
  voteCount
  baseScore
  extendedScore
  score
  afBaseScore
  afExtendedScore
  afVoteCount
}

fragment CommentsForAutocomplete on Comment {
  _id
  postId
  baseScore
  extendedScore
  createdAt
  user {
    ...UsersMinimumInfo
  }
  contents {
    markdown
  }
  post {
    ...PostsForAutocomplete
  }
}

fragment CommentsForAutocompleteWithParents on Comment {
  ...CommentsForAutocomplete
  parentComment {
    ...CommentsForAutocomplete
    parentComment {
      ...CommentsForAutocomplete
      parentComment {
        ...CommentsForAutocomplete
        parentComment {
          ...CommentsForAutocomplete
          parentComment {
            ...CommentsForAutocomplete
            parentComment {
              ...CommentsForAutocomplete
              parentComment {
                ...CommentsForAutocomplete
                parentComment {
                  ...CommentsForAutocomplete
                  parentComment {
                    ...CommentsForAutocomplete
                    parentComment {
                      ...CommentsForAutocomplete
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

fragment CommentsList on Comment {
  _id
  postId
  tagId
  tag {
    _id
    slug
  }
  relevantTagIds
  relevantTags {
    ...TagPreviewFragment
  }
  tagCommentType
  parentCommentId
  topLevelCommentId
  descendentCount
  title
  contents {
    _id
    html
    plaintextMainText
    wordCount
  }
  postedAt
  lastEditedAt
  repliesBlockedUntil
  userId
  deleted
  deletedPublic
  deletedByUserId
  deletedReason
  hideAuthor
  authorIsUnreviewed
  user {
    ...UsersMinimumInfo
  }
  currentUserVote
  currentUserExtendedVote
  baseScore
  extendedScore
  score
  voteCount
  emojiReactors
  af
  afDate
  moveToAlignmentUserId
  afBaseScore
  afExtendedScore
  suggestForAlignmentUserIds
  reviewForAlignmentUserId
  needsReview
  answer
  parentAnswerId
  retracted
  postVersion
  reviewedByUserId
  shortform
  shortformFrontpage
  lastSubthreadActivity
  moderatorHat
  hideModeratorHat
  nominatedForReview
  reviewingForReview
  promoted
  promotedByUser {
    ...UsersMinimumInfo
  }
  directChildrenCount
  votingSystem
  isPinnedOnProfile
  debateResponse
  rejected
  rejectedReason
  modGPTRecommendation
  originalDialogueId

  forumEventId
  forumEventMetadata
}

fragment CommentsListWithModGPTAnalysis on Comment {
  ...CommentsList
  post {
    ...PostsMinimumInfo
  }
  modGPTAnalysis
}

fragment CommentsListWithModerationMetadata on Comment {
  ...CommentWithRepliesFragment
  allVotes {
    voteType
  }
}

fragment CommentsListWithParentMetadata on Comment {
  ...CommentsList
  post {
    ...PostsMinimumInfo
    isRead
  }
  tag {
    ...TagBasicInfo
  }
}

fragment CommentsListWithTopLevelComment on Comment {
  ...CommentsList
  topLevelComment {
    ...CommentsList
  }
}

fragment ConceptItemFragment on Tag {
  _id
  core
  name
  slug
  oldSlugs
  postCount
  baseScore
  description {
    _id
    wordCount
  }
  wikiOnly
  isArbitalImport
  coreTagId
  maxScore
  usersWhoLiked {
    _id
    displayName
  }
}

fragment ConversationsDefaultFragment on Conversation {
  _id
  schemaVersion
  createdAt
  legacyData
  title
  participantIds
  latestActivity
  af
  messageCount
  moderator
  archivedByIds
}

fragment ConversationsList on Conversation {
  ...ConversationsMinimumInfo
  participants {
    ...UsersMinimumInfo
  }
  latestMessage {
    ...messageListFragment
  }
}

fragment ConversationsListWithReadStatus on Conversation {
  ...ConversationsList
  hasUnreadMessages
}

fragment ConversationsMinimumInfo on Conversation {
  _id
  createdAt
  latestActivity
  title
  participantIds
  archivedByIds
  messageCount
  moderator
}

fragment CronHistoriesDefaultFragment on CronHistory {
  _id
  intendedAt
  name
  startedAt
  finishedAt
  result
}

fragment CurationEmailsDefaultFragment on CurationEmail {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  postId
}

fragment CurationNoticesDefaultFragment on CurationNotice {
  _id
  schemaVersion
  createdAt
  legacyData
  contents_latest
  userId
  commentId
  postId
  deleted
}

fragment CurationNoticesFragment on CurationNotice {
  _id
  createdAt
  userId
  user {
    ...UsersMinimumInfo
  }
  commentId
  comment {
    ...CommentsList
  }
  postId
  post {
    ...PostsMinimumInfo
  }
  deleted
  contents {
    ...RevisionEdit
  }
}

fragment DatabaseMetadataDefaultFragment on DatabaseMetadata {
  _id
  schemaVersion
  createdAt
  legacyData
}

fragment DebouncerEventsDefaultFragment on DebouncerEvents {
  _id
  schemaVersion
  createdAt
  legacyData
}

fragment DeletedCommentsMetaData on Comment {
  _id
  deleted
  deletedDate
  deletedByUser {
    _id
    displayName
  }
  deletedReason
  deletedPublic
}

fragment DeletedCommentsModerationLog on Comment {
  ...DeletedCommentsMetaData
  user {
    ...UsersMinimumInfo
  }
  post {
    title
    slug
    _id
  }
}

fragment DialogueCheckInfo on DialogueCheck {
  _id
  userId
  targetUserId
  checked
  checkedAt
  hideInRecommendations
  matchPreference {
    ...DialogueMatchPreferencesDefaultFragment
  }
  reciprocalMatchPreference {
    ...DialogueMatchPreferencesDefaultFragment
  }
}

fragment DialogueChecksDefaultFragment on DialogueCheck {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  targetUserId
  checked
  checkedAt
  hideInRecommendations
}

fragment DialogueMatchPreferenceInfo on DialogueMatchPreference {
  _id
  dialogueCheckId
  topicNotes
  topicPreferences
  syncPreference
  asyncPreference
  formatNotes
  generatedDialogueId
  deleted
}

fragment DialogueMatchPreferencesDefaultFragment on DialogueMatchPreference {
  _id
  schemaVersion
  createdAt
  legacyData
  dialogueCheckId
  topicPreferences
  topicNotes
  syncPreference
  asyncPreference
  formatNotes
  calendlyLink
  generatedDialogueId
  deleted
}

fragment DigestPostsDefaultFragment on DigestPost {
  _id
  schemaVersion
  createdAt
  legacyData
  digestId
  postId
  emailDigestStatus
  onsiteDigestStatus
}

fragment DigestPostsMinimumInfo on DigestPost {
  _id
  digestId
  postId
  emailDigestStatus
  onsiteDigestStatus
}

fragment DigestsDefaultFragment on Digest {
  _id
  schemaVersion
  createdAt
  legacyData
  num
  startDate
  endDate
  publishedDate
  onsiteImageId
  onsitePrimaryColor
}

fragment DigestsMinimumInfo on Digest {
  _id
  num
  startDate
  endDate
  publishedDate
  onsiteImageId
  onsitePrimaryColor
}

fragment ElectionCandidateBasicInfo on ElectionCandidate {
  _id
  electionName
  name
  logoSrc
  href
  fundraiserLink
  gwwcLink
  gwwcId
  description
  tagId
  tag {
    ...TagBasicInfo
  }
  postCount
  baseScore
  score
  extendedScore
  voteCount
  currentUserVote
  currentUserExtendedVote
}

fragment ElectionCandidateSimple on ElectionCandidate {
  _id
  name
  logoSrc
  href
  fundraiserLink
  description
}

fragment ElectionCandidatesDefaultFragment on ElectionCandidate {
  _id
  schemaVersion
  createdAt
  legacyData
  electionName
  name
  logoSrc
  href
  fundraiserLink
  gwwcLink
  gwwcId
  description
  userId
  postCount
  tagId
  isElectionFundraiser
  amountRaised
  targetAmount
  voteCount
  baseScore
  extendedScore
  score
  afBaseScore
  afExtendedScore
  afVoteCount
}

fragment ElectionVoteInfo on ElectionVote {
  _id
  electionName
  userId
  compareState
  vote
  submittedAt
  submissionComments
  userExplanation
  userOtherComments
}

fragment ElectionVoteRecentDiscussion on ElectionVote {
  _id
  electionName
  submittedAt
}

fragment ElectionVotesDefaultFragment on ElectionVote {
  _id
  schemaVersion
  createdAt
  legacyData
  electionName
  userId
  compareState
  vote
  submittedAt
  submissionComments
  userExplanation
  userOtherComments
}

fragment ElicitQuestionFragment on ElicitQuestion {
  _id
  title
  notes
  resolution
  resolvesBy
}

fragment ElicitQuestionPredictionsDefaultFragment on ElicitQuestionPrediction {
  _id
  prediction
  createdAt
  notes
  creator
  userId
  sourceUrl
  sourceId
  binaryQuestionId
  isDeleted
}

fragment ElicitQuestionsDefaultFragment on ElicitQuestion {
  _id
  schemaVersion
  createdAt
  legacyData
  title
  notes
  resolution
  resolvesBy
}

fragment EmailTokensDefaultFragment on EmailTokens {
  _id
  schemaVersion
  createdAt
  legacyData
}

fragment ExplorePageTagFragment on Tag {
  ...TagFragment
  contributors(limit: $contributorsLimit) {
    totalCount
    contributors {
      user {
        ...UsersMinimumInfo
      }
      contributionScore
      currentAttributionCharCount
      numCommits
      voteCount
    }
  }
  legacyData
}

fragment FeaturedResourcesDefaultFragment on FeaturedResource {
  _id
  schemaVersion
  createdAt
  legacyData
  title
  body
  ctaText
  ctaUrl
  expiresAt
}

fragment FeaturedResourcesFragment on FeaturedResource {
  _id
  title
  body
  ctaText
  ctaUrl
  expiresAt
}

fragment FieldChangeFragment on FieldChange {
  _id
  createdAt
  userId
  changeGroup
  documentId
  fieldName
  oldValue
  newValue
}

fragment FieldChangesDefaultFragment on FieldChange {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  changeGroup
  documentId
  fieldName
  oldValue
  newValue
}

fragment ForumEventsDefaultFragment on ForumEvent {
  _id
  schemaVersion
  createdAt
  legacyData
  frontpageDescription_latest
  frontpageDescriptionMobile_latest
  postPageDescription_latest
  title
  startDate
  endDate
  darkColor
  lightColor
  bannerTextColor
  contrastColor
  tagId
  postId
  bannerImageId
  includesPoll
  eventFormat
  pollQuestion_latest
  pollAgreeWording
  pollDisagreeWording
  maxStickersPerUser
  customComponent
  commentPrompt
  publicData
}

fragment ForumEventsDisplay on ForumEvent {
  ...ForumEventsMinimumInfo
  publicData
  voteCount

  post {
    ...PostsMinimumInfo
  }
  tag {
    ...TagBasicInfo
  }
  frontpageDescription {
    _id
    html
  }
  frontpageDescriptionMobile {
    _id
    html
  }
  postPageDescription {
    _id
    html
  }
  pollQuestion {
    _id
    html
  }
}

fragment ForumEventsEdit on ForumEvent {
  ...ForumEventsMinimumInfo
  frontpageDescription {
    ...RevisionEdit
  }
  frontpageDescriptionMobile {
    ...RevisionEdit
  }
  postPageDescription {
    ...RevisionEdit
  }
  pollQuestion {
    ...RevisionEdit
  }
}

fragment ForumEventsMinimumInfo on ForumEvent {
  _id
  title
  startDate
  endDate
  darkColor
  lightColor
  bannerTextColor
  contrastColor
  tagId
  postId
  bannerImageId
  eventFormat
  customComponent
  commentPrompt

  pollAgreeWording
  pollDisagreeWording

  maxStickersPerUser
}

fragment GardenCodeFragment on GardenCode {
  _id
  code
  title
  userId
  deleted
  slug
  startTime
  endTime
  fbLink
  type
  afOnly
  contents {
    ...RevisionDisplay
  }
}

fragment GardenCodeFragmentEdit on GardenCode {
  _id
  code
  title
  userId
  deleted
  slug
  startTime
  endTime
  fbLink
  type
  afOnly
  contents {
    ...RevisionEdit
  }
}

fragment GardenCodesDefaultFragment on GardenCode {
  _id
  schemaVersion
  createdAt
  legacyData
  contents_latest
  pingbacks
  slug
  code
  title
  userId
  startTime
  endTime
  fbLink
  type
  hidden
  deleted
  afOnly
}

fragment GoogleServiceAccountSessionAdminInfo on GoogleServiceAccountSession {
  _id
  email
  estimatedExpiry
}

fragment GoogleServiceAccountSessionInfo on GoogleServiceAccountSession {
  _id
  email
}

fragment GoogleServiceAccountSessionsDefaultFragment on GoogleServiceAccountSession {
  _id
  schemaVersion
  createdAt
  legacyData
  email
  estimatedExpiry
  active
  revoked
}

fragment HighlightWithHash on Post {
  _id
  contents {
    _id
    htmlHighlightStartingAtHash(hash: $hash)
  }
}

fragment ImagesDefaultFragment on Images {
  _id
  schemaVersion
  createdAt
  legacyData
}

fragment JargonTerms on JargonTerm {
  _id
  postId
  term
  contents {
    ...RevisionEdit
  }
  humansAndOrAIEdited
  approved
  deleted
  altTerms
}

fragment JargonTermsDefaultFragment on JargonTerm {
  _id
  schemaVersion
  createdAt
  legacyData
  contents_latest
  postId
  term
  approved
  deleted
  altTerms
}

fragment JargonTermsPost on JargonTerm {
  _id
  term
  humansAndOrAIEdited
  approved
  deleted
  altTerms
  contents {
    ...RevisionDisplay
  }
}

fragment JargonTermsWithPostInfo on JargonTerm {
  ...JargonTerms
  post {
    ...PostsMinimumInfo
  }
}

fragment LWEventsDefaultFragment on LWEvent {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  name
  documentId
  important
  properties
  intercom
}

fragment LegacyDataDefaultFragment on LegacyData {
  _id
  schemaVersion
  createdAt
  legacyData
}

fragment LlmConversationsDefaultFragment on LlmConversation {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  title
  model
  systemPrompt
  deleted
}

fragment LlmConversationsFragment on LlmConversation {
  _id
  userId
  title
  createdAt
  lastUpdatedAt
  deleted
}

fragment LlmConversationsViewingPageFragment on LlmConversation {
  ...LlmConversationsFragment
  totalCharacterCount
  user {
    ...UsersMinimumInfo
  }
}

fragment LlmConversationsWithMessagesFragment on LlmConversation {
  ...LlmConversationsFragment
  messages {
    ...LlmMessagesFragment
  }
}

fragment LlmMessagesDefaultFragment on LlmMessage {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  conversationId
  role
  content
}

fragment LlmMessagesFragment on LlmMessage {
  _id
  userId
  conversationId
  role
  content
  createdAt
}

fragment LocalgroupsDefaultFragment on Localgroup {
  _id
  schemaVersion
  createdAt
  legacyData
  contents_latest
  name
  nameInAnotherLanguage
  organizerIds
  lastActivity
  types
  categories
  isOnline
  mongoLocation
  googleLocation
  location
  contactInfo
  facebookLink
  facebookPageLink
  meetupLink
  slackLink
  website
  bannerImageId
  inactive
  deleted
}

fragment ManifoldProbabilitiesCachesDefaultFragment on ManifoldProbabilitiesCache {
  _id
  schemaVersion
  createdAt
  legacyData
  marketId
  probability
  isResolved
  year
  lastUpdated
  url
}

fragment MembersOfGroupFragment on Subscription {
  user {
    ...UsersMinimumInfo
  }
}

fragment MessagesDefaultFragment on Message {
  _id
  schemaVersion
  createdAt
  legacyData
  contents_latest
  userId
  conversationId
  noEmail
}

fragment MigrationsDefaultFragment on Migration {
  _id
  schemaVersion
  createdAt
  legacyData
}

fragment ModerationTemplateFragment on ModerationTemplate {
  _id
  name
  collectionName
  order
  deleted
  contents {
    ...RevisionEdit
  }
}

fragment ModerationTemplatesDefaultFragment on ModerationTemplate {
  _id
  schemaVersion
  createdAt
  legacyData
  contents_latest
  name
  collectionName
  order
  deleted
}

fragment ModeratorActionDisplay on ModeratorAction {
  _id
  user {
    ...UsersMinimumInfo
  }
  userId
  type
  active
  createdAt
  endedAt
}

fragment ModeratorActionsDefaultFragment on ModeratorAction {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  type
  endedAt
}

fragment ModeratorClientIDInfo on ClientId {
  _id
  clientId
  createdAt
  firstSeenReferrer
  firstSeenLandingPage
  users {
    ...UsersMinimumInfo
  }
}

fragment MultiDocumentContentDisplay on MultiDocument {
  ...MultiDocumentMinimumInfo
  tableOfContents
  textLastUpdatedAt
  contents {
    ...RevisionEdit
  }
}

fragment MultiDocumentEdit on MultiDocument {
  ...MultiDocumentContentDisplay
  arbitalLinkedPages {
    ...ArbitalLinkedPagesFragment
  }
  summaries {
    ...MultiDocumentContentDisplay
  }
  textLastUpdatedAt
}

fragment MultiDocumentMinimumInfo on MultiDocument {
  _id
  parentDocumentId
  collectionName
  fieldName
  userId
  slug
  oldSlugs
  title
  tabTitle
  tabSubtitle
  preview
  index
  deleted
  createdAt
  legacyData

  baseScore
  extendedScore
  score
  afBaseScore
  afExtendedScore
  voteCount
  currentUserVote
  currentUserExtendedVote
}

fragment MultiDocumentParentDocument on MultiDocument {
  ...MultiDocumentEdit
  parentTag {
    ...TagHistoryFragment
  }
}

fragment MultiDocumentRevision on MultiDocument {
  ...MultiDocumentMinimumInfo
  contents(version: $version) {
    ...RevisionEdit
  }
  tableOfContents(version: $version)
}

fragment MultiDocumentWithContributors on MultiDocument {
  ...MultiDocumentEdit
  contributors {
    totalCount
    contributors {
      user {
        ...UsersMinimumInfo
      }
      currentAttributionCharCount
    }
  }
}

fragment MultiDocumentWithContributorsRevision on MultiDocument {
  ...MultiDocumentRevision
  contributors(version: $version) {
    totalCount
    contributors {
      user {
        ...UsersMinimumInfo
      }
      currentAttributionCharCount
      contributionScore
    }
  }
  arbitalLinkedPages {
    ...ArbitalLinkedPagesFragment
  }
  textLastUpdatedAt
}

fragment MultiDocumentsDefaultFragment on MultiDocument {
  _id
  schemaVersion
  createdAt
  legacyData
  contents_latest
  pingbacks
  slug
  oldSlugs
  title
  preview
  tabTitle
  tabSubtitle
  userId
  parentDocumentId
  collectionName
  fieldName
  index
  contributionStats
  htmlWithContributorAnnotations
  deleted
  voteCount
  baseScore
  extendedScore
  score
  afBaseScore
  afExtendedScore
  afVoteCount
}

fragment NotificationsDefaultFragment on Notification {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  documentId
  documentType
  extraData
  link
  title
  message
  type
  deleted
  viewed
  emailed
  waitingForBatch
}

fragment NotificationsList on Notification {
  _id
  documentId
  documentType
  deleted
  userId
  createdAt
  link
  message
  type
  viewed
  extraData
}

fragment PageCacheDefaultFragment on PageCacheEntry {
  _id
  schemaVersion
  createdAt
  legacyData
}

fragment PetrovDayActionInfo on PetrovDayAction {
  _id
  createdAt
  userId
  actionType
  data
}

fragment PetrovDayActionsDefaultFragment on PetrovDayAction {
  _id
  schemaVersion
  createdAt
  legacyData
  actionType
  data
  userId
}

fragment PetrovDayLaunchInfo on PetrovDayLaunch {
  _id
  createdAt
  launchCode
  userId
}

fragment PetrovDayLaunchsDefaultFragment on PetrovDayLaunch {
  _id
  schemaVersion
  createdAt
  legacyData
  launchCode
  hashedLaunchCode
  userId
}

fragment PodcastEpisodeFull on PodcastEpisode {
  _id
  podcastId
  title
  episodeLink
  externalEpisodeId
}

fragment PodcastEpisodesDefaultFragment on PodcastEpisode {
  _id
  schemaVersion
  createdAt
  legacyData
  podcastId
  title
  episodeLink
  externalEpisodeId
}

fragment PodcastSelect on Podcast {
  _id
  title
}

fragment PodcastsDefaultFragment on Podcast {
  _id
  schemaVersion
  createdAt
  legacyData
  title
  applePodcastLink
  spotifyPodcastLink
}

fragment PostEmbeddingsDefaultFragment on PostEmbedding {
  _id
  schemaVersion
  createdAt
  legacyData
  postId
  postHash
  lastGeneratedAt
  model
  embeddings
}

fragment PostForReviewWinnerItem on Post {
  _id
  spotlight {
    _id
  }
  reviewWinner {
    _id
    category
  }
}

fragment PostRecommendationsDefaultFragment on PostRecommendation {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  clientId
  postId
  strategyName
  strategySettings
  recommendationCount
  lastRecommendedAt
  clickedAt
}

fragment PostRelationsDefaultFragment on PostRelation {
  _id
  schemaVersion
  createdAt
  legacyData
  type
  sourcePostId
  targetPostId
  order
}

fragment PostSequenceNavigation on Post {
  # Prev/next sequence navigation
  sequence(sequenceId: $sequenceId) {
    ...SequencesPageFragment
  }
  prevPost(sequenceId: $sequenceId) {
    ...PostsListWithVotes
    sequence(sequenceId: $sequenceId, prevOrNext: "prev") {
      _id
    }
  }
  nextPost(sequenceId: $sequenceId) {
    ...PostsListWithVotes
    sequence(sequenceId: $sequenceId, prevOrNext: "next") {
      _id
    }
  }
}

fragment PostSideComments on Post {
  _id
  sideComments
  sideCommentsCache {
    ...SideCommentCacheMinimumInfo
  }
}

fragment PostViewTimesDefaultFragment on PostViewTime {
  _id
  schemaVersion
  createdAt
  legacyData
}

fragment PostViewsDefaultFragment on PostViews {
  _id
  schemaVersion
  createdAt
  legacyData
}

fragment PostWithDialogueMessage on Post {
  _id
  dialogueMessageContents(dialogueMessageId: $dialogueMessageId)
}

fragment PostWithGeneratedSummary on Post {
  _id
  languageModelSummary
}

fragment PostsAuthors on Post {
  user {
    ...UsersMinimumInfo
    profileImageId
      
    # Author moderation info
    moderationStyle
    bannedUserIds
    moderatorAssistance
  }
  coauthors {
    ...UsersMinimumInfo
  }
}

fragment PostsBase on Post {
  ...PostsMinimumInfo
    
  # Core fields
  url
  postedAt
  createdAt
  sticky
  metaSticky
  stickyPriority
  status
  frontpageDate
  meta
  deletedDraft
  postCategory
  tagRelevance

  shareWithUsers
  sharingSettings
  linkSharingKey

  contents_latest
  commentCount
  voteCount
  baseScore
  extendedScore
  emojiReactors
  unlisted
  score
  lastVisitedAt
  isFuture
  isRead
  lastCommentedAt
  lastCommentPromotedAt
  canonicalCollectionSlug
  curatedDate
  commentsLocked
  commentsLockedToAccountsCreatedAfter
  debate

  # questions
  question
  hiddenRelatedQuestion
  originalPostRelationSourceId

  userId
    
  # Local Event data
  location
  googleLocation
  onlineEvent
  globalEvent
  startTime
  endTime
  localStartTime
  localEndTime
  eventRegistrationLink
  joinEventLink
  facebookLink
  meetupLink
  website
  contactInfo
  isEvent
  eventImageId
  eventType
  types
  groupId

  # Review data 
  reviewedByUserId
  suggestForCuratedUserIds
  suggestForCuratedUsernames
  reviewForCuratedUserId
  authorIsUnreviewed

  # Alignment Forum
  afDate
  suggestForAlignmentUserIds
  reviewForAlignmentUserId
  afBaseScore
  afExtendedScore
  afCommentCount
  afLastCommentedAt
  afSticky
    
  hideAuthor
  moderationStyle
  ignoreRateLimits

  submitToFrontpage
  shortform
  onlyVisibleToLoggedIn
  onlyVisibleToEstablishedAccounts

  reviewCount
  reviewVoteCount
  positiveReviewVoteCount
  manifoldReviewMarketId

  annualReviewMarketProbability
  annualReviewMarketIsResolved
  annualReviewMarketYear
  annualReviewMarketUrl

  group {
    _id
    name
    organizerIds
  }
  rsvpCounts

  podcastEpisodeId
  forceAllowType3Audio

  # deprecated
  nominationCount2019
  reviewCount2019

  votingSystem
    
  disableRecommendation
}

fragment PostsBestOfList on Post {
  ...PostsListWithVotes
  podcastEpisode {
    _id
    title
    podcast {
      _id
      title
      applePodcastLink
      spotifyPodcastLink
    }
    episodeLink
    externalEpisodeId
  }
  socialPreviewData {
    _id
    text
    imageUrl
  }
  firstVideoAttribsForPreview
}

fragment PostsDefaultFragment on Post {
  _id
  schemaVersion
  createdAt
  legacyData
  contents_latest
  pingbacks
  moderationGuidelines_latest
  customHighlight_latest
  slug
  postedAt
  modifiedAt
  url
  postCategory
  title
  viewCount
  lastCommentedAt
  clickCount
  deletedDraft
  status
  isFuture
  sticky
  stickyPriority
  userIP
  userAgent
  referrer
  author
  userId
  question
  authorIsUnreviewed
  readTimeMinutesOverride
  submitToFrontpage
  hiddenRelatedQuestion
  originalPostRelationSourceId
  shortform
  canonicalSource
  nominationCount2018
  nominationCount2019
  reviewCount2018
  reviewCount2019
  reviewCount
  reviewVoteCount
  positiveReviewVoteCount
  manifoldReviewMarketId
  reviewVoteScoreAF
  reviewVotesAF
  reviewVoteScoreHighKarma
  reviewVotesHighKarma
  reviewVoteScoreAllKarma
  reviewVotesAllKarma
  finalReviewVoteScoreHighKarma
  finalReviewVotesHighKarma
  finalReviewVoteScoreAllKarma
  finalReviewVotesAllKarma
  finalReviewVoteScoreAF
  finalReviewVotesAF
  lastCommentPromotedAt
  tagRelevance
  noIndex
  rsvps
  activateRSVPs
  nextDayReminderSent
  onlyVisibleToLoggedIn
  onlyVisibleToEstablishedAccounts
  hideFromRecentDiscussions
  votingSystem
  podcastEpisodeId
  forceAllowType3Audio
  legacy
  legacyId
  legacySpam
  feedId
  feedLink
  curatedDate
  metaDate
  suggestForCuratedUserIds
  frontpageDate
  autoFrontpage
  collectionTitle
  coauthorStatuses
  hasCoauthorPermission
  socialPreviewImageId
  socialPreviewImageAutoUrl
  socialPreview
  fmCrosspost
  canonicalSequenceId
  canonicalCollectionSlug
  canonicalBookId
  canonicalNextPostSlug
  canonicalPrevPostSlug
  unlisted
  disableRecommendation
  defaultRecommendation
  hideFromPopularComments
  draft
  wasEverUndrafted
  meta
  hideFrontpageComments
  maxBaseScore
  scoreExceeded2Date
  scoreExceeded30Date
  scoreExceeded45Date
  scoreExceeded75Date
  scoreExceeded125Date
  scoreExceeded200Date
  bannedUserIds
  commentsLocked
  commentsLockedToAccountsCreatedAfter
  organizerIds
  groupId
  eventType
  isEvent
  reviewedByUserId
  reviewForCuratedUserId
  startTime
  localStartTime
  endTime
  localEndTime
  eventRegistrationLink
  joinEventLink
  onlineEvent
  globalEvent
  mongoLocation
  googleLocation
  location
  contactInfo
  facebookLink
  meetupLink
  website
  eventImageId
  types
  metaSticky
  sharingSettings
  shareWithUsers
  linkSharingKey
  linkSharingKeyUsedBy
  commentSortOrder
  hideAuthor
  sideCommentVisibility
  disableSidenotes
  moderationStyle
  ignoreRateLimits
  hideCommentKarma
  commentCount
  topLevelCommentCount
  debate
  collabEditorDialogue
  mostRecentPublishedDialogueResponseDate
  rejected
  rejectedReason
  rejectedByUserId
  subforumTagId
  af
  afDate
  afCommentCount
  afLastCommentedAt
  afSticky
  suggestForAlignmentUserIds
  reviewForAlignmentUserId
  agentFoundationsId
  swrCachingEnabled
  generateDraftJargon
  voteCount
  baseScore
  extendedScore
  score
  afBaseScore
  afExtendedScore
  afVoteCount
}

fragment PostsDetails on Post {
  ...PostsListBase

  canonicalSource
  noIndex
  viewCount
  tags {
    ...TagPreviewFragment
  }
  socialPreviewData {
    _id
    text
    imageUrl
  }
    
  # Tags
  tagRelevance
    
  # Posts-page display options
  commentSortOrder
  sideCommentVisibility
    
  # Sequence navigation
  collectionTitle
  canonicalPrevPostSlug
  canonicalNextPostSlug
  canonicalSequenceId
  canonicalBookId
  canonicalSequence {
    _id
    title
  }
  canonicalBook {
    _id
    title
  }
  canonicalCollection {
    _id
    title
  }

  # Podcast
  podcastEpisode {
    _id
    title
    podcast {
      _id
      title
      applePodcastLink
      spotifyPodcastLink
    }
    episodeLink
    externalEpisodeId
  }

  # Moderation stuff
  bannedUserIds
  moderationStyle
    
  # Voting
  currentUserVote
  currentUserExtendedVote
    
  # RSS metadata
  feedLink
  feed {
    ...RSSFeedMinimumInfo
  }
    
  # Related Questions
  sourcePostRelations {
    _id
    sourcePostId
    sourcePost {
      ...PostsListWithVotes
    }
    order
  }
  targetPostRelations {
    _id
    sourcePostId
    targetPostId
    targetPost {
      ...PostsListWithVotes
    }
    order
  }
    
  # Events
  rsvps
  activateRSVPs

  # Crossposting
  fmCrosspost

  # Jargon Terms
  glossary {
    ...JargonTermsPost
  }
}

fragment PostsEdit on Post {
  ...PostsDetails
  ...PostSideComments
  myEditorAccess
  version
  coauthorStatuses
  readTimeMinutesOverride
  fmCrosspost
  hideFromRecentDiscussions
  hideFromPopularComments
  moderationGuidelines {
    ...RevisionEdit
  }
  customHighlight {
    ...RevisionEdit
  }
  tableOfContents
  subforumTagId
  socialPreviewImageId
  socialPreview
  socialPreviewData {
    _id
    imageId
    text
  }
  user {
    ...UsersMinimumInfo
  }
  usersSharedWith {
    ...UsersMinimumInfo
  }
  coauthors {
    ...UsersMinimumInfo
  }
  generateDraftJargon
}

fragment PostsEditMutationFragment on Post {
  ...PostsEdit
  contents {
    ...RevisionEdit
  }
}

fragment PostsEditQueryFragment on Post {
  ...PostsEdit
  contents(version: $version) {
    ...RevisionEdit
  }
}

fragment PostsExpandedHighlight on Post {
  _id
  contents {
    _id
    html
  }
}

fragment PostsForAutocomplete on Post {
  _id
  title
  userId
  baseScore
  extendedScore
  user {
    ...UsersMinimumInfo
  }
  contents {
    markdown
  }
}

fragment PostsHTML on Post {
  _id
  contents {
    ...RevisionHTML
  }
}

fragment PostsList on Post {
  ...PostsListBase
  deletedDraft
  contents {
    _id
    htmlHighlight
    plaintextDescription
    wordCount
    version
  }
  fmCrosspost
}

fragment PostsListBase on Post {
  ...PostsBase
  ...PostsAuthors
  readTimeMinutes
  rejectedReason
  customHighlight {
    _id
    html
    plaintextDescription
  }
  lastPromotedComment {
    _id
    user {
      ...UsersMinimumInfo
    }
  }
  bestAnswer {
    ...CommentsList
  }
  tags {
    ...TagBasicInfo
  }
  socialPreviewData {
    _id
    imageUrl
  }

  feedId
  totalDialogueResponseCount
  unreadDebateResponseCount
  dialogTooltipPreview
  disableSidenotes
}

fragment PostsListTag on Post {
  ...PostsList
  tagRel(tagId: $tagId) {
    ...WithVoteTagRel
  }
}

fragment PostsListTagWithVotes on Post {
  ...PostsListWithVotes
  tagRel(tagId: $tagId) {
    ...WithVoteTagRel
  }
}

fragment PostsListWithVotes on Post {
  ...PostsList
  currentUserVote
  currentUserExtendedVote
}

fragment PostsListWithVotesAndSequence on Post {
  ...PostsListWithVotes
  canonicalSequence {
    ...SequencesPageFragment
  }
}

fragment PostsMinimumInfo on Post {
  _id
  slug
  title
  draft
  shortform
  hideCommentKarma
  af
  currentUserReviewVote {
    _id
    qualitativeScore
    quadraticScore
  }
  userId
  coauthorStatuses
  hasCoauthorPermission
  rejected
  debate
  collabEditorDialogue
}

fragment PostsModerationGuidelines on Post {
  ...PostsMinimumInfo
  frontpageDate
  user {
    _id
    displayName
    moderationStyle
  }
  moderationStyle
  moderationGuidelines {
    _id
    html
    originalContents {
      type
      data
    }
  }
}

fragment PostsOriginalContents on Post {
  _id
  contents {
    _id
    originalContents {
      type
      data
    }
  }
}

fragment PostsPage on Post {
  ...PostsDetails
  version
  contents {
    ...RevisionDisplay
  }
  customHighlight {
    ...RevisionDisplay
  }
  myEditorAccess
}

fragment PostsPlaintextDescription on Post {
  _id
  contents {
    _id
    plaintextDescription
  }
}

fragment PostsRSSFeed on Post {
  ...PostsPage
  scoreExceeded2Date
  scoreExceeded30Date
  scoreExceeded45Date
  scoreExceeded75Date
  scoreExceeded125Date
  scoreExceeded200Date
  metaDate
}

fragment PostsRecentDiscussion on Post {
  ...PostsListWithVotes
  recentComments(commentsLimit: $commentsLimit, maxAgeHours: $maxAgeHours, af: $af) {
    ...CommentsList
  }
}

fragment PostsReviewVotingList on Post {
  ...PostsListWithVotes
  reviewVoteScoreAllKarma
  reviewVotesAllKarma
  reviewVoteScoreHighKarma
  reviewVotesHighKarma
  reviewVoteScoreAF
  reviewVotesAF
}

fragment PostsRevision on Post {
  ...PostsDetails

  # Content & Revisions
  version
  contents(version: $version) {
    ...RevisionDisplay
  }
  revisions {
    ...RevisionMetadata
  }
}

fragment PostsRevisionEdit on Post {
  ...PostsDetails

  # Content & Revisions
  version
  contents(version: $version) {
    ...RevisionEdit
  }
  revisions {
    ...RevisionMetadata
  }
}

fragment PostsRevisionsList on Post {
  _id
  revisions {
    ...RevisionMetadata
  }
}

fragment PostsTopItemInfo on Post {
  ...PostsMinimumInfo
  ...PostsAuthors
  isRead
  contents {
    _id
    htmlHighlight
    wordCount
    version
  }
  customHighlight {
    _id
    html
  }
  tags {
    ...TagPreviewFragment
  }
  reviewWinner {
    ...ReviewWinnerTopPostsPage
  }
  spotlight {
    ...SpotlightReviewWinner
  }
  reviews {
    ...CommentsList
  }
  finalReviewVoteScoreHighKarma
}

fragment PostsTwitterAdmin on Post {
  ...PostsListWithVotes
  user {
    ...UsersSocialMediaInfo
  }
  coauthors {
    ...UsersSocialMediaInfo
  }
}

fragment PostsWithNavigation on Post {
  ...PostsPage
  ...PostSequenceNavigation
    
  tableOfContents
  reviewWinner {
    ...ReviewWinnerAll
  }
}

fragment PostsWithNavigationAndRevision on Post {
  ...PostsRevision
  ...PostSequenceNavigation
  customHighlight {
    ...RevisionDisplay
  }
    
  tableOfContentsRevision(version: $version)
  reviewWinner {
    ...ReviewWinnerAll
  }
}

fragment PostsWithVotes on Post {
  ...PostsBase
  currentUserVote
  currentUserExtendedVote
}

fragment RSSFeedMinimumInfo on RSSFeed {
  _id
  userId
  user {
    ...UsersMinimumInfo
  }
  createdAt
  ownedByUser
  displayFullContent
  nickname
  url
  importAsDraft
}

fragment RSSFeedMutationFragment on RSSFeed {
  _id
  userId
  ownedByUser
  displayFullContent
  nickname
  url
  importAsDraft
}

fragment RSSFeedsDefaultFragment on RSSFeed {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  ownedByUser
  displayFullContent
  nickname
  url
  status
  rawFeed
  setCanonicalUrl
  importAsDraft
}

fragment ReadStatusesDefaultFragment on ReadStatus {
  _id
  schemaVersion
  createdAt
  legacyData
}

fragment RecentDiscussionRevisionTagFragment on Revision {
  ...RevisionHistoryEntry
  tag {
    ...TagRecentDiscussion
  }
}

fragment RecommendationsCachesDefaultFragment on RecommendationsCache {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  postId
  source
  scenario
  attributionId
  ttlMs
}

fragment ReportsDefaultFragment on Report {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  reportedUserId
  commentId
  postId
  link
  claimedUserId
  description
  closedAt
  markedAsSpam
  reportedAsSpam
}

fragment ReviewVotesDefaultFragment on ReviewVote {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  postId
  qualitativeScore
  quadraticScore
  comment
  year
  dummy
  reactions
}

fragment ReviewWinnerAll on ReviewWinner {
  _id
  category
  curatedOrder
  postId
  reviewYear
  reviewRanking
  reviewWinnerArt {
    ...ReviewWinnerArtImages
  }
  competitorCount
}

fragment ReviewWinnerAnnouncement on ReviewWinner {
  _id
  category
  curatedOrder
  reviewYear
  reviewRanking
  competitorCount
  postId
  post {
    _id
    title
    slug
  }
}

fragment ReviewWinnerArtImages on ReviewWinnerArt {
  _id
  postId
  splashArtImagePrompt
  splashArtImageUrl
  activeSplashArtCoordinates {
    ...SplashArtCoordinatesEdit
  }
}

fragment ReviewWinnerArtsDefaultFragment on ReviewWinnerArt {
  _id
  schemaVersion
  createdAt
  legacyData
  postId
  splashArtImagePrompt
  splashArtImageUrl
}

fragment ReviewWinnerEditDisplay on ReviewWinner {
  _id
  postId
  reviewYear
  curatedOrder
  reviewRanking
}

fragment ReviewWinnerTopPostsDisplay on ReviewWinner {
  _id
  postId
  post {
    ...PostsTopItemInfo
  }
  reviewYear
  curatedOrder
  reviewRanking
}

fragment ReviewWinnerTopPostsPage on ReviewWinner {
  _id
  category
  curatedOrder
  reviewYear
  reviewRanking
  reviewWinnerArt {
    splashArtImageUrl
    activeSplashArtCoordinates {
      ...SplashArtCoordinatesEdit
    }
  }
}

fragment ReviewWinnersDefaultFragment on ReviewWinner {
  _id
  schemaVersion
  createdAt
  legacyData
  postId
  reviewYear
  category
  curatedOrder
  reviewRanking
  isAI
}

fragment RevisionDisplay on Revision {
  _id
  version
  updateType
  editedAt
  userId
  html
  commitMessage
  wordCount
  htmlHighlight
  plaintextDescription
}

fragment RevisionEdit on Revision {
  _id
  version
  updateType
  editedAt
  userId
  originalContents {
    type
    data
  }
  html
  markdown
  draftJS
  ckEditorMarkup
  wordCount
  htmlHighlight
  plaintextDescription
}

fragment RevisionHTML on Revision {
  _id
  html
}

fragment RevisionHistoryEntry on Revision {
  ...RevisionMetadata
  documentId
  collectionName
  changeMetrics
  legacyData
  skipAttributions
  user {
    ...UsersMinimumInfo
  }
}

fragment RevisionHistorySummaryEdit on Revision {
  ...RevisionHistoryEntry
  summary {
    ...MultiDocumentMinimumInfo
    parentTag {
      _id
      name
    }
    parentLens {
      _id
      title
      tabTitle
      tabSubtitle
    }
  }
}

fragment RevisionMetadata on Revision {
  _id
  version
  editedAt
  commitMessage
  userId
    
  score
  baseScore
  extendedScore
  voteCount
  currentUserVote
  currentUserExtendedVote
}

fragment RevisionMetadataWithChangeMetrics on Revision {
  ...RevisionMetadata
  changeMetrics
  user {
    ...UsersMinimumInfo
  }
}

fragment RevisionTagFragment on Revision {
  ...RevisionHistoryEntry
  tag {
    ...TagHistoryFragment
  }
  lens {
    ...MultiDocumentParentDocument
  }
}

fragment RevisionsDefaultFragment on Revision {
  _id
  schemaVersion
  createdAt
  legacyData
  documentId
  collectionName
  fieldName
  editedAt
  updateType
  version
  commitMessage
  userId
  draft
  originalContents
  html
  wordCount
  changeMetrics
  googleDocMetadata
  skipAttributions
  voteCount
  baseScore
  extendedScore
  score
  afBaseScore
  afExtendedScore
  afVoteCount
}

fragment SequenceContinueReadingFragment on Sequence {
  _id
  title
  gridImageId
  canonicalCollectionSlug
}

fragment SequencesDefaultFragment on Sequence {
  _id
  schemaVersion
  createdAt
  legacyData
  contents_latest
  lastUpdated
  userId
  title
  bannerImageId
  gridImageId
  hideFromAuthorPage
  draft
  isDeleted
  curatedOrder
  userProfileOrder
  canonicalCollectionSlug
  hidden
  noindex
  af
}

fragment SequencesEdit on Sequence {
  ...SequencesPageFragment
  contents { 
    ...RevisionEdit
  }
}

fragment SequencesPageFragment on Sequence {
  ...SequencesPageTitleFragment
  createdAt
  userId
  user {
    ...UsersMinimumInfo
  }
  contents {
    ...RevisionDisplay
  }
  gridImageId
  bannerImageId
  canonicalCollectionSlug
  draft
  isDeleted
  hidden
  hideFromAuthorPage
  noindex
  curatedOrder
  userProfileOrder
  af
  postsCount
  readPostsCount
}

fragment SequencesPageTitleFragment on Sequence {
  _id
  title
  canonicalCollectionSlug
  canonicalCollection {
    _id
    title
  }
}

fragment SequencesPageWithChaptersFragment on Sequence {
  ...SequencesPageFragment
  chapters {
    ...ChaptersFragment
  }
}

fragment SessionsDefaultFragment on Session {
  _id
  session
  expires
  lastModified
}

fragment SharedUserBooleans on User {
  walledGardenInvite
  hideWalledGardenUI
  walledGardenPortalOnboarded
  taggingDashboardCollapsed
  usernameUnset
}

fragment ShortformComments on Comment {
  ...CommentsList
  post {
    ...PostsMinimumInfo
  }
  relevantTags {
    ...TagPreviewFragment
  }
}

fragment ShortformRecentDiscussion on Post {
  ...PostsListWithVotes
  recentComments(commentsLimit: $commentsLimit, maxAgeHours: $maxAgeHours, af: $af) {
    ...CommentsListWithTopLevelComment
  }
}

fragment SideCommentCacheMinimumInfo on SideCommentCache {
  _id
  postId
  annotatedHtml
  commentsByBlock
  version
  createdAt
}

fragment SideCommentCachesDefaultFragment on SideCommentCache {
  _id
  schemaVersion
  createdAt
  legacyData
}

fragment SplashArtCoordinates on SplashArtCoordinate {
  _id
  reviewWinnerArtId
  leftXPct
  leftYPct
  leftHeightPct
  leftWidthPct
  leftFlipped
  middleXPct
  middleYPct
  middleHeightPct
  middleWidthPct
  middleFlipped
  rightXPct
  rightYPct
  rightHeightPct
  rightWidthPct
  rightFlipped
}

fragment SplashArtCoordinatesDefaultFragment on SplashArtCoordinate {
  _id
  schemaVersion
  createdAt
  legacyData
  reviewWinnerArtId
  leftXPct
  leftYPct
  leftHeightPct
  leftWidthPct
  leftFlipped
  middleXPct
  middleYPct
  middleHeightPct
  middleWidthPct
  middleFlipped
  rightXPct
  rightYPct
  rightHeightPct
  rightWidthPct
  rightFlipped
}

fragment SplashArtCoordinatesEdit on SplashArtCoordinate {
  ...SplashArtCoordinates
  createdAt
}

fragment SpotlightDisplay on Spotlight {
  ...SpotlightMinimumInfo
  post {
    ...PostsMinimumInfo
    user {
      _id
      displayName
      slug
    }
    reviews {
      ...CommentsList
    }
  }
  sequence {
    _id
    title
    user {
      _id
      displayName
      slug
    }
  }
  tag {
    _id
    name
    slug
    user {
      _id
      displayName
      slug
    }
  }
  sequenceChapters {
    ...ChaptersFragment
  }
  description {
    html
  }
}

fragment SpotlightEditQueryFragment on Spotlight {
  ...SpotlightMinimumInfo
  description {
    ...RevisionEdit
  }
}

fragment SpotlightHeaderEventSubtitle on Spotlight {
  ...SpotlightMinimumInfo
  post {
    _id
    slug
  }
  sequence {
    _id
  }
  tag {
    _id
    slug
  }
}

fragment SpotlightMinimumInfo on Spotlight {
  _id
  documentId
  documentType
  spotlightImageId
  spotlightDarkImageId
  spotlightSplashImageUrl
  draft
  deletedDraft
  position
  lastPromotedAt
  customTitle
  customSubtitle
  subtitleUrl
  headerTitle
  headerTitleLeftColor
  headerTitleRightColor
  duration
  showAuthor
  imageFade
  imageFadeColor
}

fragment SpotlightReviewWinner on Spotlight {
  ...SpotlightMinimumInfo
  description {
    html
  }
  sequenceChapters {
    ...ChaptersFragment
  }
}

fragment SpotlightsDefaultFragment on Spotlight {
  _id
  schemaVersion
  createdAt
  legacyData
  description_latest
  documentId
  documentType
  position
  duration
  customTitle
  customSubtitle
  subtitleUrl
  headerTitle
  headerTitleLeftColor
  headerTitleRightColor
  lastPromotedAt
  spotlightSplashImageUrl
  draft
  deletedDraft
  showAuthor
  imageFade
  imageFadeColor
  spotlightImageId
  spotlightDarkImageId
}

fragment StickySubforumCommentFragment on Comment {
  ...CommentWithRepliesFragment
  tag {
    ...TagBasicInfo
  }
}

fragment SubscribedPostAndCommentsFeed on SubscribedPostAndComments {
  _id
  post {
    ...PostsList
  }
  comments {
    ...CommentsList
  }
  expandCommentIds
  postIsFromSubscribedUser
}

fragment SubscriptionState on Subscription {
  _id
  userId
  createdAt
  state
  documentId
  collectionName
  deleted
  type
}

fragment SubscriptionsDefaultFragment on Subscription {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  state
  documentId
  collectionName
  deleted
  type
}

fragment SuggestAlignmentComment on Comment {
  ...CommentsList
  post {
    ...PostsMinimumInfo
  }
  suggestForAlignmentUserIds
  suggestForAlignmentUsers {
    _id
    displayName
  }
}

fragment SuggestAlignmentPost on Post {
  ...PostsList
  suggestForAlignmentUsers {
    _id
    displayName
  }
}

fragment SuggestAlignmentUser on User {
  ...UsersMinimumInfo
  afKarma
  afPostCount
  afCommentCount
  reviewForAlignmentForumUserId
  groups
  afApplicationText
  afSubmittedApplication
}

fragment SunshineCurationPostsList on Post {
  ...PostsList
  curationNotices {
    ...CurationNoticesFragment
  }
}

fragment SunshinePostsList on Post {
  ...PostsListBase

  currentUserVote
  currentUserExtendedVote
  fmCrosspost
  rejectedReason
  autoFrontpage

  contents {
    _id
    html
    htmlHighlight
    wordCount
    version
  }

  moderationGuidelines {
    _id
    html
  }

  user {
    ...UsersMinimumInfo
    biography {
      ...RevisionDisplay
    }
    profileImageId
      
    # Author moderation info
    moderationStyle
    bannedUserIds
    moderatorAssistance
      
    moderationGuidelines {
      _id
      html
    }

    needsReview
    moderatorActions {
      ...ModeratorActionDisplay
    }
  }
}

fragment SunshineTagFragment on Tag {
  ...TagFragment
  user {
    ...UsersMinimumInfo
  }
}

fragment SunshineUsersList on User {
  ...UsersMinimumInfo
  karma
  htmlBio
  website
  createdAt
  email
  emails
  commentCount
  maxCommentCount
  postCount
  maxPostCount
  voteCount
  smallUpvoteCount
  bigUpvoteCount
  smallDownvoteCount
  bigDownvoteCount
  banned
  reviewedByUserId
  reviewedAt
  signUpReCaptchaRating
  mapLocation
  needsReview
  sunshineNotes
  sunshineFlagged
  postingDisabled
  allCommentingDisabled
  commentingOnOtherUsersDisabled
  conversationsDisabled
  snoozedUntilContentCount
  nullifyVotes
  deleteContent
    
  moderatorActions {
    ...ModeratorActionDisplay
  }
  usersContactedBeforeReview
  associatedClientIds {
    clientId
    firstSeenReferrer
    firstSeenLandingPage
    userIds
  }
  altAccountsDetected

  voteReceivedCount
  smallUpvoteReceivedCount
  bigUpvoteReceivedCount
  smallDownvoteReceivedCount
  bigDownvoteReceivedCount

  recentKarmaInfo
  lastNotificationsCheck
}

fragment SurveyMinimumInfo on Survey {
  _id
  name
  questions {
    ...SurveyQuestionMinimumInfo
  }
  createdAt
}

fragment SurveyQuestionMinimumInfo on SurveyQuestion {
  _id
  question
  format
  order
}

fragment SurveyQuestionsDefaultFragment on SurveyQuestion {
  _id
  schemaVersion
  createdAt
  legacyData
  surveyId
  question
  format
  order
}

fragment SurveyResponseMinimumInfo on SurveyResponse {
  _id
  surveyId
  surveyScheduleId
  userId
  clientId
  response
}

fragment SurveyResponsesDefaultFragment on SurveyResponse {
  _id
  schemaVersion
  createdAt
  legacyData
  surveyId
  surveyScheduleId
  userId
  clientId
  response
}

fragment SurveyScheduleEdit on SurveySchedule {
  ...SurveyScheduleMinimumInfo
  surveyId
  name
  impressionsLimit
  maxVisitorPercentage
  minKarma
  maxKarma
  target
  startDate
  endDate
  deactivated
  createdAt
}

fragment SurveyScheduleMinimumInfo on SurveySchedule {
  _id
  survey {
    ...SurveyMinimumInfo
  }
}

fragment SurveySchedulesDefaultFragment on SurveySchedule {
  _id
  schemaVersion
  createdAt
  legacyData
  surveyId
  name
  impressionsLimit
  maxVisitorPercentage
  minKarma
  maxKarma
  target
  startDate
  endDate
  deactivated
  clientIds
}

fragment SurveysDefaultFragment on Survey {
  _id
  schemaVersion
  createdAt
  legacyData
  name
}

fragment TagBasicInfo on Tag {
  _id
  userId
  name
  shortName
  slug
  core
  postCount
  adminOnly
  canEditUserIds
  suggestedAsFilter
  needsReview
  descriptionTruncationCount
  createdAt
  wikiOnly
  deleted
  isSubforum
  noindex
  isArbitalImport
  isPlaceholderPage

  baseScore
  extendedScore
  score
  afBaseScore
  afExtendedScore
  voteCount
  currentUserVote
  currentUserExtendedVote
}

fragment TagCreationHistoryFragment on Tag {
  ...TagFragment
  user {
    ...UsersMinimumInfo
  }
  description {
    html
  }
}

fragment TagDetailedPreviewFragment on Tag {
  ...TagDetailsFragment
  description {
    _id
    htmlHighlight
  }
}

fragment TagDetailsFragment on Tag {
  ...TagBasicInfo
  subtitle
  oldSlugs
  isRead
  defaultOrder
  reviewedByUserId
  wikiGrade
  subforumModeratorIds
  subforumModerators {
    ...UsersMinimumInfo
  }
  moderationGuidelines {
    _id
    html
  }
  bannerImageId
  squareImageId
  lesswrongWikiImportSlug
  lesswrongWikiImportRevision
  sequence {
    ...SequencesPageFragment
  }
}

fragment TagEditFragment on Tag {
  ...TagDetailsFragment
  isPostType
  parentTagId
  parentTag {
    ...TagBasicInfo
  }
  subforumIntroPostId
  tagFlagsIds
  postsDefaultSortOrder
  introSequenceId
    
  autoTagModel
  autoTagPrompt
    
  description {
    ...RevisionEdit
  }
  subforumWelcomeText {
    ...RevisionEdit
  }
  moderationGuidelines {
    ...RevisionEdit
  }
}

fragment TagFlagEditFragment on TagFlag {
  ...TagFlagFragment
  contents {
    ...RevisionEdit
  }
}

fragment TagFlagFragment on TagFlag {
  _id
  createdAt
  name
  slug
  order
  deleted
  contents { 
    html
    htmlHighlight
    plaintextDescription
  }
}

fragment TagFlagsDefaultFragment on TagFlag {
  _id
  schemaVersion
  createdAt
  legacyData
  contents_latest
  slug
  name
  deleted
  order
}

fragment TagFragment on Tag {
  ...TagDetailsFragment
  parentTag {
    ...TagBasicInfo
  }
  subTags {
    ...TagBasicInfo
  }
  description {
    _id
    html
    htmlHighlight
    plaintextDescription
    version
    editedAt
  }
  canVoteOnRels
}

fragment TagFullContributorsList on Tag {
  contributors {
    totalCount
    contributors {
      user {
        ...UsersMinimumInfo
      }
      contributionScore
      currentAttributionCharCount
      numCommits
      voteCount
    }
  }
}

fragment TagHistoryFragment on Tag {
  ...TagFragment
  textLastUpdatedAt
  tableOfContents
  user {
    ...UsersMinimumInfo
  }
  lensesIncludingDeleted {
    ...MultiDocumentContentDisplay
  }
}

fragment TagName on Tag {
  _id
  name
  slug
}

fragment TagPageArbitalContentFragment on Tag {
  lenses {
    ...MultiDocumentWithContributors
  }
  arbitalLinkedPages {
    ...ArbitalLinkedPagesFragment
  }
}

fragment TagPageFragment on Tag {
  ...TagWithFlagsFragment
  tableOfContents
  postsDefaultSortOrder
  subforumIntroPost {
    ...PostsListWithVotes
  }
  subforumWelcomeText {
    _id
    html
  }
  contributors(limit: $contributorsLimit) {
    totalCount
    contributors {
      user {
        ...UsersMinimumInfo
      }
      contributionScore
      currentAttributionCharCount
      numCommits
      voteCount
    }
  }
  canVoteOnRels
  forceAllowType3Audio
  textLastUpdatedAt
}

fragment TagPageRevisionWithArbitalContentFragment on Tag {
  ...TagPageWithRevisionFragment
  ...TagPageArbitalContentFragment
}

fragment TagPageWithArbitalContentAndLensRevisionFragment on Tag {
  ...TagPageFragment
  arbitalLinkedPages {
    ...ArbitalLinkedPagesFragment
  }
  lenses(lensSlug: $lensSlug, version: $version) {
    ...MultiDocumentWithContributorsRevision
  }
}

fragment TagPageWithArbitalContentFragment on Tag {
  ...TagPageFragment
  ...TagPageArbitalContentFragment
}

fragment TagPageWithRevisionFragment on Tag {
  ...TagWithFlagsAndRevisionFragment
  tableOfContents(version: $version)
  textLastUpdatedAt
  postsDefaultSortOrder
  subforumIntroPost {
    ...PostsListWithVotes
  }
  subforumWelcomeText {
    _id
    html
  }
  contributors(limit: $contributorsLimit, version: $version) {
    totalCount
    contributors {
      user {
        ...UsersMinimumInfo
      }
      contributionScore
      currentAttributionCharCount
      numCommits
      voteCount
    }
  }
  canVoteOnRels
  forceAllowType3Audio
}

fragment TagPreviewFragment on Tag {
  ...TagBasicInfo
  isRead
  parentTag {
    ...TagBasicInfo
  }
  subTags {
    ...TagBasicInfo
  }
  description {
    _id
    htmlHighlight
  }
  canVoteOnRels
  isArbitalImport
}

fragment TagRecentDiscussion on Tag {
  ...TagFragment
  lastVisitedAt
  recentComments(tagCommentsLimit: $tagCommentsLimit, maxAgeHours: $maxAgeHours, af: $af) {
    ...CommentsList
  }
}

fragment TagRelBasicInfo on TagRel {
  _id
  score
  baseScore
  extendedScore
  afBaseScore
  voteCount
  tagId
  postId
  autoApplied
}

fragment TagRelCreationFragment on TagRel {
  ...TagRelBasicInfo
  tag {
    ...TagPreviewFragment
  }
  post {
    ...PostsList
    tagRelevance
    tagRel(tagId: $tagId) {
      ...WithVoteTagRel
    }
  }
  currentUserVote
  currentUserExtendedVote
}

fragment TagRelFragment on TagRel {
  ...TagRelBasicInfo
  tag {
    ...TagPreviewFragment
  }
  post {
    ...PostsList
  }
  currentUserVote
  currentUserExtendedVote
  currentUserCanVote
}

fragment TagRelHistoryFragment on TagRel {
  ...TagRelBasicInfo
  createdAt
  user {
    ...UsersMinimumInfo
  }
  post {
    ...PostsList
  }
}

fragment TagRelMinimumFragment on TagRel {
  ...TagRelBasicInfo
  tag {
    ...TagPreviewFragment
  }
  currentUserVote
  currentUserExtendedVote
  currentUserCanVote
}

fragment TagRelVotes on Vote {
  _id
  userId
  voteType
  power
  documentId
  votedAt
  isUnvote
  tagRel {
    ...WithVoteTagRel
  }
}

fragment TagRelsDefaultFragment on TagRel {
  _id
  schemaVersion
  createdAt
  legacyData
  tagId
  postId
  deleted
  userId
  backfilled
  voteCount
  baseScore
  extendedScore
  score
  afBaseScore
  afExtendedScore
  afVoteCount
}

fragment TagRevisionFragment on Tag {
  ...TagDetailsFragment
  parentTag {
    ...TagBasicInfo
  }
  subTags {
    ...TagBasicInfo
  }
  isRead
  description(version: $version) {
    _id
    version
    html
    htmlHighlight
    plaintextDescription
    editedAt
      
    user {
      ...UsersMinimumInfo
    }
  }
}

fragment TagSectionPreviewFragment on Tag {
  ...TagBasicInfo
  isRead
  parentTag {
    ...TagBasicInfo
  }
  subTags {
    ...TagBasicInfo
  }
  description {
    _id
    htmlHighlightStartingAtHash(hash: $hash)
  }
  canVoteOnRels
}

fragment TagSubforumFragment on Tag {
  ...TagPreviewFragment
  subforumModeratorIds
  tableOfContents
  subforumWelcomeText {
    _id
    html
  }
}

fragment TagSubforumSidebarFragment on Tag {
  ...TagBasicInfo
}

fragment TagSubtagFragment on Tag {
  _id
  subforumModeratorIds
  subTags {
    ...TagPreviewFragment
  }
}

fragment TagVotingActivity on Vote {
  ...TagRelVotes
  tagRel {
    ...TagRelFragment
  }
}

fragment TagWithFlagsAndRevisionFragment on Tag {
  ...TagRevisionFragment
  tagFlagsIds
  tagFlags {
    ...TagFlagFragment
  }
}

fragment TagWithFlagsFragment on Tag {
  ...TagFragment
  tagFlagsIds
  tagFlags {
    ...TagFlagFragment
  }
}

fragment TagsDefaultFragment on Tag {
  _id
  schemaVersion
  createdAt
  legacyData
  description_latest
  pingbacks
  subforumWelcomeText_latest
  moderationGuidelines_latest
  slug
  oldSlugs
  name
  shortName
  subtitle
  core
  isPostType
  suggestedAsFilter
  defaultOrder
  descriptionTruncationCount
  postCount
  userId
  adminOnly
  canEditUserIds
  charsAdded
  charsRemoved
  deleted
  lastCommentedAt
  lastSubforumCommentAt
  needsReview
  reviewedByUserId
  wikiGrade
  wikiOnly
  bannerImageId
  squareImageId
  tagFlagsIds
  lesswrongWikiImportRevision
  lesswrongWikiImportSlug
  lesswrongWikiImportCompleted
  htmlWithContributorAnnotations
  contributionStats
  introSequenceId
  postsDefaultSortOrder
  canVoteOnRels
  isSubforum
  subforumModeratorIds
  subforumIntroPostId
  parentTagId
  subTagIds
  autoTagModel
  autoTagPrompt
  noindex
  isPlaceholderPage
  coreTagId
  forceAllowType3Audio
  voteCount
  baseScore
  extendedScore
  score
  afBaseScore
  afExtendedScore
  afVoteCount
}

fragment TestCollection2DefaultFragment on undefined {
  _id
  data
  schemaVersion
}

fragment TestCollection3DefaultFragment on undefined {
  _id
  notNullData
}

fragment TestCollection4DefaultFragment on undefined {
  _id
  testCollection3Id
  schemaVersion
}

fragment TestCollection5DefaultFragment on undefined {
  _id
  jsonField
  schemaVersion
}

fragment TestCollectionDefaultFragment on undefined {
  _id
  a
  b
  c
  d
  schemaVersion
}

fragment TweetsDefaultFragment on Tweet {
  _id
  schemaVersion
  createdAt
  legacyData
}

fragment TypingIndicatorInfo on TypingIndicator {
  _id
  userId
  documentId
  lastUpdated
}

fragment TypingIndicatorsDefaultFragment on TypingIndicator {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  documentId
  lastUpdated
}

fragment UnclaimedReportsList on Report {
  _id
  userId
  user {
    ...UsersMinimumInfo
  }
  commentId
  comment {
    ...CommentsList
    post {
      ...PostsMinimumInfo
    }
    tag {
      ...TagBasicInfo
    }
  }
  postId
  post {
    ...PostsList
  }
  reportedUser {
    ...SunshineUsersList
  }
  closedAt
  createdAt
  claimedUserId
  claimedUser {
    _id
    displayName
    username
    slug
  }
  link
  description
  reportedAsSpam
  markedAsSpam
}

fragment UserActivitiesDefaultFragment on UserActivity {
  _id
  schemaVersion
  createdAt
  legacyData
}

fragment UserAltAccountsFragment on User {
  ...SunshineUsersList
  IPs
}

fragment UserBookmarkedPosts on User {
  _id
  bookmarkedPosts {
    ...PostsList
  }
}

fragment UserEAGDetailsDefaultFragment on UserEAGDetail {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  careerStage
  countryOrRegion
  nearestCity
  willingnessToRelocate
  experiencedIn
  interestedIn
  lastUpdated
}

fragment UserEAGDetailsMinimumInfo on UserEAGDetail {
  _id
  userId
  createdAt
  lastUpdated
  careerStage
  countryOrRegion
  nearestCity
  willingnessToRelocate
  experiencedIn
  interestedIn
}

fragment UserJobAdsDefaultFragment on UserJobAd {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  jobName
  adState
  reminderSetAt
  lastUpdated
}

fragment UserJobAdsMinimumInfo on UserJobAd {
  _id
  userId
  createdAt
  lastUpdated
  jobName
  adState
  reminderSetAt
}

fragment UserKarmaChanges on User {
  _id
  karmaChanges {
    totalChange
    updateFrequency
    startDate
    endDate
    nextBatchDate
    posts {
      _id
      scoreChange
      postId
      title
      slug
      addedReacts {
        reactionType
        userId
      }
      eaAddedReacts
    }
    comments {
      _id
      scoreChange
      commentId
      description
      postId
      postTitle
      postSlug
      tagSlug
      tagName
      tagCommentType
      addedReacts {
        reactionType
        userId
      }
      eaAddedReacts
    }
    tagRevisions {
      _id
      scoreChange
      tagId
      tagSlug
      tagName
      addedReacts {
        reactionType
        userId
      }
      eaAddedReacts
    }
    todaysKarmaChanges {
      posts {
        _id
        scoreChange
        postId
        title
        slug
        addedReacts {
          reactionType
          userId
        }
        eaAddedReacts
      }
      comments {
        _id
        scoreChange
        commentId
        description
        postId
        postTitle
        postSlug
        tagSlug
        tagName
        tagCommentType
        addedReacts {
          reactionType
          userId
        }
        eaAddedReacts
      }
      tagRevisions {
        _id
        scoreChange
        tagId
        tagSlug
        tagName
        addedReacts {
          reactionType
          userId
        }
        eaAddedReacts
      }
    }
    thisWeeksKarmaChanges {
      posts {
        _id
        scoreChange
        postId
        title
        slug
        addedReacts {
          reactionType
          userId
        }
        eaAddedReacts
      }
      comments {
        _id
        scoreChange
        commentId
        description
        postId
        postTitle
        postSlug
        tagSlug
        tagName
        tagCommentType
        addedReacts {
          reactionType
          userId
        }
        eaAddedReacts
      }
      tagRevisions {
        _id
        scoreChange
        tagId
        tagSlug
        tagName
        addedReacts {
          reactionType
          userId
        }
        eaAddedReacts
      }
    }
  }
}

fragment UserMostValuablePostInfo on UserMostValuablePost {
  _id
  userId
  postId
  deleted
}

fragment UserMostValuablePostsDefaultFragment on UserMostValuablePost {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  postId
  deleted
}

fragment UserOnboardingAuthor on User {
  _id
  displayName
  profileImageId
  karma
  jobTitle
  organization
}

fragment UserOnboardingTag on Tag {
  _id
  name
  slug
  bannerImageId
  squareImageId
}

fragment UserRateLimitDisplay on UserRateLimit {
  _id
  user {
    ...UsersMinimumInfo
  }
  userId
  type
  actionsPerInterval
  intervalUnit
  intervalLength
  createdAt
  endedAt
}

fragment UserRateLimitsDefaultFragment on UserRateLimit {
  _id
  schemaVersion
  createdAt
  legacyData
  userId
  type
  intervalUnit
  intervalLength
  actionsPerInterval
  endedAt
}

fragment UserTagRelDetails on UserTagRel {
  _id
  userId
  tagId
  subforumShowUnreadInSidebar
  subforumEmailNotifications
  subforumHideIntroPost
}

fragment UserTagRelsDefaultFragment on UserTagRel {
  _id
  schemaVersion
  createdAt
  legacyData
  tagId
  userId
  subforumShowUnreadInSidebar
  subforumEmailNotifications
  subforumHideIntroPost
}

fragment UserVotes on Vote {
  _id
  userId
  voteType
  power
  cancelled
  documentId
  votedAt
  isUnvote
  collectionName
}

fragment UserVotesWithDocument on Vote {
  ...UserVotes
  comment {
    ...CommentsListWithParentMetadata
  }
  post {
    ...PostsListWithVotes
  }
}

fragment UsersAdmin on User {
  _id
  username
  createdAt
  isAdmin
  displayName
  email
  slug
  groups
  services
  karma
}

fragment UsersBannedFromPostsModerationLog on Post {
  user {
    ...UsersMinimumInfo
  }
  title
  slug
  _id
  bannedUserIds
}

fragment UsersBannedFromUsersModerationLog on User {
  _id
  slug
  displayName
  bannedUserIds
  bannedPersonalUserIds
}

fragment UsersCrosspostInfo on User {
  _id
  username
  slug
  fmCrosspostUserId
}

fragment UsersCurrent on User {
  ...UsersProfile

  beta
  email
  services
  acceptedTos
  pageUrl
  banned
  isReviewed
  nullifyVotes
  hideIntercom
  hideNavigationSidebar
  hideCommunitySection
  expandedFrontpageSections
  hidePostsRecommendations
  currentFrontpageFilter
  frontpageSelectedTab
  frontpageFilterSettings
  hideFrontpageFilterSettingsDesktop
  allPostsTimeframe
  allPostsSorting
  allPostsFilter
  allPostsShowLowKarma
  allPostsIncludeEvents
  allPostsHideCommunity
  allPostsOpenSettings
  draftsListSorting
  draftsListShowArchived
  draftsListShowShared
  lastNotificationsCheck
  bannedUserIds
  bannedPersonalUserIds
  moderationStyle
  noKibitz
  showHideKarmaOption
  markDownPostEditor
  hideElicitPredictions
  hideAFNonMemberInitialWarning
  commentSorting
  location
  googleLocation
  mongoLocation
  mapLocation
  mapLocationSet
  mapMarkerText
  htmlMapMarkerText
  nearbyEventsNotifications
  nearbyEventsNotificationsLocation
  nearbyEventsNotificationsRadius
  nearbyPeopleNotificationThreshold
  hideFrontpageMap
  emailSubscribedToCurated
  subscribedToDigest
  unsubscribeFromAll
  emails
  whenConfirmationEmailSent
  hideSubscribePoke
  hideMeetupsPoke
  hideHomeRHS
  noCollapseCommentsFrontpage
  noCollapseCommentsPosts
  noSingleLineComments
  showCommunityInRecentDiscussion
  karmaChangeNotifierSettings
  karmaChangeLastOpened
  shortformFeedId
  viewUnreviewedComments
  recommendationSettings
  theme

  bookmarkedPostsMetadata

  hiddenPostsMetadata
  auto_subscribe_to_my_posts
  auto_subscribe_to_my_comments
  autoSubscribeAsOrganizer
  noExpandUnreadCommentsReview
  reviewVotesQuadratic
  reviewVotesQuadratic2019
  reviewVotesQuadratic2020
  hideTaggingProgressBar
  hideFrontpageBookAd
  hideFrontpageBook2019Ad

  abTestKey
  abTestOverrides

  sortDraftsBy
  reactPaletteStyle

  petrovPressedButtonDate
  petrovLaunchCodeDate
  petrovOptOut
  lastUsedTimezone
  ...SharedUserBooleans

  acknowledgedNewUserGuidelines
  notificationSubforumUnread
  subforumPreferredLayout
    
  hideJobAdUntil
  criticismTipsDismissed
    
  allowDatadogSessionReplay
  hideFrontpageBook2020Ad

  hideDialogueFacilitation
  optedInToDialogueFacilitation
  revealChecksToAdmins
  notificationNewDialogueChecks
  notificationYourTurnMatchForm

  showDialoguesList
  showMyDialogues
  showMatches
  showRecommendedPartners
  hideActiveDialogueUsers

  hideSunshineSidebar
  optedOutOfSurveys
  postGlossariesPinned
  generateJargonForDrafts
  generateJargonForPublishedPosts
}

fragment UsersCurrentCommentRateLimit on User {
  _id
  rateLimitNextAbleToComment(postId: $postId)
}

fragment UsersCurrentPostRateLimit on User {
  _id
  rateLimitNextAbleToPost(eventForm: $eventForm)
}

fragment UsersDefaultFragment on User {
  _id
  schemaVersion
  createdAt
  legacyData
  moderationGuidelines_latest
  howOthersCanHelpMe_latest
  howICanHelpOthers_latest
  slug
  oldSlugs
  biography_latest
  username
  emails
  isAdmin
  services
  displayName
  previousDisplayName
  email
  noindex
  groups
  lwWikiImport
  theme
  lastUsedTimezone
  whenConfirmationEmailSent
  legacy
  commentSorting
  sortDraftsBy
  reactPaletteStyle
  noKibitz
  showHideKarmaOption
  showPostAuthorCard
  hideIntercom
  markDownPostEditor
  hideElicitPredictions
  hideAFNonMemberInitialWarning
  noSingleLineComments
  noCollapseCommentsPosts
  noCollapseCommentsFrontpage
  hideCommunitySection
  expandedFrontpageSections
  showCommunityInRecentDiscussion
  hidePostsRecommendations
  petrovOptOut
  optedOutOfSurveys
  postGlossariesPinned
  generateJargonForDrafts
  generateJargonForPublishedPosts
  acceptedTos
  hideNavigationSidebar
  currentFrontpageFilter
  frontpageSelectedTab
  frontpageFilterSettings
  hideFrontpageFilterSettingsDesktop
  allPostsTimeframe
  allPostsFilter
  allPostsSorting
  allPostsShowLowKarma
  allPostsIncludeEvents
  allPostsHideCommunity
  allPostsOpenSettings
  draftsListSorting
  draftsListShowArchived
  draftsListShowShared
  lastNotificationsCheck
  karma
  goodHeartTokens
  moderationStyle
  moderatorAssistance
  collapseModerationGuidelines
  bannedUserIds
  bannedPersonalUserIds
  bookmarkedPostsMetadata
  hiddenPostsMetadata
  legacyId
  deleted
  permanentDeletionRequestedAt
  voteBanned
  nullifyVotes
  deleteContent
  banned
  auto_subscribe_to_my_posts
  auto_subscribe_to_my_comments
  autoSubscribeAsOrganizer
  notificationCommentsOnSubscribedPost
  notificationShortformContent
  notificationRepliesToMyComments
  notificationRepliesToSubscribedComments
  notificationSubscribedUserPost
  notificationSubscribedUserComment
  notificationPostsInGroups
  notificationSubscribedTagPost
  notificationSubscribedSequencePost
  notificationPrivateMessage
  notificationSharedWithMe
  notificationAlignmentSubmissionApproved
  notificationEventInRadius
  notificationKarmaPowersGained
  notificationRSVPs
  notificationGroupAdministration
  notificationCommentsOnDraft
  notificationPostsNominatedReview
  notificationSubforumUnread
  notificationNewMention
  notificationDialogueMessages
  notificationPublishedDialogueMessages
  notificationAddedAsCoauthor
  notificationDebateCommentsOnSubscribedPost
  notificationDebateReplies
  notificationDialogueMatch
  notificationNewDialogueChecks
  notificationYourTurnMatchForm
  hideDialogueFacilitation
  revealChecksToAdmins
  optedInToDialogueFacilitation
  showDialoguesList
  showMyDialogues
  showMatches
  showRecommendedPartners
  hideActiveDialogueUsers
  karmaChangeNotifierSettings
  karmaChangeLastOpened
  karmaChangeBatchStart
  emailSubscribedToCurated
  subscribedToDigest
  unsubscribeFromAll
  hideSubscribePoke
  hideMeetupsPoke
  hideHomeRHS
  frontpagePostCount
  sequenceCount
  sequenceDraftCount
  mongoLocation
  googleLocation
  location
  mapLocation
  mapLocationSet
  mapMarkerText
  htmlMapMarkerText
  nearbyEventsNotifications
  nearbyEventsNotificationsLocation
  nearbyEventsNotificationsMongoLocation
  nearbyEventsNotificationsRadius
  nearbyPeopleNotificationThreshold
  hideFrontpageMap
  hideTaggingProgressBar
  hideFrontpageBookAd
  hideFrontpageBook2019Ad
  hideFrontpageBook2020Ad
  sunshineNotes
  sunshineFlagged
  needsReview
  sunshineSnoozed
  snoozedUntilContentCount
  reviewedByUserId
  reviewedAt
  afKarma
  voteCount
  smallUpvoteCount
  smallDownvoteCount
  bigUpvoteCount
  bigDownvoteCount
  voteReceivedCount
  smallUpvoteReceivedCount
  smallDownvoteReceivedCount
  bigUpvoteReceivedCount
  bigDownvoteReceivedCount
  usersContactedBeforeReview
  fullName
  shortformFeedId
  viewUnreviewedComments
  partiallyReadSequences
  beta
  reviewVotesQuadratic
  reviewVotesQuadratic2019
  reviewVotesQuadratic2020
  petrovPressedButtonDate
  petrovLaunchCodeDate
  defaultToCKEditor
  signUpReCaptchaRating
  noExpandUnreadCommentsReview
  postCount
  maxPostCount
  commentCount
  maxCommentCount
  tagRevisionCount
  abTestKey
  abTestOverrides
  reenableDraftJs
  walledGardenInvite
  hideWalledGardenUI
  walledGardenPortalOnboarded
  taggingDashboardCollapsed
  usernameUnset
  paymentEmail
  paymentInfo
  profileUpdatedAt
  profileImageId
  jobTitle
  organization
  careerStage
  website
  fmCrosspostUserId
  linkedinProfileURL
  facebookProfileURL
  blueskyProfileURL
  twitterProfileURL
  twitterProfileURLAdmin
  githubProfileURL
  profileTagIds
  organizerOfGroupIds
  programParticipation
  postingDisabled
  allCommentingDisabled
  commentingOnOtherUsersDisabled
  conversationsDisabled
  acknowledgedNewUserGuidelines
  subforumPreferredLayout
  hideJobAdUntil
  criticismTipsDismissed
  hideFromPeopleDirectory
  allowDatadogSessionReplay
  afPostCount
  afCommentCount
  afSequenceCount
  afSequenceDraftCount
  reviewForAlignmentForumUserId
  afApplicationText
  afSubmittedApplication
  hideSunshineSidebar
  inactiveSurveyEmailSentAt
  userSurveyEmailSentAt
  recommendationSettings
}

fragment UsersEdit on User {
  ...UsersCurrent
  biography {
    ...RevisionEdit
  }
  # Moderation Guidelines editor information
  moderationGuidelines {
    ...RevisionEdit
  }

  # UI Settings
  markDownPostEditor
  hideElicitPredictions
  hideAFNonMemberInitialWarning
  hideIntercom
  commentSorting
  currentFrontpageFilter
  noCollapseCommentsPosts
  noCollapseCommentsFrontpage
  noSingleLineComments
  hideCommunitySection
  showCommunityInRecentDiscussion
  hidePostsRecommendations
  beta
  theme

  # Emails
  email
  whenConfirmationEmailSent
  emailSubscribedToCurated
  subscribedToDigest
  unsubscribeFromAll
  hasAuth0Id

  # Moderation
  moderatorAssistance
  collapseModerationGuidelines
  bannedUserIds
  bannedPersonalUserIds
  noKibitz
  showHideKarmaOption

  # Ban & Purge
  nullifyVotes
  deleteContent
  banned

  # Name
  username
  displayName
  fullName

  # Location
  mongoLocation
  googleLocation
  location
    
  # Map Location (public)
  mapLocation
    
  # Privacy settings
  hideFromPeopleDirectory
  allowDatadogSessionReplay

  # Admin & Review
  reviewedByUserId

  # Alignment Forum
  reviewForAlignmentForumUserId
  groups
  afApplicationText
  afSubmittedApplication

  # Karma Settings
  karmaChangeLastOpened
  karmaChangeNotifierSettings

  notificationShortformContent
  notificationCommentsOnSubscribedPost
  notificationRepliesToMyComments
  notificationRepliesToSubscribedComments
  notificationSubscribedUserPost
  notificationSubscribedUserComment
  notificationSubscribedTagPost
  notificationSubscribedSequencePost
  notificationPostsInGroups
  notificationPrivateMessage
  notificationSharedWithMe
  notificationAlignmentSubmissionApproved
  notificationEventInRadius
  notificationRSVPs
  notificationCommentsOnDraft
  notificationPostsNominatedReview
  notificationGroupAdministration
  notificationSubforumUnread
  notificationNewMention
  notificationNewDialogueChecks
  notificationYourTurnMatchForm

  hideFrontpageMap
  hideTaggingProgressBar
  hideFrontpageBookAd
  hideFrontpageBook2020Ad

  deleted
  permanentDeletionRequestedAt

  twitterProfileURLAdmin
}

fragment UsersMapEntry on User {
  _id
  displayName
  username
  fullName
  slug
  mapLocationLatLng {
    lat
    lng
  }
  mapLocationSet
  htmlMapMarkerText
}

fragment UsersMinimumInfo on User {
  _id
  slug
  createdAt
  username
  displayName
  profileImageId
  previousDisplayName
  fullName
  karma
  afKarma
  deleted
  isAdmin
  htmlBio
  jobTitle
  organization
  postCount
  commentCount
  sequenceCount
  afPostCount
  afCommentCount
  spamRiskScore
  tagRevisionCount
  reviewedByUserId
}

fragment UsersOptedInToDialogueFacilitation on User {
  _id
  displayName
}

fragment UsersProfile on User {
  ...UsersMinimumInfo
  oldSlugs
  groups
  jobTitle
  organization
  careerStage
  biography {
    ...RevisionDisplay
  }
  howOthersCanHelpMe {
    ...RevisionDisplay
  }
  howICanHelpOthers {
    ...RevisionDisplay
  }
  profileTagIds
  profileTags {
    ...TagPreviewFragment
  }
  organizerOfGroupIds
  organizerOfGroups {
    ...localGroupsBase
  }
  programParticipation
  website
  linkedinProfileURL
  facebookProfileURL
  blueskyProfileURL
  twitterProfileURL
  githubProfileURL
  frontpagePostCount
  afSequenceCount
  afSequenceDraftCount
  sequenceDraftCount
  moderationStyle
  moderationGuidelines {
    ...RevisionDisplay
  }
  bannedUserIds
  location
  googleLocation
  mapLocation
  mapLocationSet
  mapMarkerText
  htmlMapMarkerText
  mongoLocation
  shortformFeedId
  viewUnreviewedComments
  auto_subscribe_to_my_posts
  auto_subscribe_to_my_comments
  autoSubscribeAsOrganizer
  petrovPressedButtonDate
  petrovOptOut
  sortDraftsBy
  email
  emails
  banned
  ...SharedUserBooleans
  noindex
  paymentEmail
  paymentInfo
  goodHeartTokens
  postingDisabled
  allCommentingDisabled
  commentingOnOtherUsersDisabled
  conversationsDisabled
}

fragment UsersProfileEdit on User {
  _id
  slug
  displayName
  jobTitle
  organization
  careerStage
  profileImageId
  biography {
    ...RevisionEdit
  }
  howOthersCanHelpMe {
    ...RevisionEdit
  }
  howICanHelpOthers {
    ...RevisionEdit
  }
  profileTagIds
  organizerOfGroupIds
  organizerOfGroups {
    ...localGroupsBase
  }
  programParticipation
  mapLocation
  website
  linkedinProfileURL
  facebookProfileURL
  blueskyProfileURL
  twitterProfileURL
  githubProfileURL
}

fragment UsersSocialMediaInfo on User {
  ...UsersProfile
  twitterProfileURLAdmin
}

fragment UsersWithReviewInfo on User {
  ...UsersMinimumInfo
  reviewVoteCount
  email
}

fragment VotesDefaultFragment on Vote {
  _id
  schemaVersion
  createdAt
  legacyData
  documentId
  collectionName
  userId
  authorIds
  voteType
  extendedVoteType
  power
  afPower
  cancelled
  isUnvote
  votedAt
  documentIsAf
  silenceNotification
}

fragment WithVoteComment on Comment {
  __typename
  _id
  currentUserVote
  currentUserExtendedVote
  baseScore
  extendedScore
  score
  afBaseScore
  afExtendedScore
  voteCount
}

fragment WithVoteElectionCandidate on ElectionCandidate {
  __typename
  _id
  score
  baseScore
  extendedScore
  afBaseScore
  voteCount
  currentUserVote
  currentUserExtendedVote
}

fragment WithVoteMultiDocument on MultiDocument {
  ...MultiDocumentMinimumInfo
}

fragment WithVotePost on Post {
  __typename
  _id
  currentUserVote
  currentUserExtendedVote
  baseScore
  extendedScore
  score
  afBaseScore
  afExtendedScore
  voteCount
}

fragment WithVoteRevision on Revision {
  __typename
  _id
  currentUserVote
  currentUserExtendedVote
  baseScore
  extendedScore
  score
  voteCount
}

fragment WithVoteTag on Tag {
  ...TagBasicInfo
}

fragment WithVoteTagRel on TagRel {
  __typename
  _id
  score
  baseScore
  extendedScore
  afBaseScore
  voteCount
  currentUserVote
  currentUserExtendedVote
}

fragment emailHistoryFragment on LWEvent {
  _id
  createdAt
  userId
  name
  properties
}

fragment lastEventFragment on LWEvent {
  _id
  createdAt
  documentId
  userId
  name
  important
  properties
  intercom
}

fragment localGroupsBase on Localgroup {
  _id
  createdAt
  organizerIds
  organizers {
    ...UsersMinimumInfo
  }
  lastActivity
  name
  nameInAnotherLanguage
  isOnline
  location
  googleLocation
  mongoLocation
  types
  categories
  contactInfo
  facebookLink
  facebookPageLink
  meetupLink
  slackLink
  website
  bannerImageId
  inactive
  deleted
}

fragment localGroupsEdit on Localgroup {
  ...localGroupsBase
  contents {
    ...RevisionEdit
  }
}

fragment localGroupsHomeFragment on Localgroup {
  ...localGroupsBase
  contents {
    ...RevisionDisplay
  }
}

fragment localGroupsIsOnline on Localgroup {
  _id
  name
  isOnline
}

fragment lwEventsAdminPageFragment on LWEvent {
  _id
  createdAt
  userId
  user {
    ...UsersMinimumInfo
  }
  name
  documentId
  important
  properties
  intercom
}

fragment messageListFragment on Message {
  _id
  user {
    ...UsersMinimumInfo
    profileImageId
  }
  contents {
    html
    plaintextMainText
  }
  createdAt
  conversationId
}

fragment newEventFragment on LWEvent {
  _id
  createdAt
  userId
  name
  important
  properties
  intercom
}

fragment newRSSFeedFragment on RSSFeed {
  _id
  userId
  createdAt
  ownedByUser
  displayFullContent
  nickname
  url
  status
  importAsDraft
}

fragment reviewAdminDashboard on ReviewVote {
  _id
  createdAt
  userId
  user {
    _id
    displayName
    karma
  }
}

fragment reviewVoteFragment on ReviewVote {
  _id
  createdAt
  userId
  postId
  qualitativeScore
  quadraticScore
  comment
  year
  dummy
  reactions
}

fragment reviewVoteWithUserAndPost on ReviewVote {
  ...reviewVoteFragment
  user {
    ...UsersMinimumInfo
    email
    emails
  }
  post {
    ...PostsMinimumInfo
  }
}